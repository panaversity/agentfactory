# Chapter 49: Docker for AI Services — Implementation Plan

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: specs/001-ch49-docker-restructure/spec.md
**Created**: 2025-12-27
**Constitution**: v7.0.0 (Agent Factory Paradigm)

---

## I. Chapter Analysis

### Chapter Type

**Technical/Code-Focused** — This chapter requires hands-on Dockerfile writing, container execution, and practical debugging. Learning objectives use "apply/create/implement" verbs and code examples are required throughout. The running example (In-Memory Task API) provides consistent code scaffolding across lessons.

### Concept Density Analysis

**Core Concepts** (from spec): 12 concepts

1. Container vs VM architecture
2. Docker Engine/Desktop/containerd relationship
3. Dockerfile syntax (FROM, WORKDIR, COPY, RUN, CMD, EXPOSE)
4. Docker CLI commands (build, run, logs, exec, inspect)
5. Layer caching and build optimization
6. Multi-stage builds (build vs runtime stages)
7. Base image selection (slim vs alpine vs distroless)
8. Container lifecycle (start, stop, restart, remove)
9. Container debugging (logs, exec, port conflicts)
10. Production hardening (env vars, health checks, non-root)
11. Skill creation methodology (Persona + Questions + Principles)
12. Spec-driven containerization workflow

**Complexity Assessment**: Standard-to-Complex (6 L1 foundation lessons, 1 L3 skill creation, 1 L4 capstone)

**Proficiency Tier**: B1 (Intermediate) — from chapter-index.md

**Justified Lesson Count**: 8 lessons

- Layer 1 (Manual): 6 lessons (concepts 1-10, building vocabulary and hands-on skills)
- Layer 3 (Intelligence): 1 lesson (concept 11, create reusable skill)
- Layer 4 (Capstone): 1 lesson (concept 12, spec-driven integration)

**Total**: 8 lessons (reduced from 14, aligned with spec requirements)

**Reasoning**: The 14-lesson original structure included networking deep-dive (deferred to Kubernetes), Docker Compose (deferred to Kubernetes), Docker Engine architecture theory (not practical), and Gordon AI features (availability risk). The 8-lesson structure focuses on core containerization skills needed for Digital FTE production: write Dockerfiles, debug containers, optimize images, harden for production, create reusable skill, apply spec-driven workflow.

---

## II. Success Evals (from Spec)

**Predefined Success Criteria** (evals-first requirement):

1. **SC-001**: Chapter contains exactly 8 lessons (down from 14)
2. **SC-002**: Total chapter duration is 6 hours (360 minutes) or less
3. **SC-003**: Students can containerize the Task API within 45 minutes following Lesson 3
4. **SC-004**: Multi-stage builds reduce image size by at least 70% (from ~1.2GB to under 200MB)
5. **SC-005**: All 8 lessons pass educational-validator checks
6. **SC-006**: All factual claims verified via factual-verifier
7. **SC-007**: Layer progression validated: L1 (6 lessons) → L3 (1 lesson) → L4 (1 lesson)
8. **SC-008**: Skill created in L07 successfully generates Dockerfiles for 3+ project types when tested

**All lessons below map to these evals.**

---

## III. Pedagogical Arc

| Phase | Lessons | Purpose | Pedagogical Approach |
|-------|---------|---------|---------------------|
| **Foundation** | L01-L02 | Build mental models | Direct teaching, diagrams, conceptual understanding |
| **Practice** | L03-L05 | Hands-on Dockerfile skills | Hands-on discovery, iterative optimization, debugging |
| **Integration** | L06 | Production patterns | Error analysis, security hardening, best practices |
| **Mastery** | L07-L08 | Create reusable intelligence, capstone | Skill creation, spec-driven workflow |

---

## IV. Lesson Sequence

### Lesson 01: Docker Installation and Setup (Layer 1: Manual Foundation)

**File**: `01-docker-installation-and-setup.md`
**Action**: UPDATE (minor) — Verify current content aligns with spec requirements

**Learning Objectives** (Bloom's taxonomy):

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Explain why containers exist and how they differ from virtual machines | Understand |
| LO2 | Install Docker Desktop on your operating system | Apply |
| LO3 | Verify Docker Engine is running with `docker version` | Apply |
| LO4 | Run your first container with `docker run hello-world` | Apply |
| LO5 | Configure Docker Desktop resources for AI workloads | Apply |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 6):
1. Container vs VM architecture
2. Docker Desktop GUI
3. Docker Engine
4. containerd runtime
5. Docker Hub registry
6. Resource configuration (CPU/memory allocation)

**Cognitive Load Validation**: 6 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-005, SC-007

**Content Elements**:
- Why containers matter for AI services (works on my machine problem)
- Three-way architecture comparison (manual setup vs VM vs containers)
- Platform-specific installation walkthrough (macOS/Windows/Linux)
- Verification with docker version and docker run hello-world
- Resource configuration for AI workloads

**Teaching Modality**: Direct Teaching (setup lesson)

**Quality Reference**: Current lesson structure is already well-designed. Minimal updates needed.

**Prerequisites**: None (Chapter 49 entry point)

**Estimated Duration**: 30 minutes

---

### Lesson 02: Container Fundamentals (Layer 1: Manual Foundation)

**File**: `02-container-fundamentals.md`
**Action**: UPDATE (minor) — Ensure alignment with spec

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Explain the difference between images and containers | Understand |
| LO2 | Pull images from Docker Hub with `docker pull` | Apply |
| LO3 | Explain how layers create efficient, reusable images | Understand |
| LO4 | List and manage images with `docker images` and `docker rmi` | Apply |
| LO5 | List running containers with `docker ps` | Apply |
| LO6 | Start, stop, and remove containers with `docker start/stop/rm` | Apply |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 7):
1. Images vs containers distinction
2. Docker Hub as public registry
3. Image layers and caching
4. docker pull command
5. docker images command
6. docker ps command
7. Container lifecycle (start/stop/rm)

**Cognitive Load Validation**: 7 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-005, SC-007

**Content Elements**:
- Image = blueprint, Container = running instance (class vs object analogy)
- Pulling images from Docker Hub
- Layer architecture visualization
- Container lifecycle management commands
- Cleaning up unused images and containers

**Teaching Modality**: Hands-On Discovery (exploring Docker commands)

**Quality Reference**: Current lesson structure is already well-designed.

**Prerequisites**: Lesson 01 (Docker installed and running)

**Estimated Duration**: 40 minutes

---

### Lesson 03: Writing Your First Dockerfile (Layer 1: Manual Foundation)

**File**: `03-writing-your-first-dockerfile.md`
**Action**: UPDATE — Replace generic FastAPI example with In-Memory Task API from Chapter 40

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Write a Dockerfile from scratch using FROM, WORKDIR, COPY, RUN, CMD, EXPOSE | Create |
| LO2 | Build an image with `docker build -t` and tag appropriately | Apply |
| LO3 | Run a container from custom image and verify functionality | Apply |
| LO4 | Create a .dockerignore file to exclude unnecessary files | Apply |
| LO5 | Order Dockerfile instructions to maximize layer cache hits | Analyze |
| LO6 | Pass environment variables with -e flag | Apply |
| LO7 | Map ports from container to host with -p flag | Apply |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 9):
1. Dockerfile syntax
2. FROM instruction (base image selection)
3. WORKDIR instruction
4. COPY instruction
5. RUN instruction
6. CMD instruction
7. EXPOSE instruction
8. .dockerignore file
9. Layer caching strategy

**Cognitive Load Validation**: 9 concepts <= 10 B1 limit → WITHIN LIMIT (at upper bound)

**Maps to Evals**: SC-002, SC-003, SC-005, SC-007

**Content Elements**:
- **CRITICAL UPDATE**: Use In-Memory Task API from Chapter 40 Lessons 1-5
- Step-by-step Dockerfile creation (FROM python:3.12-slim, etc.)
- UV package manager for dependency installation
- Build and run the containerized Task API
- Test CRUD endpoints at localhost:8000
- Layer caching explanation with practical demonstration

**Teaching Modality**: Hands-On Discovery (building first Dockerfile)

**Quality Reference**: Match structure of current lesson but update all code examples to use Task API

**Running Example Code** (from Chapter 40):
```python
# main.py - In-Memory Task API
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI(title="Task API")

class Task(BaseModel):
    id: int | None = None
    title: str
    completed: bool = False

tasks: list[Task] = []
next_id = 1

@app.post("/tasks", response_model=Task)
def create_task(task: Task) -> Task:
    global next_id
    task.id = next_id
    next_id += 1
    tasks.append(task)
    return task

@app.get("/tasks", response_model=list[Task])
def list_tasks() -> list[Task]:
    return tasks

@app.get("/tasks/{task_id}", response_model=Task)
def get_task(task_id: int) -> Task:
    for task in tasks:
        if task.id == task_id:
            return task
    raise HTTPException(status_code=404, detail="Task not found")

@app.put("/tasks/{task_id}", response_model=Task)
def update_task(task_id: int, updated: Task) -> Task:
    for i, task in enumerate(tasks):
        if task.id == task_id:
            updated.id = task_id
            tasks[i] = updated
            return updated
    raise HTTPException(status_code=404, detail="Task not found")

@app.delete("/tasks/{task_id}")
def delete_task(task_id: int) -> dict:
    for i, task in enumerate(tasks):
        if task.id == task_id:
            tasks.pop(i)
            return {"message": "Task deleted"}
    raise HTTPException(status_code=404, detail="Task not found")

@app.get("/health")
def health_check() -> dict:
    return {"status": "healthy"}
```

**Prerequisites**: Lesson 02 (understand images and containers)

**Estimated Duration**: 45 minutes

---

### Lesson 04: Container Lifecycle and Debugging (Layer 1: Manual Foundation)

**File**: `04-container-lifecycle-and-debugging.md`
**Action**: UPDATE — Use Task API examples for debugging scenarios

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | View container logs with `docker logs` | Apply |
| LO2 | Execute commands inside running container with `docker exec` | Apply |
| LO3 | Inspect container configuration with `docker inspect` | Apply |
| LO4 | Debug port conflicts and resolve them | Analyze |
| LO5 | Configure restart policies for container resilience | Apply |
| LO6 | Identify and fix common container startup failures | Analyze |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 7):
1. docker logs command
2. docker exec command
3. docker inspect command
4. Port conflict diagnosis
5. Restart policies (no, always, unless-stopped, on-failure)
6. Container startup failure patterns
7. Interactive shell access (-it flags)

**Cognitive Load Validation**: 7 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-005, SC-007

**Content Elements**:
- Run Task API container in detached mode (-d)
- View logs with docker logs -f (follow mode)
- Execute shell inside container with docker exec -it bash/sh
- Inspect container configuration and networking
- Debug common failures: port already in use, missing environment variables, import errors
- Set restart policies for production resilience

**Teaching Modality**: Error Analysis (debugging-focused lesson)

**Quality Reference**: Use current lesson structure with Task API debugging scenarios

**Prerequisites**: Lesson 03 (can build and run containers)

**Estimated Duration**: 40 minutes

---

### Lesson 05: Multi-Stage Builds and Optimization (Layer 1: Manual Foundation)

**File**: `05-multi-stage-builds-and-optimization.md`
**Action**: UPDATE — Use Task API for optimization examples

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Explain why multi-stage builds reduce image size | Understand |
| LO2 | Write a multi-stage Dockerfile with build and runtime stages | Create |
| LO3 | Use UV package manager for fast Python dependency installation | Apply |
| LO4 | Compare slim, alpine, and distroless base images | Analyze |
| LO5 | Optimize layers by combining RUN commands and cleaning caches | Apply |
| LO6 | Measure image size before and after optimization | Evaluate |
| LO7 | Achieve 70%+ size reduction from naive to optimized image | Apply |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 8):
1. Multi-stage build architecture
2. Build stage vs runtime stage
3. COPY --from=builder pattern
4. UV package manager
5. Base image comparison (slim/alpine/distroless)
6. Layer optimization techniques
7. Cache busting and cleanup
8. docker history command

**Cognitive Load Validation**: 8 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-004, SC-005, SC-007

**Content Elements**:
- Start with naive Dockerfile (Task API at ~1.2GB)
- Iteration 1: Use slim base image (~450MB)
- Iteration 2: Multi-stage build (~180MB)
- Iteration 3: Alpine + UV (~120MB)
- Measure at each step with docker images
- Analyze layers with docker history
- Demonstrate 85-90% size reduction

**Teaching Modality**: Iterative Optimization (progressive improvement)

**Quality Reference**: Current lesson is excellent quality. Update to use Task API consistently.

**Prerequisites**: Lesson 04 (can debug containers)

**Estimated Duration**: 50 minutes

---

### Lesson 06: Production Hardening (Layer 1: Manual Foundation)

**File**: `06-production-hardening.md`
**Action**: CREATE (new lesson)

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Configure environment variables for container configuration | Apply |
| LO2 | Implement health check endpoints and Docker HEALTHCHECK instruction | Create |
| LO3 | Run containers as non-root user for security | Apply |
| LO4 | Use ARG and ENV instructions appropriately | Apply |
| LO5 | Create production-ready Dockerfile with all hardening patterns | Create |
| LO6 | Verify health check status with docker inspect | Evaluate |

**Stage**: Layer 1 (Manual Foundation)

**CEFR Proficiency**: B1

**New Concepts** (count: 8):
1. Environment variable configuration
2. ENV instruction in Dockerfile
3. ARG instruction (build-time variables)
4. HEALTHCHECK instruction
5. Health check endpoints in FastAPI
6. Non-root user creation (RUN adduser)
7. USER instruction in Dockerfile
8. Production Dockerfile patterns

**Cognitive Load Validation**: 8 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-005, SC-007

**Content Elements**:
- Environment variables for configuration (DATABASE_URL, API_KEY patterns)
- Health check implementation (FastAPI /health endpoint)
- Docker HEALTHCHECK instruction with curl/wget
- Non-root user security (adduser, USER instruction)
- Production Dockerfile combining all patterns
- Test health check with docker inspect --format

**Teaching Modality**: Best Practices Integration (security-focused)

**Quality Reference**: Match structure of Lesson 05 with focus on security patterns

**Production Dockerfile Template**:
```dockerfile
# Stage 1: Build
FROM python:3.12-alpine AS builder
WORKDIR /app
RUN pip install uv
COPY requirements.txt .
RUN uv pip install --system --no-cache -r requirements.txt

# Stage 2: Runtime
FROM python:3.12-alpine

# Create non-root user
RUN adduser -D -u 1000 appuser

WORKDIR /app

# Copy dependencies from builder
COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# Copy application code
COPY --chown=appuser:appuser main.py .

# Environment configuration
ENV PYTHONUNBUFFERED=1

# Switch to non-root user
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8000/health || exit 1

EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Prerequisites**: Lesson 05 (can write optimized Dockerfiles)

**Estimated Duration**: 45 minutes

---

### Lesson 07: Docker Image Builder Skill (Layer 3: Intelligence Design)

**File**: `07-docker-image-builder-skill.md`
**Action**: CREATE (new lesson)

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Identify recurring patterns from Lessons 1-6 worth encoding | Analyze |
| LO2 | Design skill persona for Docker expertise | Create |
| LO3 | Write analysis questions that activate reasoning mode | Create |
| LO4 | Define principles for production Dockerfile decisions | Create |
| LO5 | Create SKILL.md file following canonical format | Create |
| LO6 | Test skill with novel project scenarios | Evaluate |

**Stage**: Layer 3 (Intelligence Design)

**CEFR Proficiency**: B1 (elevated to intelligence design)

**New Concepts** (count: 6):
1. Skill as reusable intelligence
2. Persona + Questions + Principles pattern
3. SKILL.md file format
4. Skill activation triggers
5. Skill testing methodology
6. Intelligence accumulation

**Cognitive Load Validation**: 6 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-005, SC-007, SC-008

**Content Elements**:
- Review patterns from Lessons 1-6 (multi-stage builds, UV, alpine, hardening)
- Design persona: "Think like a DevOps engineer optimizing container images"
- Create analysis questions:
  - What's the target deployment environment (Kubernetes, bare Docker)?
  - What's the base image strategy (slim/alpine/distroless)?
  - Are there large files (>100MB) that should be volume-mounted?
  - What security requirements apply (non-root, read-only fs)?
- Define principles:
  - Multi-stage builds for all Python projects
  - UV package manager for 10-100x faster installs
  - Health checks mandatory for orchestrated deployments
  - Non-root user for production security
- Test skill with 3 scenarios: Python CLI, FastAPI service, ML inference service

**Teaching Modality**: Skill Creation (intelligence design)

**Quality Reference**: Match `.claude/skills/creating-skills/SKILL.md` canonical format

**Canonical Skill Format**:
```markdown
---
name: production-dockerfile
description: This skill should be used when containerizing Python applications for production deployment. Use when creating Dockerfiles, optimizing image size, or hardening containers for security.
---

# Production Dockerfile Skill

## Persona

Think like a DevOps engineer who optimizes container images for production Kubernetes deployments. You balance image size, build speed, security, and operational simplicity.

## Analysis Questions

Before generating a Dockerfile, analyze:

1. **Deployment Target**: Kubernetes cluster, Docker Compose, bare Docker?
2. **Base Image Strategy**: What constraints apply (security, size, compatibility)?
3. **Large Files**: Are there model files or data that should be volume-mounted?
4. **Security Requirements**: Non-root user required? Read-only filesystem?
5. **Health Monitoring**: What endpoints indicate service health?

## Principles

1. **Multi-Stage Always**: Separate build dependencies from runtime
2. **UV for Speed**: Use UV package manager (10-100x faster than pip)
3. **Alpine Default**: Start with alpine, fall back to slim if compatibility issues
4. **Health Checks Mandatory**: Every production container needs HEALTHCHECK
5. **Non-Root Default**: Run as non-root user unless explicitly required otherwise
6. **Environment Configuration**: All configuration via environment variables
7. **No Secrets in Image**: Never COPY .env or credentials into image

## Output Format

[Dockerfile structure guidelines...]
```

**Skill Output Path**: `.claude/skills/production-dockerfile/SKILL.md`

**Prerequisites**: Lessons 1-6 (accumulated Docker knowledge)

**Estimated Duration**: 50 minutes

---

### Lesson 08: Capstone: Containerize Your API (Layer 4: Spec-Driven Integration)

**File**: `08-capstone-containerize-your-api.md`
**Action**: CREATE (new lesson)

**Learning Objectives**:

| ID | Objective | Bloom's Level |
|----|-----------|---------------|
| LO1 | Write specification for containerization project BEFORE implementation | Create |
| LO2 | Apply production-dockerfile skill to generate Dockerfile | Apply |
| LO3 | Containerize SQLModel + Neon Task API from Chapter 40 Lesson 7 | Create |
| LO4 | Configure database connection via environment variable | Apply |
| LO5 | Build production-ready container image under 200MB | Create |
| LO6 | Push container image to registry (Docker Hub or GHCR) | Apply |
| LO7 | Validate container works on different machine | Evaluate |

**Stage**: Layer 4 (Spec-Driven Integration)

**CEFR Proficiency**: B1

**New Concepts** (count: 5):
1. Specification-first containerization workflow
2. Skill composition (using production-dockerfile skill)
3. Database URL configuration for containers
4. Container registry push workflow
5. Cross-machine validation

**Cognitive Load Validation**: 5 concepts <= 10 B1 limit → WITHIN LIMIT

**Maps to Evals**: SC-002, SC-004, SC-005, SC-007

**Content Elements**:

**Phase 1: Specification Writing (BEFORE any code)**
```markdown
## Containerization Specification

### Intent
Containerize the SQLModel + Neon Task API for production deployment.

### Constraints
- Image size: <200MB
- Security: Non-root user, health check
- Configuration: Database URL via environment variable
- Registry: Push to Docker Hub or GitHub Container Registry

### Success Criteria
- Container builds successfully
- All CRUD endpoints work when running containerized
- Health check passes
- Image can be pulled and run on different machine
```

**Phase 2: Skill Application**
- Invoke production-dockerfile skill
- Answer skill's analysis questions
- Generate production Dockerfile

**Phase 3: Implementation**
- Build image with docker build
- Tag appropriately (username/task-api:v1)
- Run locally with DATABASE_URL environment variable
- Test all endpoints

**Phase 4: Registry Push**
- Login to registry (docker login)
- Push image (docker push)
- Pull on different machine or cloud VM
- Verify functionality

**Teaching Modality**: Spec-Driven Integration (capstone)

**Quality Reference**: Match capstone structure from other chapters (specification first, skill composition, validation)

**SQLModel Task API** (from Chapter 40 Lesson 7):
```python
# main.py - SQLModel + Neon version
from fastapi import FastAPI, HTTPException
from sqlmodel import SQLModel, Field, Session, create_engine, select
import os

DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://...")

engine = create_engine(DATABASE_URL)

class Task(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    completed: bool = False

app = FastAPI(title="Task API")

@app.on_event("startup")
def on_startup():
    SQLModel.metadata.create_all(engine)

# CRUD endpoints similar to in-memory version...
```

**Prerequisites**: Lessons 1-7 (all Docker skills + production-dockerfile skill)

**Estimated Duration**: 60 minutes

---

## V. Skill Dependencies

**Skill Dependency Graph**:

```
[Container Fundamentals] (no prerequisites) → Lesson 01-02
    ↓
[Dockerfile Writing] (requires Container Fundamentals) → Lesson 03
    ↓
[Container Debugging] (requires Dockerfile Writing) → Lesson 04
    ↓
[Image Optimization] (requires Container Debugging) → Lesson 05
    ↓
[Production Hardening] (requires Image Optimization) → Lesson 06
    ↓
[Skill Creation] (requires Production Hardening) → Lesson 07
    ↓
[Spec-Driven Containerization] (requires Skill Creation) → Lesson 08
```

**Cross-Chapter Dependencies**:

| Dependency | Source Chapter | Content Used |
|------------|----------------|--------------|
| In-Memory Task API | Chapter 40 Lessons 1-5 | Running example for Lessons 03-07 |
| SQLModel + Neon Task API | Chapter 40 Lesson 7 | Capstone containerization target |
| FastAPI fundamentals | Chapter 40 | Pydantic models, endpoints, uvicorn |
| UV package manager | Part 5 | Assumed familiarity |
| Command line basics | Chapter 7 | Terminal navigation, file operations |

**Validation**: All prerequisite content exists and is implemented.

---

## VI. Assessment Plan

### Formative Assessments (During Lessons)

| Lesson | Assessment Type | Description |
|--------|-----------------|-------------|
| L01 | Verification | docker version shows Client + Server |
| L02 | Practical | Can pull, list, and remove images |
| L03 | Hands-On | Build and run Task API container, test /health endpoint |
| L04 | Debugging | Identify and fix simulated container failure |
| L05 | Measurement | Document image size reduction (naive to optimized) |
| L06 | Integration | Container passes health check, runs as non-root |
| L07 | Creation | SKILL.md file produces valid Dockerfiles |
| L08 | Capstone | Container image pushed to registry, works on different machine |

### Summative Assessment (End of Chapter)

**Capstone Deliverable** (Lesson 08):
- spec.md for containerization project
- Production Dockerfile using skill patterns
- Container image under 200MB
- Successful registry push and cross-machine validation

---

## VII. Content Implementation Guidelines

### "Try With AI" Requirements

Each lesson must include 3 "Try With AI" prompts:

1. **Exploration prompt**: Investigate a concept from the lesson
2. **Application prompt**: Apply learned skills to new scenario
3. **Reflection prompt**: Connect to student's own projects/goals

**Example format (from Lesson 03)**:
```markdown
## Try With AI

### Part 1: Analyze Your Dockerfile

Ask AI:
"I just wrote my first Dockerfile for a FastAPI application.
Here's what I have: [paste Dockerfile]

Help me understand:
1. What does each instruction do?
2. Is the layer order optimized for caching?
3. What would happen if I changed X to Y?"

**What you're learning**: Critical analysis of Dockerfile structure.

### Part 2: Optimize for Size

Ask AI:
"My current Docker image is 450MB. I want to reduce it.
My requirements: [paste requirements.txt]

What optimization strategies would you recommend?
Walk me through the tradeoffs of each approach."

**What you're learning**: Image optimization decision-making.

### Part 3: Connect to Your Project

Ask AI:
"I'm building [describe your project/API].
Based on what I learned about Dockerfiles today,
help me plan the containerization approach.
Ask me questions about my deployment requirements."

**What you're learning**: Applying Docker patterns to your specific context.
```

### Running Example Consistency

**Lessons 03-07**: Use In-Memory Task API consistently
- Same main.py file
- Same requirements.txt (fastapi, uvicorn, pydantic)
- Progressively optimize the same Dockerfile

**Lesson 08**: Switch to SQLModel + Neon Task API
- Adds database dependency (sqlmodel, psycopg2-binary)
- Requires DATABASE_URL environment variable
- More complex production scenario

### Output Block Requirements

All commands must include expected output:

```bash
docker build -t task-api:v1 .
```

**Output:**
```
[+] Building 12.3s (9/9) FINISHED
 => [internal] load build definition from Dockerfile
 => [1/5] FROM python:3.12-alpine
 => [2/5] WORKDIR /app
 ...
Successfully tagged task-api:v1
```

---

## VIII. File Operations Summary

### Files to DELETE (18 files)

| File | Reason |
|------|--------|
| `06-docker-networking-fundamentals.md` | Deferred to Kubernetes |
| `06-docker-networking-fundamentals.summary.md` | Summary file |
| `07-container-to-container-communication.md` | Deferred to Kubernetes |
| `07-container-to-container-communication.summary.md` | Summary file |
| `08-volumes-persistent-data.md` | Not needed for stateless API |
| `08-volumes-persistent-data.summary.md` | Summary file |
| `09-docker-engine-architecture.md` | Pure theory, no practical value |
| `09-docker-engine-architecture.summary.md` | Summary file |
| `10-docker-compose-for-development.md` | Deferred to Kubernetes |
| `10-docker-compose-for-development.summary.md` | Summary file |
| `11-security-and-best-practices.md` | Merged into L06 |
| `11-security-and-best-practices.summary.md` | Summary file |
| `12-ai-assisted-docker-with-gordon.md` | Gordon availability risk |
| `12-ai-assisted-docker-with-gordon.summary.md` | Summary file |
| `13-capstone-production-ready-agent.md` | Replaced by L08 |
| `13-capstone-production-ready-agent.summary.md` | Summary file |
| `14-building-production-dockerfile-skill.md` | Content moves to L07 |
| `14-building-production-dockerfile-skill.summary.md` | Summary file |

### Files to UPDATE (5 files)

| File | Changes |
|------|---------|
| `01-docker-installation-and-setup.md` | Minor: verify spec alignment |
| `02-container-fundamentals.md` | Minor: verify spec alignment |
| `03-writing-your-first-dockerfile.md` | Major: replace generic example with Task API |
| `04-container-lifecycle-and-debugging.md` | Major: use Task API debugging examples |
| `05-multi-stage-builds-and-optimization.md` | Major: use Task API optimization examples |

### Files to CREATE (4 files)

| File | Description |
|------|-------------|
| `06-production-hardening.md` | New L1 lesson on env vars, health checks, non-root |
| `07-docker-image-builder-skill.md` | New L3 skill creation lesson |
| `08-capstone-containerize-your-api.md` | New L4 capstone lesson |
| `README.md` | Update chapter structure, remove references to deleted lessons |

### Skill to CREATE (1 file)

| File | Description |
|------|-------------|
| `.claude/skills/production-dockerfile/SKILL.md` | Docker containerization skill |

---

## IX. Validation Checklist

### Chapter-Level Validation

- [x] Chapter type identified: Technical/Code-Focused
- [x] Concept density analysis documented: 12 core concepts
- [x] Lesson count justified: 8 lessons (reduced from 14)
- [x] All evals from spec covered by lessons
- [x] All lessons map to at least one eval

### Layer Progression Validation

- [x] Lessons 1-6: Layer 1 (Manual Foundation)
- [x] Lesson 7: Layer 3 (Intelligence Design/Skill Creation)
- [x] Lesson 8: Layer 4 (Spec-Driven Integration)
- [x] No AI collaboration lessons (L2) — appropriate for foundational Docker skills
- [x] Spec-first only in Layer 4 (Lesson 8)

### Cognitive Load Validation

- [x] All lesson concept counts documented
- [x] B1 proficiency limits respected (max 10 concepts)
- [x] No lesson exceeds cognitive load limit

### Running Example Validation

- [x] Lessons 03-07: Use In-Memory Task API from Chapter 40 Lessons 1-5
- [x] Lesson 08: Use SQLModel + Neon Task API from Chapter 40 Lesson 7
- [x] Code consistency maintained across lessons

### Quality Requirements

- [ ] Each lesson has full YAML frontmatter
- [ ] Each lesson has 3 "Try With AI" prompts
- [ ] All code examples have Output blocks
- [ ] Skill follows canonical format (`.claude/skills/*/SKILL.md`)

---

## X. Implementation Order

**Recommended implementation sequence**:

1. **Phase 1: Deletion** — Remove obsolete files (18 files)
2. **Phase 2: Updates** — Update existing lessons (5 files)
   - L01-L02: Minor updates for spec alignment
   - L03-L05: Major updates for Task API running example
3. **Phase 3: Creation** — Create new lessons (3 files)
   - L06: Production Hardening
   - L07: Docker Image Builder Skill
   - L08: Capstone
4. **Phase 4: Skill Creation** — Create production-dockerfile skill
5. **Phase 5: README Update** — Update chapter README with new structure
6. **Phase 6: Validation** — Run educational-validator on all lessons

**Estimated total duration**: 6-8 hours of implementation work

---

## XI. Duration Summary

| Lesson | Duration | Cumulative |
|--------|----------|------------|
| L01: Docker Installation and Setup | 30 min | 30 min |
| L02: Container Fundamentals | 40 min | 70 min |
| L03: Writing Your First Dockerfile | 45 min | 115 min |
| L04: Container Lifecycle and Debugging | 40 min | 155 min |
| L05: Multi-Stage Builds and Optimization | 50 min | 205 min |
| L06: Production Hardening | 45 min | 250 min |
| L07: Docker Image Builder Skill | 50 min | 300 min |
| L08: Capstone: Containerize Your API | 60 min | 360 min |

**Total**: 360 minutes (6 hours) — Meets SC-002 requirement

---

**Plan Status**: READY FOR IMPLEMENTATION

**Next Step**: Execute Phase 1 (file deletion) or invoke content-implementer for lesson updates/creation.
