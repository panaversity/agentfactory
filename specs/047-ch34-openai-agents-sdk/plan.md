# Implementation Plan: Chapter 34 — OpenAI Agents SDK (Production Mastery)

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: `/specs/047-ch34-openai-agents-sdk/spec.md`
**Constitution**: v7.0.0 (Agent Factory Paradigm)
**Created**: 2025-12-26
**Status**: Ready for Lesson Implementation

---

## I. Chapter Analysis

### Chapter Type Recognition

**Classification**: Technical/Code-Focused
- **Recognition signals**: Spec focuses on API mastery (FR-001 through FR-041), code examples required in every lesson, learning objectives use "implement/build/create" verbs
- **Structure**: Sequential lessons (8 total) that build from SDK basics through production patterns to capstone
- **Content elements**: Code examples with type hints, practical exercises (function tools, context objects, agents as tools), technical assessments
- **Closure**: Layer 4 Capstone producing complete customer support Digital FTE

### Concept Density Analysis

**Core Concepts** (from spec—excluding sub-concepts and examples):

1. Agent primitives (Agent class, Runner, execution lifecycle)
2. Function tools (@function_tool decorator, type hints, docstrings)
3. Context objects (Pydantic models, RunContextWrapper, state mutations)
4. Agents as tools (agent.as_tool(), custom_output_extractor, orchestration)
5. Agent composition (agent.clone(), tool lists, dynamic tooling)
6. Handoffs (basic lists, handoff() function, callbacks, context injection)
7. Message filtering (HandoffInputData, input_filter, handoff_filters utilities)
8. Guardrails (input/output guardrails, agent-based validation, tripwires)
9. Sessions (SQLiteSession, file persistence, history management)
10. Advanced sessions (AdvancedSQLiteSession, branching, usage tracking)
11. Lifecycle hooks (RunHooks, event callbacks, lifecycle phases)
12. Tracing (gen_trace_id(), trace(), custom_span(), group_id linking)
13. Observable patterns (context.usage tracking, token monitoring)
14. MCP integration (MCPServerStdio, agent mcp_servers configuration)
15. Conversation loops (to_input_list(), result.last_agent, conversation management)

**Complexity Assessment**: Complex technical patterns
- Standard/Advanced complexity: 15 core concepts
- B1-B2 → C1 proficiency transition
- Each concept builds on previous (sequential dependencies)

**Proficiency Tier**: B1-B2 → C1 (from spec: "Build production FTEs")
- B1-B2: Early lessons (SDK setup, basic patterns)
- C1: Later lessons (guardrails, tracing, multi-agent orchestration)

**Justified Lesson Count**: 8 lessons
- Layer 1 (Manual Foundation): 1-2 lessons (SDK setup, hello world, basic concepts)
- Layer 2 (AI Collaboration): 3-4 lessons (function tools, context objects, handoffs, guardrails with Three Roles demonstrations)
- Layer 3 (Intelligence Design): 1-2 lessons (create reusable skills from patterns)
- Layer 4 (Capstone): 1 lesson (full customer support FTE with spec-first approach)
- **Total**: 8 lessons (justified by 15 core concepts + proficiency tier transition B1→C1)

**Reasoning for 8 lessons**:
- Lesson 1-2: Manual foundation (SDK primitives, basic agent pattern, running examples without AI)
- Lesson 3-6: AI collaboration + progressive complexity (function tools, context, agents as tools, handoffs, guardrails)
- Lesson 7: Intelligence design (create reusable skill from accumulated patterns)
- Lesson 8: Layer 4 capstone (customer support FTE with spec-first orchestration)

---

## II. Success Evals Mapping (from Spec)

**Specification's Predefined Success Criteria** (evals-first requirement):

| Eval ID | Success Criterion | Which Lesson(s) Teach | Assessment Type |
|---------|-------------------|----------------------|-----------------|
| **SC-001** | Students can implement context objects that persist across tools and agents | Lesson 2 (manual), Lesson 4 (AI collab) | Hands-on: Create context model + tools accessing context |
| **SC-002** | Students can build orchestrator with 3+ sub-agents as tools | Lesson 3 (manual agents as tools), Lesson 8 (capstone multi-agent) | Hands-on: Implement manager agent + 3 specialist agents |
| **SC-003** | Students can implement handoff with callback that injects runtime data | Lesson 4 (manual handoff basics), Lesson 5 (with callback) | Hands-on: Implement on_handoff callback with context mutation |
| **SC-004** | Students can implement agent-based guardrail with structured output | Lesson 5 (guardrail implementation) | Hands-on: Create guardrail agent + detect violations |
| **SC-005** | Students can use AdvancedSQLiteSession with branching | Lesson 6 (session management) | Hands-on: Branch conversation, merge histories |
| **SC-006** | Students can implement full RunHooks with usage tracking | Lesson 7 (tracing/hooks) | Hands-on: Log all lifecycle events, track token usage |
| **SC-007** | Students can trace multi-agent workflow with custom spans | Lesson 7 (tracing/hooks) | Hands-on: Generate trace with sub-spans, view in dashboard |
| **SC-008** | Capstone matches production quality of customer_service example | Lesson 8 (capstone) | Validated: Customer support FTE implements all 8 success criteria |

**All lessons map to evals**. All evals covered.

---

## III. Lesson Sequence (8 Lessons)

### Lesson 1: SDK Setup & First Agent (Layer 1: Manual Foundation)

**Learning Objective**: Set up OpenAI Agents SDK and run a functional agent without AI assistance

**Stage**: Layer 1 (Manual Foundation — no AI collaboration yet)

**CEFR Proficiency**: B1 (independent language use)

**New Concepts** (count: 6 ≤ B1 limit of 10):
1. SDK installation (pip install openai-agents)
2. API key configuration (OPENAI_API_KEY environment variable)
3. Agent class and instantiation
4. Runner.run_sync() execution pattern
5. Basic prompting and response handling
6. LiteLLM model alternative (LitellmModel with anthropic/claude-3-5-sonnet)

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: None directly (foundation-only lesson)

**Content Elements**:
- **Setup section** (5-10 min): Step-by-step SDK installation, environment configuration
- **Hello World example** (15-20 min): Create minimal agent that greets user, run with Runner.run_sync()
- **Manual execution** (10-15 min): Students execute basic agent by hand, observe responses
- **LiteLLM alternative** (10-15 min): Demonstrate same agent using LitellmModel("anthropic/claude-3-5-sonnet")
- **No AI assistance**: Students type code by hand, understand basic flow without AI collaboration

**Prerequisites**: Chapter 33 (Conceptual introduction to agents), Part 5 Python skills

**Estimated Time**: 50-60 minutes

---

### Lesson 2: Function Tools & Context Objects (Layer 1: Manual Foundation)

**Learning Objective**: Implement function tools with type hints and context objects that persist state across tool calls

**Stage**: Layer 1 (Manual Foundation — manual tool creation, no AI yet)

**CEFR Proficiency**: B1

**New Concepts** (count: 7 ≤ B1 limit of 10):
1. @function_tool decorator for tool definition
2. Type hints in function signatures (e.g., name: str, age: int)
3. Docstrings as tool descriptions
4. Pydantic BaseModel for context objects
5. RunContextWrapper[ContextType] type annotation
6. Context access in tool functions (context.context.attribute)
7. State mutations persisting across tool calls

**Cognitive Load Validation**: 7 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-001 (context objects persist across tools)

**Content Elements**:
- **Function tool basics** (15-20 min): Decorator syntax, type hints, docstrings
- **Context model definition** (15-20 min): Create TaskManagerContext with user_id, current_project, tasks_added
- **Tool implementation** (15-20 min): Implement add_task() tool that accesses and mutates context
- **Manual execution** (10-15 min): Run agent, call tool, observe context mutations
- **Multiple tools** (10-15 min): Add multiple tools that all modify same context

**Prerequisites**: Lesson 1 (SDK setup), Part 5 Python (type hints, Pydantic Chapter 30)

**Estimated Time**: 65-75 minutes

---

### Lesson 3: Agents as Tools & Orchestration (Layer 2: AI Collaboration)

**Learning Objective**: Build orchestrator agent that calls specialist agents as tools using AI collaboration patterns

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B1-B2

**New Concepts** (count: 5 ≤ B1 limit of 10):
1. agent.as_tool() for converting agents to tools
2. tool_name and tool_description for agent tools
3. custom_output_extractor for structured output control
4. Orchestrator pattern (manager agent coordinates specialists)
5. Dynamic composition (passing different agents at runtime)

**Cognitive Load Validation**: 5 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-002 (orchestrator with 3+ sub-agents)

**Three Roles Demonstrations** (REQUIRED for Layer 2):
- **AI as Teacher**: Suggests agent.as_tool() pattern and custom_output_extractor strategy
- **AI as Student**: Adapts to student's information needs (specific data vs full conversation)
- **Co-Worker**: Iterates toward dynamic agent composition for runtime flexibility

**Content Elements**:
- **Agent as tool concept** (10-15 min): Theory - how agents become orchestrator tools
- **Orchestrator pattern** (15-20 min): Implement manager agent with planning + execution specialists
- **Custom output extraction** (15-20 min): Control what sub-agent output flows forward
- **Three Roles demo** (20-25 min): Explicit collaboration showing all three roles
- **Practice exercise** (15-20 min): Students implement new orchestrator with 3+ specialist agents

**Prerequisites**: Lessons 1-2, Chapter 33 conceptual foundation

**Estimated Time**: 75-100 minutes

---

### Lesson 4: Handoffs & Message Filtering (Layer 2: AI Collaboration)

**Learning Objective**: Implement handoff patterns with callbacks and message filtering for context-preserving transfers

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B1-B2

**New Concepts** (count: 6 ≤ B1 limit of 10):
1. Basic handoffs list (handoffs=[agent1, agent2])
2. handoff() function with agent parameter
3. on_handoff callback for context injection
4. HandoffInputData structure for message filtering
5. input_filter parameter for transforming history
6. handoff_filters.remove_all_tools and other utility filters

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-003 (handoff with callback that injects runtime data)

**Three Roles Demonstrations** (REQUIRED for Layer 2):
- **AI as Teacher**: Suggests on_handoff callbacks for context injection
- **AI as Student**: Learns to filter history based on specialist information needs
- **Co-Worker**: Discovers bidirectional handoff pattern (specialist can hand back)

**Content Elements**:
- **Handoff basics** (10-15 min): Simple handoffs list, agent transfer
- **on_handoff callbacks** (15-20 min): Context injection before handoff
- **Message filtering** (15-20 min): Filter history before sending to specialist
- **Bidirectional handoffs** (10-15 min): Specialist can hand back to orchestrator
- **Three Roles demo** (20-25 min): Explicit collaboration scenarios
- **Practice exercise** (15-20 min): Implement bidirectional handoffs in TaskManager

**Prerequisites**: Lessons 1-3, context objects from Lesson 2

**Estimated Time**: 75-100 minutes

---

### Lesson 5: Guardrails & Agent-Based Validation (Layer 2: AI Collaboration)

**Learning Objective**: Implement input/output guardrails with agent-based validation using structured outputs

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B2

**New Concepts** (count: 6 ≤ B1 limit of 10):
1. @input_guardrail decorator for input validation
2. @output_guardrail decorator for output validation
3. GuardrailFunctionOutput with tripwire_triggered flag
4. Agent-based guardrails (guardrail calls another agent)
5. Exception handling (InputGuardrailTripwireTriggered)
6. Structured output validation patterns

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-004 (agent-based guardrail with structured output)

**Three Roles Demonstrations** (REQUIRED for Layer 2):
- **AI as Teacher**: Teaches agent-based validation vs simple checks
- **AI as Student**: Learns semantic distinctions (request vs mention)
- **Co-Worker**: Discovers user-friendly validation messages through iteration

**Content Elements**:
- **Guardrail decorator basics** (10-15 min): @input_guardrail syntax, return structure
- **Simple validation** (10-15 min): String checks, basic guards
- **Agent-based guardrails** (15-20 min): Guardrail agent calls another agent for reasoning
- **Structured outputs** (10-15 min): GuardrailFunctionOutput with reasoning
- **Exception handling** (10-15 min): Catch InputGuardrailTripwireTriggered
- **Three Roles demo** (20-25 min): Scenarios above
- **Practice exercise** (15-20 min): Implement PII detector guardrail

**Prerequisites**: Lessons 1-4, Pydantic output models

**Estimated Time**: 75-100 minutes

---

### Lesson 6: Sessions & Conversation Memory (Layer 2: AI Collaboration)

**Learning Objective**: Persist conversation state using SQLiteSession and AdvancedSQLiteSession with branching capabilities

**Stage**: Layer 2 (AI Collaboration with Three Roles)

**CEFR Proficiency**: B2

**New Concepts** (count: 6 ≤ B1 limit of 10):
1. SQLiteSession for basic persistence
2. File-based session storage (session_id + file path)
3. session.get_items(limit=N) for history retrieval
4. AdvancedSQLiteSession for production scenarios
5. store_run_usage() for token tracking
6. create_branch_from_turn() for conversation branching

**Cognitive Load Validation**: 6 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-005 (AdvancedSQLiteSession with branching)

**Three Roles Demonstrations** (REQUIRED for Layer 2):
- **AI as Teacher**: Teaches AdvancedSQLiteSession for production persistence
- **AI as Student**: Learns reliability requirement (data survival across crashes)
- **Co-Worker**: Discovers efficient branching through resource consideration

**Content Elements**:
- **SQLiteSession basics** (10-15 min): Basic persistence, file storage
- **Session management** (10-15 min): Retrieve history, replay conversation
- **AdvancedSQLiteSession** (15-20 min): Token tracking, branching
- **Conversation branching** (15-20 min): Create branch from turn, switch branches
- **Three Roles demo** (20-25 min): Scenarios above
- **Practice exercise** (15-20 min): Implement branching for TaskManager

**Prerequisites**: Lessons 1-5

**Estimated Time**: 75-100 minutes

---

### Lesson 7: Tracing, Hooks & Observability (Layer 2+3: AI Collaboration & Intelligence Design)

**Learning Objective**: Implement lifecycle hooks and custom tracing for multi-agent workflow observability

**Stage**: Layer 2 extending to Layer 3 (AI Collaboration with Intelligence Design)

**CEFR Proficiency**: B2 → C1

**New Concepts** (count: 7 ≤ B1 limit of 10):
1. RunHooks class with lifecycle methods
2. Lifecycle events (on_agent_start, on_llm_start, on_tool_start, on_handoff, on_agent_end, etc.)
3. gen_trace_id() for unique trace identification
4. trace() context manager for span grouping
5. custom_span() for sub-operation tracing
6. group_id for linking related traces
7. context.usage token counting

**Cognitive Load Validation**: 7 new concepts ≤ B1 limit (10) → ✅ WITHIN LIMIT

**Maps to Evals**: SC-006 (RunHooks with usage tracking), SC-007 (multi-agent trace with custom spans)

**Three Roles Demonstrations** (REQUIRED for Layer 2):
- **AI as Teacher**: Teaches observability infrastructure patterns
- **AI as Student**: Learns to prioritize signals (reduce noise)
- **Co-Worker**: Discovers end-to-end trace correlation through iteration

**Content Elements**:
- **RunHooks lifecycle** (10-15 min): All lifecycle methods and when they fire
- **Lifecycle events** (15-20 min): What happens at each event, available context
- **Token usage tracking** (10-15 min): Access context.usage in hooks, calculate costs
- **Trace generation** (15-20 min): gen_trace_id(), trace context manager, dashboard URL
- **Custom spans** (10-15 min): custom_span() for sub-operations
- **Trace correlation** (10-15 min): group_id for linking multi-turn conversations
- **Three Roles demo** (20-25 min): Scenarios above
- **Skill creation** (15-20 min): Encapsulate observability patterns as reusable component (Layer 3)
- **Practice exercise** (15-20 min): Implement full hooks + tracing for TaskManager

**Prerequisites**: Lessons 1-6

**Estimated Time**: 100-125 minutes

---

### Lesson 8: Capstone - Customer Support FTE (Layer 4: Spec-Driven Integration)

**Learning Objective**: Implement production-quality customer support Digital FTE using specification-first approach and composed patterns from Lessons 1-7

**Stage**: Layer 4 (Spec-Driven Integration / Capstone)

**CEFR Proficiency**: C1 (advanced production systems)

**Maps to Evals**: ALL (SC-001 through SC-008 integrated)

**Content Elements**:

**Part 1: Specification Writing** (PRIMARY SKILL — 20-30 min)
- Write spec.md for customer support Digital FTE
- Define: intent (24/7 support agent), constraints (quality, cost), success criteria
- Identify: information needs, handoff points, validation requirements
- NO code yet (spec FIRST)

**Part 2: Pattern Analysis** (10-15 min)
- Map Lessons 1-7 patterns to customer support requirements
- Lesson 1-2: SDK setup, context objects (passenger_name, confirmation_number, seat_number)
- Lesson 3: Orchestrator pattern (triage coordinates FAQ/booking/escalation specialists)
- Lesson 4: Handoffs with callbacks (set flight_number on handoff)
- Lesson 5: Guardrails (abuse detection, PII filtering)
- Lesson 6: AdvancedSQLiteSession (conversation history per customer)
- Lesson 7: Tracing (complete conversation trace with group_id)

**Part 3: Component Composition** (15-20 min)
- Define all agents: orchestrator, FAQ specialist, booking specialist, escalation specialist
- Define all tools: faq_lookup_tool, update_seat, escalate_to_human
- Map handoffs: triage ↔ FAQ, triage ↔ booking, booking/FAQ ↔ escalation
- Design guardrails: input (abuse), output (verify seat exists)
- Plan session: AdvancedSQLiteSession per customer_id

**Part 4: AI Orchestration** (with Three Roles) (30-45 min)
- Implement spec using accumulated patterns
- AI as Teacher: Suggests architectural improvements
- You as Student: Validate suggestions against spec
- Convergence: Iterate on implementation quality until spec ↔ code alignment

**Part 5: Validation** (15-20 min)
- Test against spec success criteria
- Run conversation flows: FAQ → answer, booking → flight assignment, escalation trigger
- Verify: context persistence, message filtering, guardrail triggering, token tracking
- Generate trace, view in dashboard

**Part 6: Reflection** (10-15 min)
- How did patterns from Lessons 1-7 compose into this FTE?
- How did spec-first design guide implementation differently?
- How would you monetize this as a Digital FTE?

**Prerequisites**: Lessons 1-7 (all accumulated knowledge)

**Estimated Time**: 120-150 minutes (2.5 hours — substantial capstone)

---

## IV. Skill & Intelligence Design (Layer 3)

### Reusable Skills to Create

**From Lesson 3 (Agents as Tools)**:
- **Skill**: `orchestrator-multi-agent-pattern`
  - Encapsulates: agent.as_tool(), custom_output_extractor, orchestration strategy
  - Applies to: Any multi-agent system (not just TaskManager)

**From Lesson 4 (Handoffs)**:
- **Skill**: `handoff-with-context-injection`
  - Encapsulates: handoff(), on_handoff callback, message filtering
  - Applies to: Any specialist handoff scenario

**From Lesson 5 (Guardrails)**:
- **Skill**: `agent-based-guardrail-validation`
  - Encapsulates: @input_guardrail, agent-based reasoning, structured output
  - Applies to: PII detection, abuse detection, topic validation

**From Lesson 7 (Tracing)**:
- **Skill**: `production-observability-stack`
  - Encapsulates: RunHooks + tracing + group_id correlation + token tracking
  - Applies to: Any production agent requiring observability

**From Lesson 6 (Sessions)**:
- **Skill**: `conversation-persistence-and-branching`
  - Encapsulates: AdvancedSQLiteSession, branching logic, history retrieval
  - Applies to: Any agent with conversation memory needs

---

## V. Running Example: TaskManager Agent

**Continuation from Chapter 33**: Extends conceptual framework into production implementation

**Escalation across lessons**:
- L1: Basic setup + context objects with task state
- L2: Multi-agent orchestrator (planning/execution/validation specialists)
- L2: Handoffs between agents with context injection
- L2: Guardrails for task validation
- L2: Session persistence per user with branching
- L2+L3: Tracing and observability infrastructure
- L4: Complete production system from spec

---

## VI. Assessment Plan

### Formative Assessments (During Lessons)

**Lesson 1**: SDK setup verification quiz
**Lesson 2**: Context object implementation exercise
**Lesson 3**: Orchestrator with 3+ agents exercise
**Lesson 4**: Bidirectional handoff implementation
**Lesson 5**: Agent-based guardrail implementation
**Lesson 6**: Conversation branching exercise
**Lesson 7**: Full observability stack implementation

### Summative Assessment

**Lesson 8 Capstone**: Complete customer support Digital FTE meeting all spec criteria
- Evaluation: Technical review against rubric
- B2 competence: Core patterns implemented, basic functionality
- C1 mastery: All patterns integrated, production-quality code
- C1+ excellence: Goes beyond requirements with custom innovations

---

## VII. Implementation Handoff

**For lesson-implementer subagent**:
1. All code examples must be executed against live OpenAI API with logs
2. Three Roles demonstrations (L2 lessons) must show all three roles explicitly without meta-commentary
3. Running TaskManager example maintained consistently across all lessons
4. Full type hints required in all code samples
5. Fact-checked against official openai-agents documentation
6. LiteLLM alternative shown in Lesson 1

**For validation-auditor subagent**:
1. Verify Layer progression (L1 → L2 → L4 without skipping)
2. Check Three Roles presence in all Layer 2 lessons
3. Verify zero meta-commentary violations (grep for "Layer", "Stage", "What to notice", "AI as")
4. Validate cognitive load ≤ B1 limits per lesson
5. Confirm all success evals mapped to lesson content
6. Validate capstone spec includes intent, constraints, success criteria

---

## VIII. Success Metrics

**Technical Quality**:
- ✅ All 8 lessons implement in specified timeframes
- ✅ Layer 1 → Layer 2 → Layer 4 progression without spec-first until Lesson 8
- ✅ Three Roles demonstrated in every Layer 2 lesson with real patterns
- ✅ All code examples tested against live API
- ✅ All success evals (SC-001 through SC-008) assessable through lessons

**Pedagogical Quality**:
- ✅ TaskManager running example consistent across all lessons
- ✅ 90%+ first-pass validation success rate
- ✅ Cognitive load respects CEFR B1 limits (≤10 concepts per lesson)
- ✅ Capstone produces deployment-ready Digital FTE

---

**Plan complete. Ready for /sp.implement with lesson writer and validators.**
