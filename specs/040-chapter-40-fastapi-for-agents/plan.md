# Chapter 40: FastAPI for Agents — Implementation Plan

**Generated by**: chapter-planner v2.0.0 (Reasoning-Activated)
**Source Spec**: /Users/mjs/Documents/code/panaversity-official/tutorsgpt/p7-c/specs/040-chapter-40-fastapi-for-agents/spec.md
**Version**: 2.0.0
**Status**: Draft (Supersedes v1.0.0)
**Created**: 2025-12-27
**Constitution**: v7.0.0 (Agent Factory Paradigm)
**Related Issues**: #541, #542, #543, #544, #545, #546

---

## I. Chapter Analysis

### Chapter Type

**Technical/Code-Focused** — Chapter teaches FastAPI implementation skills through progressive code examples, hands-on exercises, and a capstone project. All learning objectives use Apply/Create verbs, code examples are required throughout, and the outcome is a production-ready REST API exposing agents.

### Concept Density Analysis

**Core Concepts** (from spec): 13 concepts across 4 tiers

**Tier A: FastAPI Fundamentals (5 concepts)**
1. FastAPI application structure (app, routes, uvicorn)
2. pytest and TestClient for API testing
3. Pydantic request/response validation
4. CRUD operations (GET, POST, PUT, DELETE)
5. HTTPException and error handling

**Tier B: Production Essentials (4 concepts)**
6. Environment variables with pydantic-settings
7. SQLModel ORM and Neon PostgreSQL
8. JWT authentication flow
9. Password hashing (Argon2) + rate limiting

**Tier C: Architecture (2 concepts)**
10. Dependency injection with Depends()
11. Server-Sent Events for streaming

**Tier D: Agent Integration (2 concepts)**
12. APIs become tools pattern
13. Multi-agent orchestration via REST

**Complexity Assessment**: Standard (13 concepts across well-defined tiers)

**Proficiency Tier**: B1 (Intermediate) — Part 6 chapter, independent developers with Python fundamentals from Part 5

**Justified Lesson Count**: 13 lessons
- Tier A (Fundamentals): 5 lessons (one concept per lesson + testing early)
- Tier B (Production): 4 lessons (one concept per lesson per Issue requirements)
- Tier C (Architecture): 2 lessons
- Tier D (Agent + Capstone): 2 lessons

**Reasoning**: The spec explicitly requires 13 lessons with "one concept per lesson" principle (Issues #541-#546). This is justified by the 13 core concepts spanning from fundamentals through production patterns to agent integration. The lesson count increases from 8 to 13 to accommodate separated concerns (JWT separate from password hashing, env vars separate from SQLModel).

---

## II. Success Evals (from Spec)

**Predefined Success Criteria**:

1. Students can write pytest tests for FastAPI endpoints (L1 Manual)
2. Students can configure apps with pydantic-settings
3. Students can connect to Neon PostgreSQL via SQLModel
4. Students can implement JWT authentication with protected routes
5. Students can hash passwords with Argon2 and apply rate limiting
6. Students can use FastAPI's Depends() for clean architecture
7. Students can stream responses via SSE
8. Students can expose agents as REST endpoints with tools
9. Students complete capstone combining all patterns (Digital FTE outcome)

---

## III. Pedagogical Arc

```
Foundation (L1-L5)    Production Essentials (L6-L9)    Architecture (L10-L11)    Agent Integration (L12-L13)
     |                         |                              |                           |
     v                         v                              v                           v
FastAPI basics           Real database               Dependency injection       APIs become tools
+ testing (L1 Manual)    + auth + security          + streaming                + Digital FTE capstone
```

### Layer Progression

| Lesson | Title | Layer | Rationale |
|--------|-------|-------|-----------|
| L01 | Hello FastAPI | - | Foundation, no specific layer |
| L02 | Pytest Fundamentals | **L1 (Manual)** | Students write tests BY HAND first |
| L03 | POST and Pydantic | - | Foundation continues |
| L04 | Full CRUD | - | Foundation continues |
| L05 | Error Handling | - | Foundation completes |
| L06 | Environment Variables | - | Production essentials |
| L07 | SQLModel + Neon | - | Production essentials |
| L08 | JWT Authentication | - | Production essentials |
| L09 | Password + Rate Limiting | - | Production completes |
| L10 | Dependency Injection | **L2 (AI Collab)** | Refactoring with AI assistance |
| L11 | Streaming with SSE | - | Architecture pattern |
| L12 | Agent Integration | **L2 (AI Collab)** | AI collaboration for tool integration |
| L13 | Capstone | **L4 (Spec-Driven)** | Spec-first Digital FTE production |

---

## IV. Lesson Sequence

### Lesson 1: Hello FastAPI (KEEP AS-IS)

**Status**: Existing — No changes needed

**Current File**: `01-hello-fastapi.md`
**Target File**: `01-hello-fastapi.md` (unchanged)

**Learning Objective**: Create first FastAPI application with uvicorn and Swagger UI

**Stage**: Foundation

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. FastAPI application instance
2. Route decorators (@app.get)
3. uvicorn server
4. Swagger UI (/docs)

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Foundation for all subsequent lessons

**File Operation**: NONE (keep as-is)

**Estimated Time**: 45 min

---

### Lesson 2: Pytest Fundamentals (NEW - Issue #544)

**Status**: NEW — Create from scratch

**Current File**: N/A
**Target File**: `02-pytest-fundamentals.md`

**Learning Objective**: Write pytest tests for API endpoints using TestClient

**Stage**: **Layer 1 (Manual Foundation)**

**CEFR Proficiency**: B1

**New Concepts** (count: 5):
1. pytest test functions
2. TestClient from FastAPI
3. Assertions (assert response.status_code)
4. Running tests (pytest, pytest -v)
5. Red-Green cycle

**Cognitive Load Validation**: 5 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 1 (pytest tests for endpoints)

**Teaching Approach (L1 Manual)**:
- Students write tests BY HAND first (no AI)
- Book explains pytest basics with explicit examples
- Students execute `pytest` manually
- Build mental model of assertions and test structure
- **Why Manual First**: Students understand WHAT tests do before AI generates them in L12-13

**Content Elements**:
- pytest basics: test functions, assertions
- TestClient for FastAPI
- Running tests: `pytest`, `pytest -v`, `pytest test_main.py::test_name`
- Test the Hello FastAPI endpoint from Lesson 1
- Red-Green cycle demonstration

**What NOT to Cover** (save for later):
- Fixtures (Lesson 3+)
- Mocking (when we have dependencies)
- Async tests
- AI-generated tests (Lessons 12-13 as L2)

**Dependencies**: `pytest httpx`

**File Operation**: CREATE NEW

**Estimated Time**: 45 min

---

### Lesson 3: POST and Pydantic Models (RENAME 02->03)

**Status**: Existing — Renumber only

**Current File**: `02-post-and-pydantic-models.md`
**Target File**: `03-post-and-pydantic-models.md`

**Learning Objective**: Implement POST endpoints with Pydantic request validation

**Stage**: Foundation

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. POST method
2. Pydantic BaseModel for requests
3. Request body validation
4. Response models

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Foundation for CRUD

**Content Changes**:
- Update `sidebar_position: 3`
- Update lesson number references
- Add pytest examples for POST endpoint (building on L2)

**File Operation**: RENAME (02 -> 03) + update frontmatter

**Estimated Time**: 50 min

---

### Lesson 4: Full CRUD Operations (RENAME 03->04)

**Status**: Existing — Renumber only

**Current File**: `03-full-crud-operations.md`
**Target File**: `04-full-crud-operations.md`

**Learning Objective**: Implement complete CRUD endpoints (GET, PUT, DELETE)

**Stage**: Foundation

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. GET with path parameters
2. PUT for updates
3. DELETE operations
4. In-memory storage pattern

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Foundation for CRUD

**Content Changes**:
- Update `sidebar_position: 4`
- Update lesson number references
- Add pytest examples for each operation

**File Operation**: RENAME (03 -> 04) + update frontmatter

**Estimated Time**: 55 min

---

### Lesson 5: Error Handling (RENAME 04->05)

**Status**: Existing — Renumber only

**Current File**: `04-error-handling.md`
**Target File**: `05-error-handling.md`

**Learning Objective**: Handle errors with HTTPException and proper status codes

**Stage**: Foundation

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. HTTPException
2. Status codes (200, 201, 400, 404, 422)
3. Error response models
4. Validation error handling

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Foundation for CRUD

**Content Changes**:
- Update `sidebar_position: 5`
- Update lesson number references
- Add test examples for error cases

**File Operation**: RENAME (04 -> 05) + update frontmatter

**Estimated Time**: 45 min

---

### Lesson 6: Environment Variables (NEW - Issue #542)

**Status**: NEW — Create from scratch

**Current File**: N/A
**Target File**: `06-environment-variables.md`

**Learning Objective**: Configure applications using environment variables and pydantic-settings

**Stage**: Production Essentials

**CEFR Proficiency**: B1

**New Concepts** (count: 5):
1. Why environment variables (secrets, environments, 12-factor apps)
2. python-dotenv for local development
3. .env file structure
4. pydantic-settings BaseSettings
5. .gitignore for secrets

**Cognitive Load Validation**: 5 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 2 (pydantic-settings configuration)

**Content Elements**:
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Task API"
    debug: bool = False
    database_url: str  # Required - will error if missing
    secret_key: str    # For JWT in later lesson

    class Config:
        env_file = ".env"

settings = Settings()
```

**What to Cover**:
- Why environment variables (secrets, environments, 12-factor apps)
- Using `python-dotenv` for local development
- Creating `.env` file with sample values
- Using `pydantic-settings` for typed configuration
- Accessing config in FastAPI (Settings class pattern)
- `.env.example` for team collaboration
- **Never commit secrets** (`.gitignore` `.env`)

**Dependencies**: `python-dotenv pydantic-settings`

**File Operation**: CREATE NEW

**Estimated Time**: 40 min

---

### Lesson 7: SQLModel + Neon Setup (NEW - Issue #541)

**Status**: NEW — Create from scratch (Fast Track)

**Current File**: N/A
**Target File**: `07-sqlmodel-neon-setup.md`

**Learning Objective**: Connect to PostgreSQL via SQLModel and Neon

**Stage**: Production Essentials

**CEFR Proficiency**: B1

**New Concepts** (count: 5):
1. SQLModel basics (SQLModel, Field)
2. Neon account setup (free tier)
3. Connection string via env var
4. create_engine and Session
5. Converting in-memory CRUD to database

**Cognitive Load Validation**: 5 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 3 (Neon PostgreSQL via SQLModel)

**Teaching Approach (Fast Track)**:
- Simple setup, no complexity
- Use env vars from L06
- NO Alembic (save for Chapter 47)
- NO complex relations (one concept per lesson)

**Content Elements**:
```python
from sqlmodel import SQLModel, Field, create_engine, Session

class Task(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    title: str
    description: str | None = None
    completed: bool = False

# Create engine from environment variable
engine = create_engine(settings.database_url)

# Create tables
SQLModel.metadata.create_all(engine)
```

**What to Cover**:
- Install SQLModel + psycopg2
- Set up Neon account (free tier)
- Configure connection string via NEON_DATABASE_URL
- Define Task SQLModel model
- Convert existing CRUD endpoints to use SQLModel
- Run migrations with `SQLModel.metadata.create_all()`

**What NOT to Cover** (save for later):
- Repository pattern abstraction (Lesson 10: DI)
- Session dependency injection (Lesson 10: DI)
- Complex migration tools (Alembic - Chapter 47)
- Advanced relations

**Dependencies**: `sqlmodel psycopg2-binary`

**Future Integration Note**: Mention Neon MCP server for Claude as Digital FTE

**File Operation**: CREATE NEW

**Estimated Time**: 55 min

---

### Lesson 8: JWT Authentication (NEW - Issue #543)

**Status**: NEW — Create from scratch (Tokens Only)

**Current File**: N/A
**Target File**: `08-jwt-authentication.md`

**Learning Objective**: Implement JWT authentication with protected routes

**Stage**: Production Essentials

**CEFR Proficiency**: B1

**New Concepts** (count: 5):
1. Why JWT for APIs (stateless, token structure)
2. Token creation with expiration (pyjwt)
3. OAuth2PasswordBearer pattern
4. Token verification dependency
5. Protected endpoints with Depends(get_current_user)

**Cognitive Load Validation**: 5 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 4 (JWT authentication with protected routes)

**Teaching Approach (Tokens Only)**:
- Separate from password hashing (one concept per lesson)
- Use temporary plain-text password check
- **Explicitly note as insecure** - fixed in Lesson 9

**Content Elements**:
```python
import jwt
from datetime import datetime, timedelta
from fastapi.security import OAuth2PasswordBearer

SECRET_KEY = settings.secret_key
ALGORITHM = "HS256"

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def create_access_token(data: dict, expires_delta: timedelta = timedelta(minutes=30)):
    to_encode = data.copy()
    expire = datetime.utcnow() + expires_delta
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401)
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401)
    return username
```

**Temporary Login** (fixed in Lesson 9):
```python
# INSECURE - plain text check (Lesson 9 adds proper hashing)
@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = get_user(form_data.username)
    if not user or form_data.password != "temp_password":
        raise HTTPException(status_code=401)
    token = create_access_token(data={"sub": user.username})
    return {"access_token": token, "token_type": "bearer"}
```

**Dependencies**: `pyjwt`

**File Operation**: CREATE NEW

**Estimated Time**: 50 min

---

### Lesson 9: Password Hashing + Rate Limiting (NEW - Issue #546)

**Status**: NEW — Create from scratch

**Current File**: N/A
**Target File**: `09-password-hashing-rate-limiting.md`

**Learning Objective**: Hash passwords with Argon2 and protect endpoints with rate limiting

**Stage**: Production Essentials (Security Hardening)

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. Password hashing with pwdlib/Argon2
2. Verify password function
3. User signup with hashed password
4. In-memory rate limiting

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 5 (Argon2 hashing + rate limiting)

**Teaching Approach**:
- Fix the insecure L08 login
- Use pwdlib NOT bcrypt (per spec)
- In-memory rate limiter (NOT Redis - save for production chapter)

**Content Elements**:
```python
from pwdlib import PasswordHash

password_hash = PasswordHash.recommended()

def hash_password(password: str) -> str:
    return password_hash.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return password_hash.verify(plain, hashed)

@app.post("/users/signup", status_code=201)
async def signup(username: str, password: str, session: SessionDep):
    hashed = hash_password(password)
    user = User(username=username, hashed_password=hashed)
    session.add(user)
    await session.commit()
    return {"username": user.username}
```

**In-Memory Rate Limiting**:
```python
from collections import defaultdict
from time import time

request_counts: dict[str, list[float]] = defaultdict(list)
RATE_LIMIT = 5  # requests
RATE_WINDOW = 60  # seconds

def check_rate_limit(client_ip: str) -> bool:
    now = time()
    request_counts[client_ip] = [
        t for t in request_counts[client_ip]
        if now - t < RATE_WINDOW
    ]
    if len(request_counts[client_ip]) >= RATE_LIMIT:
        return False
    request_counts[client_ip].append(now)
    return True
```

**Why In-Memory (Not Redis)?**
| Approach | Pros | Cons | Use When |
|----------|------|------|----------|
| In-memory | Simple, no deps | Resets on restart, single | Learning, dev |
| Redis | Persistent | Extra service | Production |

**Dependencies**: `"pwdlib[argon2]"`

**File Operation**: CREATE NEW

**Estimated Time**: 50 min

---

### Lesson 10: Dependency Injection (REWRITE from 05)

**Status**: Existing — Rewrite with modernized patterns

**Current File**: `05-dependency-injection.md`
**Target File**: `10-dependency-injection.md`

**Learning Objective**: Organize code with FastAPI's Depends() pattern

**Stage**: **Layer 2 (AI Collaboration)**

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. Depends() mechanism
2. Dependency functions
3. Repository pattern
4. Lifecycle management

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 6 (Depends() for clean architecture)

**What to KEEP from existing**:
- Core DI explanation
- Repository pattern basics
- Depends() usage
- Common mistakes section

**What to REMOVE/UPDATE**:
- Remove references to "Lesson 7 agent injection" (now Lesson 12)
- Update to work with SQLModel Session (not just in-memory)
- Update to use Settings from L06
- Add Session dependency injection (building on L07)

**Layer 2 (AI Collaboration) Elements**:
- Students refactor existing code WITH AI assistance
- AI suggests repository pattern improvements
- Student evaluates and refines
- Three Roles: AI suggests patterns (Teacher), Student specifies constraints (Student), converge on solution (Co-Worker)

**File Operation**: RENAME (05 -> 10) + REWRITE content

**Estimated Time**: 50 min

---

### Lesson 11: Streaming with SSE (RENAME from 06)

**Status**: Existing — Renumber + minor updates

**Current File**: `06-streaming-with-sse.md`
**Target File**: `11-streaming-with-sse.md`

**Learning Objective**: Implement streaming responses using Server-Sent Events

**Stage**: Architecture

**CEFR Proficiency**: B1

**New Concepts** (count: 4):
1. SSE protocol format
2. EventSourceResponse
3. Async generators (yield)
4. Browser EventSource API

**Cognitive Load Validation**: 4 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 7 (SSE streaming)

**Content Changes**:
- Update `sidebar_position: 11`
- Update references to lesson numbers
- Keep core SSE content (already high quality)
- Update "next lesson" references

**File Operation**: RENAME (06 -> 11) + update frontmatter and references

**Estimated Time**: 45 min

---

### Lesson 12: Agent Integration (SIMPLIFY per Issue #545)

**Status**: Existing — MAJOR REWRITE (Simplification)

**Current File**: `07-agent-integration.md`
**Target File**: `12-agent-integration.md`

**Learning Objective**: Expose agents as REST endpoints where APIs become tools

**Stage**: **Layer 2 (AI Collaboration)**

**CEFR Proficiency**: B1

**New Concepts** (count: 3):
1. function_tool decorator
2. APIs as agent tools pattern
3. Streaming agent responses

**Cognitive Load Validation**: 3 concepts <= 10 (B1 limit) -> WITHIN LIMIT

**Maps to Evals**: Eval 8 (agents as REST endpoints)

**What to KEEP**:
- Core insight: "APIs are just functions, functions become tools"
- Basic streaming pattern
- Tool call -> response flow

**What to REMOVE (moved to Capstone L13)**:
- Complex handoff patterns (triage -> specialist routing)
- Multiple specialist agents (scheduler, collaboration)
- Elaborate orchestration
- 654 lines -> ~250 lines

**SIMPLIFIED Scope** (per Issue #545):
```python
from agents import function_tool

# These endpoints we built...
@app.post("/tasks")
async def create_task(task: TaskCreate): ...

@app.get("/tasks/{task_id}")
async def get_task(task_id: int): ...

# Functions become tools
@function_tool
def create_task_tool(title: str, description: str) -> dict:
    """Create a new task for the user."""
    response = client.post("/tasks", json={...})
    return response.json()

@function_tool
def get_task_tool(task_id: int) -> dict:
    """Get a task by ID."""
    response = client.get(f"/tasks/{task_id}")
    return response.json()

# Agent streams via SSE
@app.get("/agent/chat")
async def agent_chat(message: str):
    async def generate():
        async for event in Runner.run_streamed(agent, message):
            yield f"data: {event.model_dump_json()}\n\n"

    return StreamingResponse(generate(), media_type="text/event-stream")
```

**Layer 2 (AI Collaboration) Elements**:
- Students implement with AI assistance
- AI suggests tool patterns
- Student refines based on their Task API structure
- Three Roles demonstrated

**File Operation**: RENAME (07 -> 12) + MAJOR REWRITE (simplify)

**Estimated Time**: 50 min

---

### Lesson 13: Capstone — Agent-Powered Task Service (REWRITE from 08)

**Status**: Existing — REWRITE to incorporate new patterns

**Current File**: `08-capstone-agent-powered-task-service.md`
**Target File**: `13-capstone-agent-powered-task-service.md`

**Learning Objective**: Build complete multi-agent API using specification-first approach

**Stage**: **Layer 4 (Spec-Driven Integration) -> Digital FTE**

**CEFR Proficiency**: B1

**New Concepts** (count: 0 — synthesis lesson):
All concepts previously taught, now composed

**Cognitive Load Validation**: Synthesis, no new concepts -> WITHIN LIMIT

**Maps to Evals**: Eval 9 (capstone combining all patterns)

**What to KEEP**:
- Multi-agent architecture (triage + specialists)
- Streaming handoff visibility
- Testing checklist

**What to ADD (new patterns from L6-L9)**:
- Real Neon PostgreSQL (not in-memory)
- Environment variables configuration
- JWT authentication on agent endpoints
- Password hashing for user signup
- Rate limiting on expensive endpoints

**Layer 4 (Spec-Driven) Structure**:
1. **Specification FIRST**: Write spec.md before implementation
2. **Compose Skills**: Use accumulated patterns from L1-L12
3. **AI Orchestrates**: Agent implements spec using composed components
4. **Validate**: Test against spec success criteria

**Updated API Endpoints**:
```
# CRUD (Lessons 1-9) — Real Database
POST /tasks              - Create task (SQLModel + Neon)
GET  /tasks              - List tasks
GET  /tasks/{id}         - Get task
PUT  /tasks/{id}         - Update task
DELETE /tasks/{id}       - Delete task

# Auth (Lessons 8-9) — JWT + Argon2
POST /users/signup       - Create account (hashed password)
POST /token              - Get JWT token (rate limited)

# Agent (Lessons 12-13) — Protected + Streaming
POST /tasks/{id}/help    - Triage -> Specialist (streaming, JWT protected)
POST /tasks/{id}/schedule - Direct to scheduler agent
GET  /agents/status      - Which agents are available
```

**Digital FTE Outcome**:
The capstone produces a deployable agent service that could be packaged for monetization:
- REST API exposing TaskManager capabilities
- Authentication and rate limiting
- Real database persistence
- Multi-agent orchestration

**File Operation**: RENAME (08 -> 13) + REWRITE to incorporate L6-L9 patterns

**Estimated Time**: 90 min

---

## V. File Operations Summary

| # | Current File | Target File | Operation | Issue |
|---|--------------|-------------|-----------|-------|
| 01 | `01-hello-fastapi.md` | `01-hello-fastapi.md` | KEEP | - |
| 02 | N/A | `02-pytest-fundamentals.md` | **CREATE** | #544 |
| 03 | `02-post-and-pydantic-models.md` | `03-post-and-pydantic-models.md` | RENAME | - |
| 04 | `03-full-crud-operations.md` | `04-full-crud-operations.md` | RENAME | - |
| 05 | `04-error-handling.md` | `05-error-handling.md` | RENAME | - |
| 06 | N/A | `06-environment-variables.md` | **CREATE** | #542 |
| 07 | N/A | `07-sqlmodel-neon-setup.md` | **CREATE** | #541 |
| 08 | N/A | `08-jwt-authentication.md` | **CREATE** | #543 |
| 09 | N/A | `09-password-hashing-rate-limiting.md` | **CREATE** | #546 |
| 10 | `05-dependency-injection.md` | `10-dependency-injection.md` | RENAME + REWRITE | - |
| 11 | `06-streaming-with-sse.md` | `11-streaming-with-sse.md` | RENAME | - |
| 12 | `07-agent-integration.md` | `12-agent-integration.md` | RENAME + **SIMPLIFY** | #545 |
| 13 | `08-capstone-agent-powered-task-service.md` | `13-capstone-agent-powered-task-service.md` | RENAME + REWRITE | - |

### Summary by Operation Type

- **KEEP AS-IS**: 1 lesson (L01)
- **RENAME ONLY**: 4 lessons (L03, L04, L05, L11)
- **CREATE NEW**: 5 lessons (L02, L06, L07, L08, L09)
- **REWRITE**: 3 lessons (L10, L12, L13)

---

## VI. Skill Dependencies

### Intra-Chapter Dependencies

```
L01 Hello FastAPI
  |
  v
L02 Pytest Fundamentals <-- Tests L01 endpoint
  |
  v
L03 POST + Pydantic
  |
  v
L04 Full CRUD
  |
  v
L05 Error Handling
  |
  +---> L06 Environment Variables (parallel track)
  |       |
  |       v
  |     L07 SQLModel + Neon (requires L06 for env vars)
  |       |
  |       v
  |     L08 JWT Auth (requires L06 for secret_key)
  |       |
  |       v
  |     L09 Password + Rate Limit (requires L08 for auth fix)
  |
  v
L10 Dependency Injection (can reference L07 patterns)
  |
  v
L11 Streaming with SSE
  |
  v
L12 Agent Integration (requires L10, L11)
  |
  v
L13 Capstone (requires ALL lessons L01-L12)
```

### Cross-Chapter Dependencies

- **Chapter 34**: OpenAI Agents SDK (Agent, Runner, function_tool, handoffs)
- **Chapters 37-38**: MCP experience (HTTP/SSE patterns familiar)
- **Part 5**: Python Fundamentals (async/await, type hints, Pydantic)

**Validation**: All prerequisite chapters are implemented (Parts 1-5 complete per chapter-index.md)

---

## VII. Legacy Content Removal

### From Lesson 10 (Dependency Injection)

**REMOVE**:
- References to "Lesson 7 agent injection" (update to L12)
- In-memory-only examples (add SQLModel Session examples)

**UPDATE**:
- Work with SQLModel Session from L07
- Use Settings from L06

### From Lesson 12 (Agent Integration)

**REMOVE** (moved to Capstone):
- TaskManager Triage Agent (40 lines)
- TaskManager Scheduler Specialist (50 lines)
- TaskManager Collaboration Specialist (40 lines)
- Handoff endpoint with complex routing (100 lines)
- Streaming handoffs section (80 lines)
- Direct specialist endpoints section (50 lines)
- Challenge: Add a Third Specialist (30 lines)

**Total removed**: ~400 lines

**KEEP**:
- Core insight: APIs -> Functions -> Tools
- Single agent with 2-3 tools
- SSE streaming endpoint
- Basic tool call -> response flow

### From Lesson 13 (Capstone)

**REMOVE**:
- In-memory storage (replace with SQLModel)

**ADD**:
- Neon PostgreSQL persistence
- Environment variables configuration
- JWT authentication on agent endpoints
- Password hashing (Argon2)
- Rate limiting on /token endpoint
- Updated testing checklist for new patterns

---

## VIII. Cognitive Load per Lesson

| Lesson | New Concepts | Tier Limit | Status |
|--------|--------------|------------|--------|
| L01 | 4 | 10 (B1) | WITHIN |
| L02 | 5 | 10 (B1) | WITHIN |
| L03 | 4 | 10 (B1) | WITHIN |
| L04 | 4 | 10 (B1) | WITHIN |
| L05 | 4 | 10 (B1) | WITHIN |
| L06 | 5 | 10 (B1) | WITHIN |
| L07 | 5 | 10 (B1) | WITHIN |
| L08 | 5 | 10 (B1) | WITHIN |
| L09 | 4 | 10 (B1) | WITHIN |
| L10 | 4 | 10 (B1) | WITHIN |
| L11 | 4 | 10 (B1) | WITHIN |
| L12 | 3 | 10 (B1) | WITHIN |
| L13 | 0 (synthesis) | 10 (B1) | WITHIN |

**All lessons within B1 cognitive load limits.**

---

## IX. Teaching Modality by Lesson

| Lesson | Modality | Rationale |
|--------|----------|-----------|
| L01 | Hands-On Discovery | First app - immediate gratification |
| L02 | **L1 Manual First** | Write tests by hand before AI |
| L03 | Direct Teaching | Pydantic patterns |
| L04 | Hands-On Discovery | Build complete CRUD |
| L05 | Error Analysis | Debug error scenarios |
| L06 | Direct Teaching | Configuration patterns |
| L07 | Hands-On Discovery | Database setup |
| L08 | Direct Teaching | Auth patterns (security critical) |
| L09 | Direct Teaching | Security hardening |
| L10 | **L2 AI Collaboration** | Refactoring with AI |
| L11 | Hands-On Discovery | Streaming implementation |
| L12 | **L2 AI Collaboration** | Tool integration with AI |
| L13 | **L4 Spec-Driven** | Capstone synthesis |

**Anti-convergence check**: No two consecutive lessons use identical modality.

---

## X. Validation Checklist

### Chapter-Level Validation
- [x] Chapter type identified (Technical)
- [x] Concept density analysis documented (13 concepts)
- [x] Lesson count justified by spec + issues (13 lessons)
- [x] All 9 evals from spec covered by lessons
- [x] All lessons map to at least one eval

### Stage Progression Validation
- [x] L02: Layer 1 (Manual First - pytest by hand)
- [x] L10, L12: Layer 2 (AI Collaboration)
- [x] L13: Layer 4 (Spec-Driven Capstone -> Digital FTE)
- [x] No spec-first before Layer 4

### Cognitive Load Validation
- [x] All lessons <= 10 concepts (B1 limit)
- [x] New lessons follow one-concept-per-lesson principle

### Dependency Validation
- [x] Intra-chapter dependencies satisfied by lesson order
- [x] Cross-chapter dependencies validated (Parts 1-5 complete)

### Issue Traceability
- [x] #541: L07 SQLModel + Neon
- [x] #542: L06 Environment Variables
- [x] #543: L08 JWT Authentication
- [x] #544: L02 Pytest Fundamentals (L1 Manual)
- [x] #545: L12 Simplify Agent Integration
- [x] #546: L09 Password Hashing + Rate Limiting

---

## XI. Implementation Order

**Recommended execution sequence**:

### Phase 1: File Operations (Renaming)
1. Rename existing files to new positions (03->04->05, etc.)
2. Update sidebar_position in frontmatter
3. Update cross-references within files

### Phase 2: Create New Lessons (L02, L06-L09)
1. L02: Pytest Fundamentals (L1 Manual First)
2. L06: Environment Variables
3. L07: SQLModel + Neon Setup
4. L08: JWT Authentication
5. L09: Password Hashing + Rate Limiting

### Phase 3: Rewrite Existing Lessons
1. L10: Dependency Injection (update for SQLModel)
2. L12: Agent Integration (SIMPLIFY per #545)
3. L13: Capstone (incorporate L06-L09 patterns)

### Phase 4: Update README and Summary Files
1. Update chapter README.md with new lesson structure
2. Generate/update .summary.md files for new lessons
3. Validate build

---

**Plan Version**: 2.0.0
**Status**: Ready for Implementation
**Next Step**: Execute `/sp.tasks` to generate tasks.md from this plan
