# PKCE OAuth Flow Documentation

This document explains the PKCE (Proof Key for Code Exchange) OAuth flow implementation for public clients.

## Why PKCE?

PKCE is required for **public clients** (SPAs, mobile apps, CLI tools) that cannot securely store a client secret. Instead of a secret, PKCE uses:

1. **Code Verifier**: A random string generated by the client
2. **Code Challenge**: SHA256 hash of the verifier
3. **Verification**: Auth server verifies the verifier matches the challenge

## Flow Diagram

```
┌──────────────┐                          ┌───────────────┐
│   Frontend   │                          │  Auth Server  │
│  (Public)    │                          │               │
└──────┬───────┘                          └───────┬───────┘
       │                                          │
       │ 1. Generate code_verifier                │
       │    code_challenge = SHA256(verifier)     │
       │                                          │
       │ 2. Redirect to /authorize                │
       │    + code_challenge                      │
       │────────────────────────────────────────▶│
       │                                          │
       │                          3. User logs in │
       │                             (if needed)  │
       │                                          │
       │ 4. Redirect back with code               │
       │◀────────────────────────────────────────│
       │                                          │
       │ 5. Exchange code + code_verifier         │
       │────────────────────────────────────────▶│
       │                                          │
       │                    6. Verify challenge   │
       │                       matches verifier   │
       │                                          │
       │ 7. Return tokens                         │
       │◀────────────────────────────────────────│
       │                                          │
```

## Implementation

### Step 1: Generate PKCE Values

```typescript
// crypto-utils.ts
function generateCodeVerifier(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64URLEncode(array);
}

async function generateCodeChallenge(verifier: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64URLEncode(new Uint8Array(hash));
}

function base64URLEncode(buffer: Uint8Array): string {
  return btoa(String.fromCharCode(...buffer))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}
```

### Step 2: Start Authorization

```typescript
async function startOAuthFlow() {
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = await generateCodeChallenge(codeVerifier);

  // Store verifier for later (sessionStorage is safer than localStorage)
  sessionStorage.setItem('pkce_verifier', codeVerifier);

  const params = new URLSearchParams({
    client_id: 'robolearn-public-client',
    redirect_uri: 'http://localhost:3000/auth/callback',
    response_type: 'code',
    scope: 'openid profile email',
    state: crypto.randomUUID(), // CSRF protection
    code_challenge: codeChallenge,
    code_challenge_method: 'S256',
  });

  window.location.href = `http://localhost:3001/api/auth/oauth2/authorize?${params}`;
}
```

### Step 3: Handle Callback

```typescript
// /auth/callback page
async function handleCallback() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const state = params.get('state');
  const error = params.get('error');

  if (error) {
    console.error('OAuth error:', error, params.get('error_description'));
    return;
  }

  if (!code) {
    console.error('No authorization code received');
    return;
  }

  // Retrieve the verifier we stored earlier
  const codeVerifier = sessionStorage.getItem('pkce_verifier');
  if (!codeVerifier) {
    console.error('No PKCE verifier found');
    return;
  }

  // Exchange code for tokens
  const tokens = await exchangeCodeForTokens(code, codeVerifier);

  // Clean up
  sessionStorage.removeItem('pkce_verifier');

  // Store tokens or redirect
  console.log('Login successful!', tokens);
}
```

### Step 4: Exchange Code for Tokens

```typescript
async function exchangeCodeForTokens(code: string, codeVerifier: string) {
  const response = await fetch('http://localhost:3001/api/auth/oauth2/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: 'http://localhost:3000/auth/callback',
      client_id: 'robolearn-public-client',
      code_verifier: codeVerifier, // PKCE: verifier instead of secret
    }),
  });

  if (!response.ok) {
    throw new Error(`Token exchange failed: ${await response.text()}`);
  }

  return response.json();
}
```

## Token Response

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 21600,
  "id_token": "eyJhbGciOiJSUzI1NiIs...",
  "scope": "openid profile email"
}
```

## Public Client Configuration

### Registering a Public Client

```bash
curl -X POST http://localhost:3001/api/auth/oauth2/register \
  -H "Content-Type: application/json" \
  -d '{
    "client_name": "My Public App",
    "redirect_uris": ["http://localhost:3000/callback"],
    "token_endpoint_auth_method": "none",
    "grant_types": ["authorization_code", "refresh_token"],
    "response_types": ["code"]
  }'
```

Response:
```json
{
  "client_id": "generated-client-id",
  "client_name": "My Public App",
  "redirect_uris": ["http://localhost:3000/callback"],
  "token_endpoint_auth_method": "none"
}
```

### Pre-Registered Public Client

The `robolearn-public-client` is pre-registered in the auth server configuration. Use it for development:

```typescript
const CLIENT_ID = 'robolearn-public-client';
const REDIRECT_URI = 'http://localhost:3000/auth/callback';
```

## Security Considerations

### 1. Code Verifier Storage

- Use `sessionStorage` not `localStorage`
- Clear after token exchange
- Never send to server before callback

### 2. State Parameter

Always include a `state` parameter to prevent CSRF:

```typescript
const state = crypto.randomUUID();
sessionStorage.setItem('oauth_state', state);

// In callback:
if (params.get('state') !== sessionStorage.getItem('oauth_state')) {
  throw new Error('Invalid state - possible CSRF attack');
}
```

### 3. Redirect URI Validation

Only register exact redirect URIs:
- `http://localhost:3000/callback`
- `https://myapp.com/callback`

Never use wildcards for public clients.

### 4. Token Storage

- Access tokens: Memory only (short-lived)
- Refresh tokens: HttpOnly cookies (if supported)
- ID tokens: Memory only (for claims)

## Common Errors

### "invalid_grant"

- Code expired (10 minute lifetime)
- Code already used (one-time use)
- Wrong redirect_uri
- PKCE verifier doesn't match challenge

### "invalid_client"

- Client not registered
- Client disabled
- Wrong token_endpoint_auth_method

### "invalid_request"

- Missing required parameters
- Invalid code_challenge_method (must be S256)
- Malformed code_challenge

## Testing

Run the test script:

```bash
cd auth-server
node tests/test-pkce-oauth.js
```

Expected output:
```
=== Testing PKCE OAuth Flow ===

1. Generated PKCE values
2. Signing in to get session...
3. Requesting authorization code with PKCE...
4. Exchanging code for tokens (using PKCE, no secret)...
5. Fetching userinfo...

=== PKCE OAuth Flow: SUCCESS ===
```

## Libraries

### React/Next.js

Use `@auth/core` or implement manually as shown above.

### Python (Backend for Backend)

If your Python backend needs to initiate PKCE flow:

```python
import secrets
import hashlib
import base64

def generate_pkce():
    verifier = secrets.token_urlsafe(32)
    challenge = base64.urlsafe_b64encode(
        hashlib.sha256(verifier.encode()).digest()
    ).rstrip(b'=').decode()
    return verifier, challenge
```

### CLI Tools

For CLI tools, use a local server callback:

```typescript
// Start local server for callback
const server = http.createServer(async (req, res) => {
  const url = new URL(req.url!, 'http://localhost:8888');
  const code = url.searchParams.get('code');

  if (code) {
    const tokens = await exchangeCodeForTokens(code, codeVerifier);
    // Store tokens locally
    res.end('Login successful! You can close this window.');
    server.close();
  }
});

server.listen(8888);
// Use redirect_uri = http://localhost:8888/callback
```
