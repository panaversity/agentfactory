---
sidebar_position: 2
title: "Part 2: AI Tool Landscape"
---

# Part 2: AI Tool Landscape

Picture this: You've just finished Part 1. You understand the transformation. You know why AI-driven development matters. You're ready to start building.

But there's a problem.

You open your terminal (or maybe you've never opened one before), and you're staring at a blank screen. You've heard about Claude Code, Gemini CLI, and GitHub. You know they're powerful. You have no idea where to start, what these tools actually do, or which one is right for you.

**Now It's Time to Get Your Hands Dirty**

This part solves that problem. By the end of these four chapters, you won't just know about AI development tools—you'll have them installed, configured, and ready to use. You'll understand the command line well enough to navigate confidently. You'll have Git and GitHub set up for professional development. And you'll know exactly which tool to reach for in any situation.

More importantly, you'll experience the paradigm shift from Part 1 becoming reality. The tools described theoretically in earlier chapters are now in your hands, ready to collaborate with you on real work.

## What You'll Learn in Part 2

This part consists of four interconnected chapters that build practical proficiency with AI development tools and professional workflows.

### Chapter 5: How It All Started—The Claude Code Phenomenon

You'll install and configure Claude Code, understanding why this "simple" command-line interface triggered such rapid adoption. We explore the origin story (how an internal Anthropic tool became a public phenomenon), walk through a straightforward npm installation, and learn Claude Code's key features through hands-on experience: subagents for specialized tasks, agent skills for autonomous discovery, and MCP servers for external data access.

This chapter establishes Claude Code as a **collaborative thinking partner**—not an automation supercomputer. By the end, Claude Code will be running on your machine with your first subagent and skill working, and you'll have experienced the paradigm shift from passive AI assistance to active AI collaboration.

### Chapter 6: Google Gemini CLI—Open Source and Everywhere

Not everyone wants to use Claude Code. Not everyone should. This chapter introduces Gemini CLI, Google's open-source alternative that anyone can download, modify, and extend. You'll explore Gemini 2.5 Pro's massive 1 million token context window, install and configure Gemini CLI, and develop a framework for comparing tools.

The goal isn't "which tool is better"—it's "which tool is right for my specific situation?" By the end of this chapter, you'll be able to evaluate AI development tools critically and choose the right tool for different tasks.

### Chapter 7: Bash Essentials for AI-Driven Development

The command line is the native language of serious development. This chapter is split into two parts: **Part I** teaches essential Bash commands (navigation, file operations, environment variables, scripting basics). **Part II** shifts perspective: instead of memorizing commands, you learn to request AI tools execute Bash commands via natural language prompts.

The practical focus: master the 90% of Bash workflows that matter for AI-driven development. Skip the esoteric corner cases. Focus on what you actually use.

### Chapter 8: Git & GitHub for AI-Driven Development

Git and GitHub aren't optional when working with AI agents—they're essential safety mechanisms. This chapter is also split into two parts: **Part I** covers essential Git commands (init, add, commit, push, branches, pull requests). **Part II** shows natural language workflows for requesting AI tools handle Git operations.

Critical insight: Git provides the safety net that makes AI-assisted development viable. Every change is tracked. Every experiment can be rolled back. Every collaboration is auditable. You'll learn why this matters before learning the mechanics of how to do it.

## A Note on Mindset

The most important thing you'll develop in this part isn't tool proficiency—it's the ability to see AI tools as collaborators, not magic.

Many people approach new tools with one of two extremes:

**The first extreme:** "This is magic. I don't need to understand it. I'll just use it." This leads to magical thinking. When something goes wrong, you're helpless. When a tool acts unexpectedly, you have no mental model to understand why. You become dependent on the tool rather than in control of it.

**The second extreme:** "I need to understand everything about how this works before I use it." This leads to paralysis. You spend months studying command-line architecture before writing your first program. You read Git documentation obsessively before making your first commit.

**There's a middle path:** Understand tools well enough to use them effectively, ask questions when confused, make mistakes safely (using Git as your safety net), and learn through experimentation.

This part teaches you that middle path. Claude Code and Gemini CLI are powerful because they're designed to be understood progressively. You don't need to be an expert before using them. You need curiosity, willingness to experiment, and the ability to ask good questions when confused.

Bash and Git work the same way. You'll learn the 20% of commands that handle 80% of your work. You'll use AI tools to help with the other 20% when needed. This is professional workflow in 2025—not memorization of obscure commands, but knowing how to ask for help effectively.

Take your time. Don't rush. Use your AI assistant (Claude Code or Gemini CLI) when you're confused. Make mistakes and use Git to recover. By the end of these four chapters, you'll have the foundation every professional developer relies on.