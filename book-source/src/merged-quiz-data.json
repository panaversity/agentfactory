{
    "quiz_data":  {
                      "chapters":  [
                                       {
                                           "chapter_id":  1,
                                           "chapter_title":  "Preface: Welcome to the AI-Native Era",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the core paradigm shift in AI-native development compared to traditional development?",
                                                                 "options":  {
                                                                                 "a":  "Developers write code faster with better auto-completion.",
                                                                                 "b":  "Developers architect with specifications, and AI agents implement them.",
                                                                                 "c":  "AI agents design the software, and humans write the code.",
                                                                                 "d":  "The development lifecycle is replaced entirely by autonomous agents."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \u0027Traditional development: You write code... AI-native development: You architect (by writing specifications in collaboration with your Personal/Coding AI Agent) → AI agents implement them → you validate the results.\u0027"
                                                             },
                                                             {
                                                                 "question":  "According to the book\u0027s philosophy, what is \u0027co-learning\u0027?",
                                                                 "options":  {
                                                                                 "a":  "A process where multiple AI agents teach each other.",
                                                                                 "b":  "A feedback loop where humans and AI agents learn from each other to reach a solution.",
                                                                                 "c":  "A traditional educational model where a teacher instructs both a human student and an AI.",
                                                                                 "d":  "The act of an AI learning from a large dataset of human-written code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The preface defines co-learning as a feedback loop: \u00271. You explain... 2. AI suggests... 3. You evaluate... 4. AI learns... 5. Together you converge on a working solution. This feedback loop — co-learning — is the heart of AI-native development.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The book describes a three-level \u0027AI Development Spectrum.\u0027 What is the primary focus of the book?",
                                                                 "options":  {
                                                                                 "a":  "Level 1: AI-Assisted Development, using AI for productivity enhancement.",
                                                                                 "b":  "Level 2: AI-Driven Development (AIDD), where AI is an implementation partner.",
                                                                                 "c":  "Level 3: AI-Native Software Development, where AI is the core of the product.",
                                                                                 "d":  "A mix of all three levels equally."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explicitly states, \u0027Primary focus: Level 2 (AIDD)—repeatable workflows to turn specs into working software with AI.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What are the \u0027dual languages\u0027 the book focuses on, and what are their primary roles?",
                                                                 "options":  {
                                                                                 "a":  "Python for user interaction and TypeScript for AI reasoning.",
                                                                                 "b":  "Java for enterprise logic and JavaScript for web interfaces.",
                                                                                 "c":  "Python for AI reasoning and TypeScript for user interaction.",
                                                                                 "d":  "C++ for performance and Python for scripting."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The book explains, \u0027Python: The Reasoning World... TypeScript: The Interaction World. The insight: Agents think in Python. Users interact through TypeScript.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the key difference between \u0027Prompting\u0027 and \u0027Spec Engineering\u0027?",
                                                                 "options":  {
                                                                                 "a":  "Prompting is for junior developers, while Spec Engineering is for seniors.",
                                                                                 "b":  "Prompting is a casual request, while Spec Engineering creates a structured, testable contract.",
                                                                                 "c":  "Prompting uses natural language, while Spec Engineering requires a formal programming language.",
                                                                                 "d":  "There is no difference; the terms are used interchangeably."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The preface clarifies, \u0027Prompting: A casual request to an AI... Spec Engineering: A structured, testable intent... The difference: One is a request. One is a contract.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  2,
                                           "chapter_title":  "A Moment That Changed Everything",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What did Sarah Chen, a solo founder, build in forty-eight hours with the help of Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "A simple personal blog.",
                                                                                 "b":  "A complete customer analytics dashboard for 1,200 customers.",
                                                                                 "c":  "A mobile game.",
                                                                                 "d":  "A tutorial on PHP."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explicitly states, \u0027In forty-eight hours, she\u0027d built a complete customer analytics dashboard that two months ago would have required a team of five developers and three weeks of work... Her dashboard processed real-time data for 1,200 customers.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does the speed of the current AI coding revolution compare to previous transitions in software development?",
                                                                 "options":  {
                                                                                 "a":  "It is happening over 10-15 years, similar to past transitions.",
                                                                                 "b":  "It is happening much slower than previous transitions.",
                                                                                 "c":  "It is happening in months, not years.",
                                                                                 "d":  "The speed is exactly the same."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter notes, \u0027Previous transitions... took 10-15 years... The AI coding revolution is happening in months, not years.\u0027"
                                                             },
                                                             {
                                                                 "question":  "According to the Stack Overflow 2024 Developer Survey cited in the chapter, what percentage of professional developers are already using AI coding tools?",
                                                                 "options":  {
                                                                                 "a":  "10%",
                                                                                 "b":  "44%",
                                                                                 "c":  "62%",
                                                                                 "d":  "76%"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text provides the statistic: \u002776% of professional developers are using or plan to use AI coding tools, with 62% already using them—up from 44% last year (Stack Overflow 2024 Developer Survey).\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s main answer to questions like \u0027Am I too late?\u0027 or \u0027Will this replace me?\u0027 for developers?",
                                                                 "options":  {
                                                                                 "a":  "It is too late for new developers to enter the field.",
                                                                                 "b":  "AI will replace most developers within the next year.",
                                                                                 "c":  "This is the best time in decades to be learning software development because of AI.",
                                                                                 "d":  "Developers should switch to a different career."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text directly answers, \u0027The answer to all four is the same, and it might surprise you: This is the best time in decades to be learning software development. Not despite AI. Because of it.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How is the role of a developer evolving in the AI era, according to the chapter?",
                                                                 "options":  {
                                                                                 "a":  "From a high-level architect to a low-level coder.",
                                                                                 "b":  "It is not evolving; the tasks remain the same.",
                                                                                 "c":  "From a typist writing code line by line to an orchestrator managing AI agents.",
                                                                                 "d":  "Developers are now primarily focused on hardware and infrastructure."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter states, \u0027Your role as a developer is evolving from typist (writing code line by line) to orchestrator (managing AI agents, making architectural decisions, exercising judgment).\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  3,
                                           "chapter_title":  "The $3 Trillion Developer Economy",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What two figures are multiplied to calculate the ~$3 trillion aggregate economic output of the developer economy?",
                                                                 "options":  {
                                                                                 "a":  "100 million GitHub users and their average subscription fee.",
                                                                                 "b":  "~30 million professional developers and $100,000 in annual generated value per developer.",
                                                                                 "c":  "The number of software companies and their average annual revenue.",
                                                                                 "d":  "The number of lines of code written per year and the value of each line."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly states the calculation: \u0027~30 million professional developers worldwide × $100,000 in annual generated value per developer = ~$3 trillion in aggregate economic output.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter compares the $3 trillion developer economy to the GDP of which country?",
                                                                 "options":  {
                                                                                 "a":  "The United States",
                                                                                 "b":  "China",
                                                                                 "c":  "Canada",
                                                                                 "d":  "France"
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The text makes a direct comparison: \u0027$3 trillion is approximately the GDP of France—the world\u0027s 7th or 8th largest economy...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027Acceleration Paradox\u0027 described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "AI coding tools are slowing down software production because of the need for more reviews.",
                                                                                 "b":  "AI coding tools are accelerating software production, but the quality of software is decreasing.",
                                                                                 "c":  "AI coding tools are accelerating software production, which is increasing the demand for software and developers, not reducing it.",
                                                                                 "d":  "Only senior developers are getting faster, while junior developers are getting slower."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains the paradox: \u0027Traditional economic logic suggested that automation reduces demand for labor... What\u0027s actually happening is more subtle and more profound... This doesn\u0027t shrink the software market. It explodes it.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter draws a historical parallel between the current software disruption and the transformation of which other industry?",
                                                                 "options":  {
                                                                                 "a":  "The automotive industry with the invention of the assembly line.",
                                                                                 "b":  "The music industry with the shift to digital streaming.",
                                                                                 "c":  "The printing industry with the introduction of desktop publishing software.",
                                                                                 "d":  "The textile industry during the industrial revolution."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text makes a specific comparison: \u0027Software disrupting itself has few direct historical parallels, but one comparison stands out: The printing industry in the late 20th century.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the primary effect of AI coding tools on the software market, as described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "It is shrinking the market by automating the creation of common software.",
                                                                                 "b":  "It is shifting the market from a Software-as-a-Service (SaaS) model to one of highly customized, individual software solutions.",
                                                                                 "c":  "It is causing a decline in software quality and security.",
                                                                                 "d":  "It is making software more expensive to create."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \u0027AI coding tools are enabling a shift toward highly customized, individual software solutions... This doesn\u0027t shrink the software market. It explodes it.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  4,
                                           "chapter_title":  "Software Disrupting Itself",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the key difference between \u0027external disruption\u0027 and the \u0027internal disruption\u0027 currently happening in software development?",
                                                                 "options":  {
                                                                                 "a":  "External disruption is slow, while internal disruption is even slower.",
                                                                                 "b":  "External disruption is when a software company disrupts another industry, while internal disruption is when AI tools transform the software industry itself.",
                                                                                 "c":  "External disruption affects senior developers, while internal disruption affects junior developers.",
                                                                                 "d":  "External disruption is voluntary, while internal disruption is forced upon developers."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines the pattern: \u0027External force: Software companies built platforms that competed with traditional retailers... Internal force: The same industry creating the tools is being transformed by them.\u0027"
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, why is the adoption of AI coding tools happening so much faster than previous technology shifts?",
                                                                 "options":  {
                                                                                 "a":  "Because developers are being forced to use them by their managers.",
                                                                                 "b":  "Because there is no external resistance, and developers are adopting them voluntarily for immediate value.",
                                                                                 "c":  "Because the tools are expensive, creating a sense of urgency.",
                                                                                 "d":  "Because previous technology shifts were not very useful."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text highlights several reasons for the speed, a key one being: \u0027No External Resistance. When AI tools disrupt software development, there\u0027s no external resistance. Developers are adopting these tools voluntarily and enthusiastically...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the chapter mean by the \u0027Recursion Effect\u0027?",
                                                                 "options":  {
                                                                                 "a":  "AI coding tools are getting stuck in infinite loops.",
                                                                                 "b":  "Developers are recursively calling the same functions, leading to bugs.",
                                                                                 "c":  "AI coding tools are being used to improve and develop the next version of themselves, creating a rapid improvement cycle.",
                                                                                 "d":  "The process of learning to code is becoming recursive and more difficult."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains this \u0027mind-bending\u0027 concept: \u0027AI coding tools are being used to improve AI coding tools... This creates a recursive improvement cycle that has no parallel in previous disruptions.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does the impact of AI coding tools on developer roles differ from previous technology shifts like cloud computing or mobile development?",
                                                                 "options":  {
                                                                                 "a":  "AI coding tools only affect junior developers.",
                                                                                 "b":  "AI coding tools have a universal impact, affecting every role in the software development value chain simultaneously.",
                                                                                 "c":  "AI coding tools have less impact than previous shifts.",
                                                                                 "d":  "Previous shifts affected all roles, while AI tools only affect a few."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \u0027AI coding tools affect everyone simultaneously,\u0027 and then lists the impact on junior, mid-level, senior, DevOps, QA, and technical writers, concluding, \u0027There\u0027s nowhere in the software development value chain that remains untouched.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s conclusion about the inevitability of AI coding tools?",
                                                                 "options":  {
                                                                                 "a":  "The \u0027if\u0027 question is still debated, and their adoption is uncertain.",
                                                                                 "b":  "The \u0027if\u0027 question is already answered; the only remaining question is \u0027how fast?\u0027",
                                                                                 "c":  "The tools are likely a temporary hype or trend.",
                                                                                 "d":  "The adoption will be slow and may take over a decade."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter asserts, \u0027With AI coding, the \u0027if\u0027 question is already answered. The tools exist, they work, they\u0027re being adopted at scale, and they\u0027re improving rapidly. The only remaining question is \u0027how fast?\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  5,
                                           "chapter_title":  "The Development Lifecycle in Transition",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the six phases of the traditional software development lifecycle mentioned in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Discovery, Design, Development, Debugging, Deployment, Decommissioning",
                                                                                 "b":  "Planning, Design, Implementation, Testing, Deployment, Operations",
                                                                                 "c":  "Requirements, Architecture, Coding, Review, Release, Retirement",
                                                                                 "d":  "Idea, Prototype, Build, Test, Launch, Iterate"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly lists the phases: \u0027The traditional software development lifecycle looks something like this: Planning → Design → Implementation → Testing → Deployment → Operations.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does the AI-augmented approach to the \u0027Planning \u0026 Requirements\u0027 phase differ from the traditional approach?",
                                                                 "options":  {
                                                                                 "a":  "AI completely replaces product managers.",
                                                                                 "b":  "AI helps extract requirements, suggest edge cases, and identify inconsistencies before development starts.",
                                                                                 "c":  "The planning phase is skipped entirely.",
                                                                                 "d":  "AI only helps with formatting the requirements document."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states the AI-augmented approach includes: \u0027Natural language processing helps extract requirements... AI agents suggest edge cases... Automated analysis identifies inconsistencies and ambiguities...\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the \u0027Testing \u0026 Quality Assurance\u0027 phase, what is a key benefit of using an AI-augmented approach?",
                                                                 "options":  {
                                                                                 "a":  "It eliminates the need for human QA engineers.",
                                                                                 "b":  "It only works for unit tests, not integration tests.",
                                                                                 "c":  "AI can generate comprehensive test suites and identify edge cases that humans might miss.",
                                                                                 "d":  "It makes testing slower but more thorough."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter highlights that with AI, it \u0027generates comprehensive test suites from requirements and code\u0027 and \u0027Automatically identifies edge cases developers didn\u0027t think to test.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027compounding effect\u0027 of AI transformation across the development lifecycle?",
                                                                 "options":  {
                                                                                 "a":  "Each phase becomes more complex and expensive.",
                                                                                 "b":  "Improvements in one phase are isolated and do not affect other phases.",
                                                                                 "c":  "An improvement in an early phase (like planning) leads to benefits and efficiencies in all subsequent phases.",
                                                                                 "d":  "The total time for development increases due to the need for more reviews."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text explains, \u0027Each phase improvement compounds with others. When AI helps you identify edge cases during planning, you write better requirements. Better requirements lead to better architecture,\u0027 and so on."
                                                             },
                                                             {
                                                                 "question":  "What is happening to specialized roles like \u0027developer,\u0027 \u0027QA engineer,\u0027 and \u0027DevOps engineer\u0027 as a result of AI tools?",
                                                                 "options":  {
                                                                                 "a":  "These roles are becoming more distinct and siloed.",
                                                                                 "b":  "The boundaries between these roles are blurring as AI enables individuals to handle more responsibilities.",
                                                                                 "c":  "These roles are being completely eliminated.",
                                                                                 "d":  "Only the developer role is changing."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter notes, \u0027The boundaries between \u0027developer,\u0027 \u0027QA engineer,\u0027 and \u0027DevOps engineer\u0027 are blurring. AI tools enable individual contributors to handle responsibilities that previously required dedicated specialists.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  6,
                                           "chapter_title":  "Beyond Code: The Changing Role of Developers",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "The chapter describes the developer\u0027s role as shifting from a \u0027typist\u0027 to what?",
                                                                 "options":  {
                                                                                 "a":  "A manager",
                                                                                 "b":  "A data scientist",
                                                                                 "c":  "An orchestrator",
                                                                                 "d":  "A marketer"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s main theme is this transition: \u0027Your role shifted from typing code to directing an AI agent. You\u0027re orchestrating, not transcribing.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is NOT one of the four core dimensions of the modern \u0027developer-as-orchestrator\u0027 role?",
                                                                 "options":  {
                                                                                 "a":  "Specification \u0026 Intent Communication",
                                                                                 "b":  "Memorizing complex syntax and APIs",
                                                                                 "c":  "Architecture \u0026 System Design",
                                                                                 "d":  "Code Review \u0026 Quality Judgment"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists four dimensions, and explicitly contrasts the new skills with the old skill of memorizing syntax. The four dimensions are: Specification \u0026 Intent Communication, Architecture \u0026 System Design, Code Review \u0026 Quality Judgment, and Agent Supervision \u0026 Iteration."
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, why do experienced developers often see greater productivity gains with AI tools than beginners?",
                                                                 "options":  {
                                                                                 "a":  "Because they type faster.",
                                                                                 "b":  "Because their experience allows them to provide more precise specifications and better evaluate the AI\u0027s output.",
                                                                                 "c":  "Because AI tools are only designed for senior developers.",
                                                                                 "d":  "Because they ignore the AI\u0027s suggestions and write the code themselves."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains that experienced developers benefit more because \u0027You know: What to ask for... What to look for... What matters...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027paradox\u0027 mentioned in the chapter regarding the value of developers?",
                                                                 "options":  {
                                                                                 "a":  "As AI tools get better, developers become less valuable.",
                                                                                 "b":  "As AI tools become more powerful, skilled developers become MORE valuable, not less.",
                                                                                 "c":  "AI tools only increase the value of junior developers.",
                                                                                 "d":  "The value of a developer is now measured by how many AI tools they use."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \u0027Here\u0027s what surprises people: As AI tools become more powerful, skilled developers become MORE valuable, not less.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What analogy does the chapter use to describe the impact of AI coding tools on developers?",
                                                                 "options":  {
                                                                                 "a":  "A calculator for a mathematician.",
                                                                                 "b":  "A word processor for a writer.",
                                                                                 "c":  "A GPS for a taxi driver.",
                                                                                 "d":  "An assembly line for a factory worker."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text makes a direct comparison: \u0027Word processors didn\u0027t make writers obsolete—they freed writers to focus on storytelling... AI coding tools are doing the same for developers.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  7,
                                           "chapter_title":  "The Autonomous Agent Era",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "The chapter describes an evolution of AI coding tools through four generations. What is the correct order of these generations?",
                                                                 "options":  {
                                                                                 "a":  "Function Generation → Autocomplete → Feature Implementation → Autonomous Agents",
                                                                                 "b":  "Autocomplete → Function Generation → Feature Implementation → Autonomous Agents",
                                                                                 "c":  "Autonomous Agents → Feature Implementation → Function Generation → Autocomplete",
                                                                                 "d":  "Feature Implementation → Autonomous Agents → Autocomplete → Function Generation"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly lists the progression: \u0027code completion → function generation → feature implementation → autonomous agents.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What distinguishes a \u0027Generation 4: Autonomous Agent\u0027 from previous generations of AI tools?",
                                                                 "options":  {
                                                                                 "a":  "It can only suggest the next line of code.",
                                                                                 "b":  "It can take high-level goals, break them into tasks, and execute them with minimal human intervention.",
                                                                                 "c":  "It can only generate a single function or class in isolation.",
                                                                                 "d":  "It requires the human to manually run tests and fix all bugs."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text defines a Generation 4 agent\u0027s capability as being able to \u0027Take high-level goals, break them into tasks, implement solutions, test, debug, and iterate—all with minimal human intervention.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a task the chapter states an autonomous agent CANNOT do yet?",
                                                                 "options":  {
                                                                                 "a":  "Write code and run tests.",
                                                                                 "b":  "Break a high-level goal into subtasks.",
                                                                                 "c":  "Make strategic trade-off decisions, like performance vs. simplicity.",
                                                                                 "d":  "Fix failing tests based on error messages."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists things an agent cannot do yet, including: \u0027Make strategic trade-off decisions (performance vs. simplicity, cost vs. scalability).\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the primary benefit of using a multi-agent system (a team of specialized agents)?",
                                                                 "options":  {
                                                                                 "a":  "It is cheaper than using a single agent.",
                                                                                 "b":  "It allows for specialization, where a testing agent can be more thorough, and a review agent can focus on security.",
                                                                                 "c":  "It is simpler to manage than a single agent.",
                                                                                 "d":  "It eliminates the need for a human orchestrator."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains the benefit of specialization: \u0027Just like human teams benefit from specialization, agent teams can be more effective... Testing Agent can be more thorough... Review Agent can check security...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s main point about the role of human judgment in the autonomous agent era?",
                                                                 "options":  {
                                                                                 "a":  "Human judgment will no longer be necessary.",
                                                                                 "b":  "Human judgment remains essential for tasks like understanding user needs, making trade-offs, and navigating ambiguity.",
                                                                                 "c":  "Only junior developers will need to use their judgment.",
                                                                                 "d":  "Human judgment is only needed for the initial prompt."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter emphasizes, \u0027Even in the full autonomous agent era, human developers remain essential,\u0027 because development requires \u0027human judgment, domain expertise, and strategic thinking.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  8,
                                           "chapter_title":  "The Opportunity Window",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "Which of the following is NOT listed as a traditional \u0027gatekeeper\u0027 to learning software development that AI is now helping to remove?",
                                                                 "options":  {
                                                                                 "a":  "Syntax Memorization",
                                                                                 "b":  "The need for creative problem-solving",
                                                                                 "c":  "Debugging Cryptic Errors",
                                                                                 "d":  "Configuration Hell"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists Syntax Memorization, Debugging Cryptic Errors, and Configuration Hell as barriers being removed. Creative problem-solving, however, is a skill that becomes more important."
                                                             },
                                                             {
                                                                 "question":  "Why do experienced developers often see greater productivity gains with AI tools compared to beginners?",
                                                                 "options":  {
                                                                                 "a":  "Because they can type faster than the AI.",
                                                                                 "b":  "Because their experience allows them to provide more precise specifications and better evaluate the AI\u0027s output.",
                                                                                 "c":  "Because the AI tools are exclusively designed for them.",
                                                                                 "d":  "Because they refuse to use the AI tools and work manually."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states that experienced developers know \u0027What to ask for,\u0027 \u0027What to look for,\u0027 and \u0027What matters,\u0027 which allows them to leverage AI more effectively."
                                                             },
                                                             {
                                                                 "question":  "According to the technology adoption curve shown in the chapter, where are AI coding tools currently positioned?",
                                                                 "options":  {
                                                                                 "a":  "Innovators",
                                                                                 "b":  "Early Adopters",
                                                                                 "c":  "Transitioning from Early Adopters to Early Majority",
                                                                                 "d":  "Laggards"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explicitly states: \u0027AI coding tools are currently transitioning from Early Adopters to Early Majority. → WE ARE HERE ←\u0027"
                                                             },
                                                             {
                                                                 "question":  "For people with deep expertise in non-technical domains (like healthcare or finance), what is the key opportunity presented by AI coding tools?",
                                                                 "options":  {
                                                                                 "a":  "They can now easily switch to a career in AI research.",
                                                                                 "b":  "Their domain expertise is no longer valuable.",
                                                                                 "c":  "They can now build software solutions for their field without needing to become full-time programmers, as AI handles the coding.",
                                                                                 "d":  "They must now get a traditional computer science degree."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter highlights this opportunity: \u0027AI handles coding; you provide domain expertise. The combination is incredibly valuable... AI doesn\u0027t replace domain expertise. It enables domain experts to build solutions...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s main argument for why \u0027this is the best time in three to four decades to be learning software development\u0027?",
                                                                 "options":  {
                                                                                 "a":  "Because developer salaries are the highest they have ever been.",
                                                                                 "b":  "Because the barriers to entry have been dramatically lowered by AI, while the opportunity for growth is massive.",
                                                                                 "c":  "Because there are fewer developers now, meaning less competition.",
                                                                                 "d":  "Because universities have finally caught up and are teaching all the necessary skills."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The central theme of the chapter is that the combination of falling barriers (syntax, debugging, etc.) and being in the \u0027Early Majority\u0027 phase of a massive technological shift creates a unique and powerful opportunity window."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  9,
                                           "chapter_title":  "Why Traditional CS Education Falls Short",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \u0027Curriculum Lag Phenomenon\u0027 described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "University curricula are updated every 3-6 months, which is too fast for students.",
                                                                                 "b":  "University curricula operate on a 2-4 year revision cycle, which is too slow to keep up with the 3-6 month evolution cycle of AI technology.",
                                                                                 "c":  "Students are lagging behind in their coursework.",
                                                                                 "d":  "The curriculum for computer science has not changed since the 1980s."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines the problem as: \u0027Universities operate on a 2-4 year curriculum revision cycle... Meanwhile, the AI coding landscape is evolving on a 3-6 month cycle.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is listed as a critical skill gap between what traditional CS programs teach and what is needed in the AI era?",
                                                                 "options":  {
                                                                                 "a":  "Understanding algorithms and data structures.",
                                                                                 "b":  "AI Collaboration and Prompt Engineering.",
                                                                                 "c":  "Mathematical reasoning and proof techniques.",
                                                                                 "d":  "Foundational computer architecture."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter identifies several gaps, with the first one being \u0027AI Collaboration and Prompt Engineering,\u0027 which is contrasted with the traditional focus on writing code from scratch."
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s recommendation for a student currently in a CS program?",
                                                                 "options":  {
                                                                                 "a":  "Quit the program immediately as it is obsolete.",
                                                                                 "b":  "Ignore all AI tools and focus only on the university curriculum.",
                                                                                 "c":  "Finish the degree for its foundational value but supplement it with practical AI skills from resources like this book.",
                                                                                 "d":  "Focus only on theory and ignore practical skills."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text advises: \u0027Should you quit? No... Should you supplement your education? Absolutely. Treat university education as the foundation and add AI-driven development skills...\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is \u0027Specification-Driven Development\u0027 identified as a critical missing piece in traditional education?",
                                                                 "options":  {
                                                                                 "a":  "Because it is a historical practice that is no longer relevant.",
                                                                                 "b":  "Because AI agents require clear, comprehensive specifications to work effectively, making it an essential skill.",
                                                                                 "c":  "Because it makes the development process slower and more bureaucratic.",
                                                                                 "d":  "Because it is only useful for hardware engineering, not software."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \u0027AI agents require clear specifications to work effectively. Vague requirements produce poor outputs. Spec-driven development isn\u0027t optional anymore...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the proposed \u0027Path Forward\u0027 to deal with the gaps in traditional CS education?",
                                                                 "options":  {
                                                                                 "a":  "A \u0027Hybrid Learning\u0027 approach, combining foundational theory from universities with practical, modern AI skills from other resources.",
                                                                                 "b":  "Abandoning universities entirely in favor of online bootcamps.",
                                                                                 "c":  "Forcing universities to update their curricula every month.",
                                                                                 "d":  "Replacing all CS theory with vocational training on specific AI tools."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter concludes by recommending a \u0027Hybrid Learning\u0027 path: \u0027The solution isn\u0027t to abandon traditional education—it\u0027s to supplement it intelligently,\u0027 combining the best of both worlds."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  10,
                                           "chapter_title":  "The Inflection Point — Why 2025 Is Different",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "According to the chapter, what are the three independent trends converging in 2025 that mark a genuine inflection point for AI?",
                                                                 "options":  {
                                                                                 "a":  "Slower model improvement, reduced developer adoption, and fewer enterprise products.",
                                                                                 "b":  "Capability breakthroughs, mainstream adoption, and enterprise productization.",
                                                                                 "c":  "A focus on theoretical research, niche tool usage, and academic projects.",
                                                                                 "d":  "Increased marketing hype, stable developer usage, and a decline in AI startups."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly states, \u0027three independent trends are converging simultaneously: 1. Capability breakthroughs... 2. Mainstream adoption... 3. Enterprise productization.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What significant achievement did AI models like GPT-5 and Gemini 2.5 Pro accomplish at the April 2025 ICPC World Finals?",
                                                                 "options":  {
                                                                                 "a":  "They successfully submitted a solution after the time limit.",
                                                                                 "b":  "They performed at a bronze-medal level, showing potential for the future.",
                                                                                 "c":  "They achieved perfect scores and gold-medal level performance, matching or exceeding top human competitors.",
                                                                                 "d":  "They were used to help the human competitors debug their code."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text highlights this breakthrough: \u0027GPT-5 achieved a perfect score... Gemini 2.5 Pro earned a gold medal in the same competition.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The DORA 2025 Report found that developers using AI tools spent a median of how much time per day collaborating with AI?",
                                                                 "options":  {
                                                                                 "a":  "15 minutes",
                                                                                 "b":  "30 minutes",
                                                                                 "c":  "1 hour",
                                                                                 "d":  "2 hours"
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The chapter cites this key finding: \u00272 hours per day median usage: Developers spend roughly one-quarter of their workday collaborating with AI [DORA Report, 2025].\u0027"
                                                             },
                                                             {
                                                                 "question":  "What major market signal in September 2025 demonstrated strong enterprise confidence in AI agents?",
                                                                 "options":  {
                                                                                 "a":  "A major tech CEO gave a keynote speech about AI.",
                                                                                 "b":  "A new open-source AI model was released.",
                                                                                 "c":  "Workday announced a $1.1 billion acquisition of a company building AI development agents.",
                                                                                 "d":  "The Stack Overflow survey showed increased developer interest."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text points to this event as a key indicator: \u0027In September 2025, Workday announced a $1.1 billion acquisition of a company building AI-powered software development agents.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does the chapter address the concern that the claims about AI\u0027s impact are just \u0027corporate marketing\u0027?",
                                                                 "options":  {
                                                                                 "a":  "It agrees that most of the claims are marketing hype.",
                                                                                 "b":  "It argues that corporate marketing is always truthful.",
                                                                                 "c":  "It points to convergent validation from independent academic benchmarks, third-party research, and major financial decisions.",
                                                                                 "d":  "It dismisses the concern without providing evidence."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027Skeptic\u0027s Corner\u0027 section makes this point directly, citing \u0027Academic benchmarks,\u0027 \u0027Third-party research,\u0027 and \u0027Financial decisions\u0027 as credible, independent sources."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  11,
                                           "chapter_title":  "Development Patterns — Vibe Coding vs. Spec-Driven Development",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is \u0027Vibe Coding\u0027?",
                                                                 "options":  {
                                                                                 "a":  "A highly structured development process focused on detailed planning.",
                                                                                 "b":  "Development driven by intuition, exploration, and immediate feedback without a formal specification.",
                                                                                 "c":  "A method that only works for large enterprise teams.",
                                                                                 "d":  "A new programming language designed for AI."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines it as \u0027development driven by intuition, exploration, and immediate feedback. You write code, run it, see what happens, and adjust. There\u0027s no formal specification.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In which of the following contexts is Vibe Coding considered an excellent approach?",
                                                                 "options":  {
                                                                                 "a":  "Building a production feature for a large team.",
                                                                                 "b":  "Learning a new language or framework.",
                                                                                 "c":  "Developing software for a regulated industry.",
                                                                                 "d":  "A project with a long maintenance lifecycle."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explicitly states that Vibe Coding is \u0027genuinely excellent\u0027 for \u0027Learning,\u0027 \u0027Exploration and Discovery,\u0027 and \u0027Low Stakes Solo Work.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the core principle of Spec-Driven Development (SDD)?",
                                                                 "options":  {
                                                                                 "a":  "Writing code as quickly as possible and fixing it later.",
                                                                                 "b":  "Writing a detailed specification first, then tests, and only then implementing the feature.",
                                                                                 "c":  "Avoiding writing any documentation or tests to move faster.",
                                                                                 "d":  "Letting the AI write the specification after the code is finished."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that SDD \u0027inverts the order. You write a specification first... Then you write tests... Only then do you implement the feature.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the comparison between Team A (Vibe Coding) and Team B (Spec-Driven), why did Team A\u0027s initial high velocity lead to problems?",
                                                                 "options":  {
                                                                                 "a":  "Their code was too simple and easy to understand.",
                                                                                 "b":  "They spent too much time on planning.",
                                                                                 "c":  "The lack of a spec led to ambiguity, missed edge cases, and code that was difficult to extend, requiring significant rework.",
                                                                                 "d":  "Their AI coding assistant was not powerful enough."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The example shows that Team A\u0027s approach resulted in code that crashed in staging, was not extensible, and ultimately had to be rebuilt from scratch."
                                                             },
                                                             {
                                                                 "question":  "How does the use of AI change the importance of development discipline like SDD?",
                                                                 "options":  {
                                                                                 "a":  "AI makes discipline unnecessary because it always writes perfect code.",
                                                                                 "b":  "AI makes discipline MORE critical because it amplifies whatever practice you use, good or bad.",
                                                                                 "c":  "AI only works with Vibe Coding.",
                                                                                 "d":  "Discipline is only important when not using AI."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes, \u0027The discipline becomes MORE critical with AI, not less. AI makes it easier to code fast. That makes vibe coding more tempting. And that\u0027s precisely when you need discipline most.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  12,
                                           "chapter_title":  "The DORA Perspective — AI as Amplifier",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the main finding of the DORA 2025 report regarding AI adoption?",
                                                                 "options":  {
                                                                                 "a":  "AI tools fix broken development processes automatically.",
                                                                                 "b":  "AI tools only benefit small startups, not large enterprises.",
                                                                                 "c":  "AI doesn\u0027t fix broken processes; it amplifies them, making good practices better and weak practices worse.",
                                                                                 "d":  "All organizations see a uniform 50% productivity gain from AI."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s central theme is this finding: \u0027AI doesn\u0027t fix broken processes. It amplifies them. If you have strong practices... AI helps you do more of what already works. If you have weak practices, AI helps you create problems faster.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is one of the seven DORA capabilities that determine AI adoption success?",
                                                                 "options":  {
                                                                                 "a":  "A policy of banning all AI tools.",
                                                                                 "b":  "Working in large, infrequent batches.",
                                                                                 "c":  "A clear, documented AI stance on how to use the tools.",
                                                                                 "d":  "Keeping all internal documentation outdated and inaccessible."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists \u0027Clear AI Stance\u0027 as the first of the seven capabilities, explaining that developers need to know what is permitted and restricted."
                                                             },
                                                             {
                                                                 "question":  "Why is \u0027Working in Small Batches\u0027 an important capability for successful AI adoption?",
                                                                 "options":  {
                                                                                 "a":  "It slows down development to a more manageable pace.",
                                                                                 "b":  "It keeps changes reviewable, testable, and safe, which is crucial when AI is accelerating the pace of coding.",
                                                                                 "c":  "It is a practice that AI tools cannot support.",
                                                                                 "d":  "It ensures that only senior developers can contribute code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains that because AI encourages faster iteration, \u0027Small batches keep changes reviewable, testable, and safe.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter uses an analogy of a mountain road to explain the role of \u0027guardrails\u0027 (like automated tests and code reviews). What is the point of the analogy?",
                                                                 "options":  {
                                                                                 "a":  "Guardrails slow you down and should be removed to increase speed.",
                                                                                 "b":  "Guardrails provide confidence and safety, which allows you to move faster, not slower.",
                                                                                 "c":  "Guardrails are expensive and unnecessary for experienced drivers.",
                                                                                 "d":  "Only roads without guardrails are interesting to drive on."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The analogy illustrates that \u0027The road with guardrails... allows drivers to go faster... because the guardrails provide confidence.\u0027 The same applies to development safety systems."
                                                             },
                                                             {
                                                                 "question":  "According to the DORA data, what was the outcome for organizations in the bottom quartile for the seven capabilities when they adopted AI?",
                                                                 "options":  {
                                                                                 "a":  "They saw the highest productivity gains.",
                                                                                 "b":  "They saw modest productivity gains but with a significant increase in change failure rates.",
                                                                                 "c":  "Their outcomes were identical to organizations in the top quartile.",
                                                                                 "d":  "They saw no change in their performance."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Skeptic\u0027s Corner\u0027 provides the data: \u0027Those in the bottom quartile for the seven capabilities saw 12% median productivity gains with 19% higher change failure rates.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  13,
                                           "chapter_title":  "The Modern AI Development Stack",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the three layers of the modern AI development stack described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Hardware, Operating System, and Applications.",
                                                                                 "b":  "Frontend, Backend, and Database.",
                                                                                 "c":  "Frontier Models, AI-First IDEs, and Development Agents.",
                                                                                 "d":  "Chatbots, Image Generators, and Code Analyzers."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter introduces this architecture explicitly: \u0027It\u0027s a three-layer architecture that separates concerns... Layer 1: Frontier Models... Layer 2: AI-First IDEs... Layer 3: Development Agents.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the primary role of \u0027Layer 1: Frontier Models\u0027 in the stack?",
                                                                 "options":  {
                                                                                 "a":  "To provide the user interface where the developer writes code.",
                                                                                 "b":  "To provide the underlying intelligence for reasoning and code generation.",
                                                                                 "c":  "To execute multi-step tasks autonomously.",
                                                                                 "d":  "To store the project\u0027s files and version history."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text defines this layer\u0027s role: \u0027This layer handles the \u0027thinking.\u0027 When you ask for code suggestions, explanations, or debugging help, the frontier model processes your request...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What key change from 2024 to 2025 enabled the move from \u0027Tool Silos\u0027 to a \u0027Modular Stack\u0027?",
                                                                 "options":  {
                                                                                 "a":  "All AI models became open-source.",
                                                                                 "b":  "The emergence of standards like the Model Context Protocol (MCP) and stable model APIs allowed for interoperability.",
                                                                                 "c":  "Developers decided to only use one tool.",
                                                                                 "d":  "AI models stopped improving."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter credits three breakthroughs, including \u0027Model Context Protocol (MCP)\u0027 and stabilized \u0027Frontier model APIs,\u0027 which enabled interoperability."
                                                             },
                                                             {
                                                                 "question":  "What analogy is used to explain the importance of the Model Context Protocol (MCP)?",
                                                                 "options":  {
                                                                                 "a":  "It\u0027s like a specific brand of computer that only works with its own software.",
                                                                                 "b":  "It\u0027s like a railroad track that only fits one type of train.",
                                                                                 "c":  "It\u0027s like a universal language for AI tools to communicate with resources.",
                                                                                 "d":  "It\u0027s like USB, a standard that allows any compatible device to connect to any port."
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The text makes a direct analogy: \u0027MCP is like USB. Before USB, every device had its own charging cable. After USB, you could plug any device into any port. MCP does the same for AI tools.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main advantage of the three-layer modular stack for a developer?",
                                                                 "options":  {
                                                                                 "a":  "It forces the developer to use only one specific tool and workflow.",
                                                                                 "b":  "It is more expensive and complex than the previous approach.",
                                                                                 "c":  "It reduces vendor lock-in and allows the developer to choose the best tool for each layer and swap them independently.",
                                                                                 "d":  "It eliminates the need for a human developer entirely."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter contrasts the 2024 \u0027Tool Silos\u0027 with the 2025 \u0027Modular Stack,\u0027 highlighting the benefit of low vendor lock-in and the ability to \u0027swap layers independently.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  14,
                                           "chapter_title":  "Chapter 2: The AI Turning Point Quiz",
                                           "skipped":  true,
                                           "questions":  [

                                                         ]
                                       },
                                       {
                                           "chapter_id":  15,
                                           "chapter_title":  "The Billion-Dollar Question",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \u0027billion-dollar question\u0027 that the chapter poses?",
                                                                 "options":  {
                                                                                 "a":  "Will AI create billion-dollar companies?",
                                                                                 "b":  "How will you get a piece of the AI opportunity?",
                                                                                 "c":  "Can a solo developer learn to code?",
                                                                                 "d":  "Which AI model is the best?"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter opens with this direct question: \u0027The question isn\u0027t whether AI will create billion-dollar companies. It already is. The question is: how will *you* get a piece of it?\u0027"
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, how has the playbook for building a billion-dollar software company changed?",
                                                                 "options":  {
                                                                                 "a":  "It now requires more funding and a larger team than ever before.",
                                                                                 "b":  "The playbook is broken, and a solo developer can now potentially orchestrate AI agents to achieve massive scale.",
                                                                                 "c":  "The playbook has not changed at all.",
                                                                                 "d":  "It is now impossible for new companies to compete with incumbents."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \u0027Today, the playbook is broken... A solo developer—working with AI coding agents like Claude Code—could potentially orchestrate teams of specialized AI agents...\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is NOT one of the three converging forces mentioned that create the current opportunity?",
                                                                 "options":  {
                                                                                 "a":  "AI tools crossing a critical capability threshold.",
                                                                                 "b":  "Mainstream adoption of AI tools by the majority of developers.",
                                                                                 "c":  "A decrease in the economic value of software.",
                                                                                 "d":  "A dramatic shift in the economics of software production."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists three forces: tools\u0027 capability, mainstream adoption, and a shift in economics. A decrease in software\u0027s value is contrary to the chapter\u0027s argument."
                                                             },
                                                             {
                                                                 "question":  "What is the most important takeaway from the chapter regarding the opportunity for individuals?",
                                                                 "options":  {
                                                                                 "a":  "You need a traditional computer science degree to succeed.",
                                                                                 "b":  "You need at least $100 million in venture capital.",
                                                                                 "c":  "The opportunity is only for experienced developers at large tech companies.",
                                                                                 "d":  "You no longer need a large team or venture capital; you need understanding, strategy, and the ability to work with AI agents."
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The chapter concludes, \u0027You don\u0027t need a large team, years of experience, or venture capital to build valuable software. You need understanding, strategy, and the ability to work effectively with AI agents.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The 2025 Stack Overflow Developer Survey found that what percentage of developers are using or plan to use AI tools?",
                                                                 "options":  {
                                                                                 "a":  "25%",
                                                                                 "b":  "51%",
                                                                                 "c":  "84%",
                                                                                 "d":  "100%"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter cites this statistic as evidence of mainstream adoption: \u0027The 2025 Stack Overflow Developer Survey found that 84% of developers are using or plan to use AI tools...\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  16,
                                           "chapter_title":  "The Snakes and Ladders Framework: Why Vertical Markets Beat Head-On Competition",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In the \u0027Snakes and Ladders framework,\u0027 which competitive layer is described as \u0027The Snakes\u0027 that solo entrepreneurs should avoid?",
                                                                 "options":  {
                                                                                 "a":  "Layer 1: Consumer AI Backbone (e.g., competing with ChatGPT or Gemini).",
                                                                                 "b":  "Layer 2: Agentic Developer Tools (e.g., Claude Code).",
                                                                                 "c":  "Layer 3: Vertical Market Subagents (e.g., finance or healthcare agents).",
                                                                                 "d":  "Layer 4: Orchestrator Layer."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter explicitly warns, \u0027At the bottom sit OpenAI (with ChatGPT) and Google (with Gemini). These are your snakes... Do not compete here as a solo entrepreneur. You will lose.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is Layer 2 (Agentic Developer Tools) described as the \u0027first ladder\u0027?",
                                                                 "options":  {
                                                                                 "a":  "Because it is the most expensive layer to enter.",
                                                                                 "b":  "Because it allows for specialization and defensibility by solving specific developer workflows, leading to faster adoption.",
                                                                                 "c":  "Because it is a consumer-facing layer with billions of users.",
                                                                                 "d":  "Because it requires no technical skill to build."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains that specializing in a developer workflow, like Claude Code does, leads to \u0027Faster adoption\u0027 and \u0027Defensibility,\u0027 making it a strategic first step."
                                                             },
                                                             {
                                                                 "question":  "What is the critical insight about competing in Layer 3 (Vertical Market Subagents)?",
                                                                 "options":  {
                                                                                 "a":  "You must compete directly with other startups in the same vertical.",
                                                                                 "b":  "The main competitors are large incumbents (like Bloomberg or Epic Systems) who cannot respond quickly to disruption.",
                                                                                 "c":  "This layer has the lowest revenue potential.",
                                                                                 "d":  "This layer is only for large, established companies."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter highlights, \u0027The competitors aren\u0027t other startups. They\u0027re incumbents... And here\u0027s the critical insight: incumbents cannot respond quickly...\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter uses the historical precedent of mobile operating systems to illustrate its point. What was Microsoft\u0027s strategic mistake with Windows Mobile?",
                                                                 "options":  {
                                                                                 "a":  "They focused too much on the enterprise market.",
                                                                                 "b":  "They tried to compete directly with Apple and Google on consumer appeal (Layer 1) instead of leveraging their strengths in a different layer first.",
                                                                                 "c":  "Their operating system was technically superior but poorly marketed.",
                                                                                 "d":  "They did not invest enough money in development."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text analyzes this failure: \u0027Microsoft\u0027s mistake was trying to win the consumer layer against entrenched competitors. They should have focused on enterprise first...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the core strategic lesson of the Snakes and Ladders framework?",
                                                                 "options":  {
                                                                                 "a":  "Always compete head-on with the largest players to prove your strength.",
                                                                                 "b":  "Avoid all competition and only build for yourself.",
                                                                                 "c":  "Dominate a specific, defensible layer first (like developer tools or a vertical market) and then integrate upward.",
                                                                                 "d":  "The only layer that matters is the consumer layer."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The framework\u0027s lesson is summarized as: \u0027Don\u0027t compete on consumer appeal (Layer 1). Own a developer layer or vertical market layer first, become indispensable, then leverage that dominance to integrate upward.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  17,
                                           "chapter_title":  "The Economics of Super Orchestrators: Why the 90-10 Rule Changes Everything",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \u002790-10 Economic Shift\u0027 described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "90% of companies will fail, and 10% will succeed.",
                                                                                 "b":  "90% of work is strategic human judgment, and 10% is mechanical execution.",
                                                                                 "c":  "90% of work is mechanical (and can be automated by AI), while 10% is strategic human judgment.",
                                                                                 "d":  "A company should only have 10 employees for every 90 customers."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines this rule: \u002790% of the work is mechanical... All of this can be automated by AI... 10% of the work is human judgment... This work requires human insight and cannot be delegated to AI.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter uses the acquisitions of Instagram and WhatsApp as historical precedents. What economic pattern did these companies demonstrate?",
                                                                 "options":  {
                                                                                 "a":  "A very low value-per-employee, requiring thousands of workers.",
                                                                                 "b":  "A focus on hardware sales rather than software.",
                                                                                 "c":  "An incredibly high value-per-employee ($77M and $345M, respectively) by delegating the \u002790% mechanical work\u0027 to infrastructure.",
                                                                                 "d":  "A business model based on advertising revenue from day one."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text calculates the value per employee for both companies, showing how small teams created immense value by focusing on the \u002710%\u0027 strategic work."
                                                             },
                                                             {
                                                                 "question":  "According to the chapter\u0027s \u0027Path from Solo to $10M Annual Revenue,\u0027 how does a solo developer\u0027s team size scale with revenue?",
                                                                 "options":  {
                                                                                 "a":  "The team must grow linearly with revenue; $10M revenue requires a team of 100.",
                                                                                 "b":  "The team doesn\u0027t scale with revenue; a solo developer can reach $10M ARR with a team of only 2-3 people.",
                                                                                 "c":  "A solo developer cannot realistically reach more than $100K in revenue.",
                                                                                 "d":  "The team size doubles for every million in revenue."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The table in the chapter shows that a team of 2-3 can reach the $5-10M ARR stage because \u0027Subagents scale work\u0027 and \u0027the team doesn\u0027t scale with revenue.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the primary bottleneck for a solo entrepreneur in the AI era, according to the chapter?",
                                                                 "options":  {
                                                                                 "a":  "The cost of cloud infrastructure.",
                                                                                 "b":  "The speed of writing code.",
                                                                                 "c":  "Human attention for making good strategic decisions.",
                                                                                 "d":  "The number of engineers they can hire."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter states, \u0027The bottleneck is human attention, not infrastructure. As long as you make good strategic decisions... the business scales.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why does the 90-10 rule matter now more than ever?",
                                                                 "options":  {
                                                                                 "a":  "It has always been easy to delegate the 90% mechanical work.",
                                                                                 "b":  "AI agents now make it possible to efficiently delegate the 90% mechanical work, which was previously not possible for a solo developer.",
                                                                                 "c":  "The 90-10 rule is a new concept invented in 2025.",
                                                                                 "d":  "The cost of human labor has become too high."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains, \u0027The 90-10 rule has always existed, but it *didn\u0027t matter* before because humans couldn\u0027t delegate the 90% efficiently... AI agents eliminate that bottleneck.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  18,
                                           "chapter_title":  "From Code Reuse to Vertical Intelligence: The New Architecture of Software",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the new principle of software architecture in the AI era that replaces the traditional \u0027Don\u0027t Repeat Yourself\u0027 (DRY) principle?",
                                                                 "options":  {
                                                                                 "a":  "Reuse code, not intelligence.",
                                                                                 "b":  "Reuse intelligence, not code.",
                                                                                 "c":  "Never reuse anything.",
                                                                                 "d":  "Only reuse code written by humans."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter introduces this new paradigm: \u0027The new principle is: Reuse intelligence, not code.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is code considered \u0027disposable\u0027 in the AI era?",
                                                                 "options":  {
                                                                                 "a":  "Because the code is low quality and must be thrown away.",
                                                                                 "b":  "Because an AI subagent can generate thousands of lines of specialized code in seconds, making regeneration cheaper than maintenance.",
                                                                                 "c":  "Because code is no longer stored in version control.",
                                                                                 "d":  "Because all software now has a very short lifespan."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains, \u0027A subagent can generate 10,000 lines of specialized code in ten seconds. Maintaining that code... is expensive. Generating fresh code... is free.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is NOT one of the five components of a reusable subagent\u0027s \u0027vertical intelligence\u0027?",
                                                                 "options":  {
                                                                                 "a":  "System Prompt (Persona + Scope).",
                                                                                 "b":  "A complex, monolithic codebase.",
                                                                                 "c":  "Vertical Skills (Domain Expertise).",
                                                                                 "d":  "MCP Vertical Connections (Industry APIs)."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists five components: System Prompt, Horizontal Skills, Vertical Skills, MCP Horizontal Connections, and MCP Vertical Connections. A monolithic codebase is contrary to the principle of disposable code."
                                                             },
                                                             {
                                                                 "question":  "What is the primary source of a product\u0027s defensibility or \u0027moat\u0027 in the vertical intelligence architecture?",
                                                                 "options":  {
                                                                                 "a":  "The specific lines of code generated by the AI.",
                                                                                 "b":  "The general-purpose AI model being used.",
                                                                                 "c":  "The deep, hard-to-replicate integrations with incumbent systems (MCP Vertical Connections).",
                                                                                 "d":  "The reusability of the code across different industries."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter emphasizes this point: \u0027This is where the defensibility lives... These integrations are not reusable across industries, but they\u0027re the moat.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does the AI-driven approach to building an accounting solution differ from the traditional approach?",
                                                                 "options":  {
                                                                                 "a":  "The AI approach focuses on building one large, reusable library for all customers.",
                                                                                 "b":  "The AI approach generates new, disposable code for each customer but reuses the core \u0027intelligence\u0027 (prompts, skills, integrations).",
                                                                                 "c":  "The traditional approach is faster and more flexible.",
                                                                                 "d":  "There is no difference between the two approaches."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example contrasts the two, stating the AI approach doesn\u0027t reuse code but does \u0027reuse the intelligence—the system prompt, the tax knowledge, the integrations.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  19,
                                           "chapter_title":  "The Piggyback Protocol Pivot (PPP) Strategy",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary goal of Phase 1 of the Piggyback Protocol Pivot (PPP) strategy?",
                                                                 "options":  {
                                                                                 "a":  "To compete directly with and replace incumbent systems.",
                                                                                 "b":  "To become the indispensable bridge between fragmented incumbent systems by building integrations.",
                                                                                 "c":  "To raise a large round of venture capital funding.",
                                                                                 "d":  "To build a consumer-facing application with millions of users."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines Phase 1\u0027s goal: \u0027Become the indispensable bridge between fragmented incumbent systems... You\u0027re not replacing the incumbents. You\u0027re becoming the bridge.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why does the PPP strategy lead to a lower Customer Acquisition Cost (CAC)?",
                                                                 "options":  {
                                                                                 "a":  "Because the product is offered for free.",
                                                                                 "b":  "Because you are an add-on that makes existing systems more valuable, not a replacement that requires customers to \u0027rip-and-replace.\u0027",
                                                                                 "c":  "Because it relies entirely on expensive paid advertising.",
                                                                                 "d":  "Because it targets individual consumers, not businesses."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains, \u0027Customer acquisition cost (CAC) drops because you\u0027re not asking them to rip-and-replace. You\u0027re asking them to add a dashboard.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the key activity during Phase 3, the \u0027Strategic Pivot\u0027?",
                                                                 "options":  {
                                                                                 "a":  "To continue only as an infrastructure bridge.",
                                                                                 "b":  "To sell the company to one of the incumbents.",
                                                                                 "c":  "To layer intelligent subagents on top of the integration bridge to automate decisions and workflows.",
                                                                                 "d":  "To abandon the vertical market and move to a new one."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter describes the pivot: \u0027Now you layer subagents on top of your infrastructure bridge... your infrastructure bridge becomes a super orchestrator. You\u0027re no longer just aggregating data; you\u0027re automating decisions.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why are incumbent companies (like Blackboard in the example) often unable to respond quickly to the PPP strategy?",
                                                                 "options":  {
                                                                                 "a":  "Because they lack the financial resources.",
                                                                                 "b":  "Because they are not aware of the new technology.",
                                                                                 "c":  "Because of organizational inertia, legacy architecture, and misaligned business incentives.",
                                                                                 "d":  "Because they welcome the competition."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text lists three reasons incumbents can\u0027t respond: \u0027Organizational inertia,\u0027 \u0027Legacy architecture,\u0027 and \u0027Incentives misaligned.\u0027"
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, what are the two key dimensions on which the PPP strategy wins against direct competition?",
                                                                 "options":  {
                                                                                 "a":  "Higher prices and slower development speed.",
                                                                                 "b":  "A larger marketing budget and a bigger team.",
                                                                                 "c":  "Lower Customer Acquisition Cost (CAC) and higher defensibility from deep integrations.",
                                                                                 "d":  "A more recognizable brand name and more features."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The comparison table and text conclude that PPP \u0027wins on two dimensions: CAC and defensibility.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  20,
                                           "chapter_title":  "Three Requirements for Vertical Success: All Three, or None",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "Which of the following is NOT one of the three non-negotiable requirements for vertical success?",
                                                                 "options":  {
                                                                                 "a":  "Domain expertise (via fine-tuned models or vertical intelligence).",
                                                                                 "b":  "A large marketing budget.",
                                                                                 "c":  "Deep integrations with existing systems.",
                                                                                 "d":  "Complete agentic solutions that solve an end-to-end problem."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter outlines three specific requirements, and a large marketing budget is not one of them. The focus is on product and technology, not marketing spend."
                                                             },
                                                             {
                                                                 "question":  "The chapter describes two paths to achieving domain expertise. What are they?",
                                                                 "options":  {
                                                                                 "a":  "Getting a PhD or working in the industry for 20 years.",
                                                                                 "b":  "Fine-tuning an AI model on domain-specific data, or building vertical reusable intelligence with sub-agents and skills.",
                                                                                 "c":  "Copying a competitor\u0027s product or hiring their employees.",
                                                                                 "d":  "Reading books or watching online tutorials."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explicitly details these two paths: \u00271. Fine-tune the underlying AI model... 2. Build vertical reusable intelligence through specialized sub-agents and agent skills.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main advantage of using \u0027Vertical Reusable Intelligence\u0027 (Path 2) over \u0027Fine-Tuned Models\u0027 (Path 1) for a startup?",
                                                                 "options":  {
                                                                                 "a":  "It is less transparent and harder to debug.",
                                                                                 "b":  "It requires more data and is more expensive.",
                                                                                 "c":  "It is faster to build and iterate on, and easier to update when domain rules change.",
                                                                                 "d":  "It is less defensible against competitors."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists the strengths of Path 2 as being \u0027Faster to build and iterate,\u0027 \u0027More transparent and debuggable,\u0027 and \u0027Easier to update.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why did OpenAI\u0027s \u0027Study Mode\u0027 fail to become a transformative product, according to the chapter\u0027s analysis?",
                                                                 "options":  {
                                                                                 "a":  "It was too expensive for schools to afford.",
                                                                                 "b":  "It was technically perfect but had poor marketing.",
                                                                                 "c":  "It only partially met the three requirements, lacking deep domain expertise, deep integrations, and a complete agentic solution.",
                                                                                 "d":  "It was released too early, before the market was ready."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter analyzes Study Mode\u0027s failure through the lens of the three requirements, concluding it only \u0027Partially\u0027 met each one and was therefore a \u0027feature, not a product.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the consequence of having domain expertise and an agentic solution, but NO deep integrations?",
                                                                 "options":  {
                                                                                 "a":  "You have a perfect product that everyone will use.",
                                                                                 "b":  "You are just a thin wrapper around a general AI that competitors can easily replicate.",
                                                                                 "c":  "You are building in a sandbox, disconnected from real customer workflows, making your solution useless.",
                                                                                 "d":  "You are just a data pipeline."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter outlines the consequences of missing each element: \u0027If you have domain expertise + agentic solution but NO integrations, you\u0027re building in a sandbox. No real customer workflows.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  21,
                                           "chapter_title":  "Pause and Reflect",
                                           "skipped":  true,
                                           "questions":  [

                                                         ]
                                       },
                                       {
                                           "chapter_id":  22,
                                           "chapter_title":  "Why This Moment Demands a New Paradigm",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \u0027Partial Adoption Problem\u0027 described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Adopting only a few AI tools and fitting them into old workflows, which leads to a productivity plateau.",
                                                                                 "b":  "Adopting all AI tools at once, which is too overwhelming.",
                                                                                 "c":  "The problem that AI tools are not yet complete enough for adoption.",
                                                                                 "d":  "A problem where only part of a development team adopts AI tools."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter defines this as adopting tools \u0027piecemeal, one at a time, fitting them into their existing workflows,\u0027 which misses the larger systemic benefit."
                                                             },
                                                             {
                                                                 "question":  "The chapter argues that the nine simultaneous revolutions in software development don\u0027t just add up. What do they do instead?",
                                                                 "options":  {
                                                                                 "a":  "They cancel each other out.",
                                                                                 "b":  "They multiply, creating a 10x leap in what\u0027s possible rather than a 2x benefit.",
                                                                                 "c":  "They only benefit senior developers.",
                                                                                 "d":  "They make software development more complicated."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \u0027these nine revolutions don\u0027t just add up—they *multiply*. When you combine natural language programming with exponential learning velocity, you don\u0027t get twice the benefit. You get a 10x leap...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the fundamental difference in the mental model between the old paradigm and the new AIDD paradigm?",
                                                                 "options":  {
                                                                                 "a":  "Old: \u0027I write code with AI.\u0027 New: \u0027I write code by myself.\u0027",
                                                                                 "b":  "Old: \u0027I am a manager.\u0027 New: \u0027I am a coder.\u0027",
                                                                                 "c":  "Old: \u0027I\u0027m a developer who sometimes uses AI tools.\u0027 New: \u0027I\u0027m a developer who orchestrates AI systems to co-create software.\u0027",
                                                                                 "d":  "There is no difference in the mental model."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explicitly contrasts these two mental models, highlighting the shift from being a solo coder to an orchestrator of a human-AI system."
                                                             },
                                                             {
                                                                 "question":  "In the story of Priya and Marcus, why was the junior developer, Marcus, more productive than the senior developer, Priya?",
                                                                 "options":  {
                                                                                 "a":  "Marcus was a genius who was naturally a better coder.",
                                                                                 "b":  "Marcus worked longer hours than Priya.",
                                                                                 "c":  "Marcus used AI as a complete system (spec-driven, AI-paired programming), while Priya used it as a collection of individual tools.",
                                                                                 "d":  "Priya\u0027s AI tools were outdated."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter uses this story to illustrate the core argument: \u0027While Priya was using AI as a *tool*, Marcus was using AI as a *system*.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main cost of the \u0027Partial Adoption Problem\u0027?",
                                                                 "options":  {
                                                                                 "a":  "You learn new skills too quickly.",
                                                                                 "b":  "You get stuck in a \u0027productivity plateau\u0027 with minor gains and fall behind those who adopt the full system.",
                                                                                 "c":  "The cost of AI tools becomes too high.",
                                                                                 "d":  "It forces you to work in a team."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text warns, \u0027You get stuck in the \u0027productivity plateau.\u0027 You see a 10-20% boost... but you never break through to the larger gains...\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  23,
                                           "chapter_title":  "AIDD Defined: A Complete Methodology",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the core definition of AI-Driven Development (AIDD)?",
                                                                 "options":  {
                                                                                 "a":  "A methodology where AI replaces the developer entirely.",
                                                                                 "b":  "A set of tools for writing code faster.",
                                                                                 "c":  "A specification-first methodology that transforms developers into specification engineers and system architects.",
                                                                                 "d":  "A traditional development process with AI-powered debugging."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter provides a clear definition: \u0027AI-Driven Development (AIDD) is a specification-first methodology that transforms developers into specification engineers and system architects.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which of the following is one of the nine defining characteristics of AIDD?",
                                                                 "options":  {
                                                                                 "a":  "Human-Excluded",
                                                                                 "b":  "Quality-Gated",
                                                                                 "c":  "Code-First",
                                                                                 "d":  "Manually-Verified"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists nine characteristics, including \u0027Quality-Gated: Automated validation at every step.\u0027 The other options are the opposite of AIDD principles."
                                                             },
                                                             {
                                                                 "question":  "How does the developer\u0027s role change with AIDD compared to traditional development?",
                                                                 "options":  {
                                                                                 "a":  "The focus shifts from writing specifications to writing code.",
                                                                                 "b":  "The developer becomes less involved in the design process.",
                                                                                 "c":  "The developer\u0027s primary focus shifts from writing code to writing specifications and designing systems.",
                                                                                 "d":  "The developer\u0027s role does not change."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The comparison table clearly shows the shift: \u0027Primary Focus\u0027 changes from \u0027Writing code\u0027 to \u0027Writing specifications,\u0027 and the role changes from \u0027Individual contributor\u0027 to \u0027Specification engineer \u0026 architect.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s clarification on what AIDD is NOT?",
                                                                 "options":  {
                                                                                 "a":  "It is not a complete methodology.",
                                                                                 "b":  "It is not a replacement for developer judgment.",
                                                                                 "c":  "It is not a specification-first approach.",
                                                                                 "d":  "It is not a way to focus on architecture."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly clarifies that AIDD \u0027is not a replacement for developer judgment (you remain the decision maker).\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why was AIDD not possible five years ago?",
                                                                 "options":  {
                                                                                 "a":  "Because developers were not interested in new methodologies.",
                                                                                 "b":  "Because the necessary enabling technologies (like advanced AI models, agent frameworks, and AI-first IDEs) had not yet converged.",
                                                                                 "c":  "Because traditional development was more efficient.",
                                                                                 "d":  "Because there were no cloud platforms available."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains that \u0027AIDD emerged from the convergence of nine technological revolutions,\u0027 including advanced AI models and structured agent frameworks that did not exist in a mature state five years prior."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  24,
                                           "chapter_title":  "The Nine Pillars—Overview and Integration",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of the nine pillars of AIDD?",
                                                                 "options":  {
                                                                                 "a":  "They are a list of recommended software to purchase.",
                                                                                 "b":  "They are nine competing methodologies for software development.",
                                                                                 "c":  "They are nine integrated technologies and practices that form the foundation of AIDD, each removing a specific barrier.",
                                                                                 "d":  "They are nine theoretical concepts with no practical application."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter introduces them as \u0027nine integrated technologies and practices—the concrete foundation that makes AIDD\u0027s characteristics achievable. Each technology removes a specific barrier...\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which pillar is responsible for removing the barrier of \u0027Tool integration complexity\u0027?",
                                                                 "options":  {
                                                                                 "a":  "AI CLI \u0026 Coding Agents",
                                                                                 "b":  "AI-First IDEs",
                                                                                 "c":  "MCP Standard (Model Context Protocol)",
                                                                                 "d":  "Linux Universal Dev Environment"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The table in the chapter directly maps the \u0027MCP Standard\u0027 to removing the barrier of \u0027Tool integration complexity.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter emphasizes that the nine pillars are interdependent. What does this mean?",
                                                                 "options":  {
                                                                                 "a":  "You only need to learn one of the nine pillars to be effective.",
                                                                                 "b":  "The pillars are completely separate and do not affect each other.",
                                                                                 "c":  "The pillars rely on each other, and their real power emerges when they work together as a system.",
                                                                                 "d":  "You must learn all nine pillars at the same time."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text states, \u0027the pillars depend on each other,\u0027 and gives examples of how removing one pillar creates gaps in the system."
                                                             },
                                                             {
                                                                 "question":  "What new type of developer does the integrated system of nine pillars enable?",
                                                                 "options":  {
                                                                                 "a":  "The \u0027I-shaped\u0027 specialist with deep expertise in only one area.",
                                                                                 "b":  "The \u0027T-shaped\u0027 generalist with shallow knowledge of many areas.",
                                                                                 "c":  "The \u0027M-shaped\u0027 developer with deep expertise across multiple complementary domains.",
                                                                                 "d":  "The \u0027O-shaped\u0027 developer with no specific expertise."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter introduces this new concept: \u0027AIDD enables something new: **M-shaped developers** who can go deep in multiple domains simultaneously.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the example of Maya building a financial analytics platform, how did she ensure the quality of the AI-generated code?",
                                                                 "options":  {
                                                                                 "a":  "By manually reviewing every single line of code.",
                                                                                 "b":  "By trusting the AI completely without verification.",
                                                                                 "c":  "By writing tests first (Test-Driven Development, Pillar 6).",
                                                                                 "d":  "By asking another developer to review the code."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The example story shows the integration of the pillars: \u0027She writes tests first (Pillar 6), ensuring the AI-generated code meets requirements.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  25,
                                           "chapter_title":  "The Nine Pillars Detailed—Deep Dive",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What makes Pillar 1, \u0027AI CLI \u0026 Coding Agents,\u0027 revolutionary compared to earlier AI tools?",
                                                                 "options":  {
                                                                                 "a":  "They are web-based chat interfaces.",
                                                                                 "b":  "They operate in the terminal with full system access, acting as autonomous partners rather than just editor plugins.",
                                                                                 "c":  "They can only perform simple code completion.",
                                                                                 "d":  "They do not have access to the user\u0027s codebase."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter distinguishes them by stating they \u0027run in your terminal, access your codebase directly, and execute commands on your behalf,\u0027 unlike earlier tools."
                                                             },
                                                             {
                                                                 "question":  "What is the revolutionary aspect of Pillar 2, \u0027Markdown as Programming Language\u0027?",
                                                                 "options":  {
                                                                                 "a":  "It requires developers to learn a new, complex programming language.",
                                                                                 "b":  "It makes documentation separate and less important than code.",
                                                                                 "c":  "It allows human-readable, natural language specifications to become executable \u0027source code\u0027 for AI agents.",
                                                                                 "d":  "It is a tool for creating visually appealing documents."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text explains that with this pillar, \u0027Markdown-formatted natural language specifications become executable \u0027source code\u0027 for AI agents.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The Model Context Protocol (MCP), Pillar 3, is compared to what historical technology standard?",
                                                                 "options":  {
                                                                                 "a":  "The QWERTY keyboard layout.",
                                                                                 "b":  "The HTTP protocol for the web.",
                                                                                 "c":  "The USB standard for connecting devices.",
                                                                                 "d":  "The vinyl record format."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter makes a direct analogy: \u0027Remember when every device had its own charging cable? Then USB became standard... MCP aims to do this for AI tool integration.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is Test-Driven Development (TDD), Pillar 6, considered so critical in the AI era?",
                                                                 "options":  {
                                                                                 "a":  "Because AI agents are incapable of writing tests.",
                                                                                 "b":  "Because it slows down the development process to a safer pace.",
                                                                                 "c":  "Because it provides a safety net to automatically verify the correctness of the large volume of code generated by AI.",
                                                                                 "d":  "Because it is a new methodology invented specifically for AI."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text states that TDD \u0027becomes critical with AI-generated code. You can\u0027t manually verify every line an AI agent writes—but you can verify that it passes comprehensive tests.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the primary function of Pillar 9, \u0027Universal Cloud Deployment,\u0027 using tools like Kubernetes and Docker?",
                                                                 "options":  {
                                                                                 "a":  "To make cloud deployment more complex and require more specialists.",
                                                                                 "b":  "To standardize infrastructure and make production deployment accessible to individual developers, not just DevOps experts.",
                                                                                 "c":  "To lock developers into a single cloud provider.",
                                                                                 "d":  "To run applications only on local machines."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that these technologies \u0027make cloud deployment accessible to developers with basic knowledge,\u0027 removing the need for specialized DevOps expertise for many tasks."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  26,
                                           "chapter_title":  "The M-Shaped Developer—What AIDD Makes Possible",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the defining characteristic of an \u0027M-Shaped Developer\u0027?",
                                                                 "options":  {
                                                                                 "a":  "Deep expertise in only one area (I-shaped).",
                                                                                 "b":  "Shallow knowledge across many domains (Generalist).",
                                                                                 "c":  "Deep, production-level mastery across multiple complementary domains.",
                                                                                 "d":  "No technical expertise, only management skills."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines the M-Shaped Developer as having \u0027multiple peaks—deep, production-level mastery across several complementary domains.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How do the nine pillars of AIDD enable the M-Shaped Developer profile?",
                                                                 "options":  {
                                                                                 "a":  "By making it harder to learn new domains.",
                                                                                 "b":  "By removing the cognitive overload that traditionally prevented mastery in multiple domains.",
                                                                                 "c":  "By requiring developers to specialize in only one of the nine pillars.",
                                                                                 "d":  "By replacing the need for any deep expertise."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains that traditional development was \u0027cognitively overwhelming,\u0027 and then details how each of the nine pillars removes a specific barrier to enable multi-domain mastery."
                                                             },
                                                             {
                                                                 "question":  "In the \u0027Real M-Shaped Profiles in Action\u0027 section, what does the \u0027Vertical SaaS Builder\u0027 profile combine?",
                                                                 "options":  {
                                                                                 "a":  "Only backend and frontend expertise.",
                                                                                 "b":  "Only DevOps and security expertise.",
                                                                                 "c":  "Healthcare domain knowledge, full-stack development, MLOps, and product design.",
                                                                                 "d":  "Only marketing and sales skills."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The example explicitly lists this combination of skills, showing how one person can cover roles that would traditionally require a team of five specialists."
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a realistic constraint on M-Shaped development mentioned in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "AI can completely replace the need for deep expertise in safety-critical or regulated domains.",
                                                                                 "b":  "All domain combinations are equally easy to master.",
                                                                                 "c":  "An individual\u0027s capabilities may exceed what their organization\u0027s structure allows them to execute.",
                                                                                 "d":  "Having M-shaped capabilities guarantees business success."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists several constraints, including \u0027Organizational Context Matters,\u0027 noting that large enterprises may still require specialist handoffs, limiting a single person\u0027s autonomy."
                                                             },
                                                             {
                                                                 "question":  "What is the key insight about how an M-Shaped developer should approach their work?",
                                                                 "options":  {
                                                                                 "a":  "They should try to be a generalist with only surface-level knowledge.",
                                                                                 "b":  "They should choose 2-4 complementary domains to master with AI augmentation.",
                                                                                 "c":  "They must become a world-class expert in all nine pillars before starting.",
                                                                                 "d":  "They should focus on one domain and delegate all others completely."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises, \u0027It\u0027s about choosing **2-4 complementary domains** where you can maintain deep expertise with AI augmentation.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  27,
                                           "chapter_title":  "Why All Nine Matter—Urgency Without Panic",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the central argument of the chapter regarding the nine pillars?",
                                                                 "options":  {
                                                                                 "a":  "Mastering just one or two pillars is sufficient for success.",
                                                                                 "b":  "The pillars are a menu to pick from, and some are more important than others.",
                                                                                 "c":  "Partial adoption creates gaps and bottlenecks, while complete adoption of the integrated system creates a competitive advantage.",
                                                                                 "d":  "The nine pillars are too difficult for one person to learn."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s main point is that \u0027Partial adoption creates gaps; complete adoption creates advantage\u0027 because the pillars are an \u0027integrated system where each pillar amplifies the others.\u0027"
                                                             },
                                                             {
                                                                 "question":  "The chapter draws parallels to previous technology shifts. What was the common pattern in the adoption of cloud computing and Agile?",
                                                                 "options":  {
                                                                                 "a":  "Partial adopters who only used the tools superficially got the most benefit.",
                                                                                 "b":  "Early adopters who embraced the complete paradigm shift gained a significant advantage.",
                                                                                 "c":  "There was no advantage to being an early adopter.",
                                                                                 "d":  "These shifts happened slowly and had little impact."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \u0027Early adopters who embraced complete transformation thrived. Partial adopters and late adopters struggled...\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s response to the skeptical question, \u0027Can One Person Really Do This?\u0027",
                                                                 "options":  {
                                                                                 "a":  "No, it\u0027s unrealistic and requires a team of nine experts.",
                                                                                 "b":  "Yes, because AI augmentation accelerates learning, and the skills are learned progressively.",
                                                                                 "c":  "Only if you quit your job and study full-time for five years.",
                                                                                 "d":  "Yes, but only if you are already a senior developer with 20 years of experience."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter directly addresses this, explaining that \u0027AI as a coding partner accelerates learning by 3-5x\u0027 and that the book teaches the pillars \u0027progressively across 46 chapters.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the chapter suggest is the \u0027new baseline\u0027 for a professional \u0027full-stack\u0027 developer?",
                                                                 "options":  {
                                                                                 "a":  "Just frontend and backend development.",
                                                                                 "b":  "A combination of frontend, backend, cloud, DevOps, AI, quality, data, and security.",
                                                                                 "c":  "Only knowledge of one programming language.",
                                                                                 "d":  "The baseline has not changed in the last five years."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter argues that the definition has expanded: \u0027Five years ago, \u0027full-stack\u0027 meant frontend + backend. Today, it means frontend + backend + cloud + DevOps + AI + quality + data + security + collaboration.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s main message regarding the \u0027urgency\u0027 of learning the nine pillars?",
                                                                 "options":  {
                                                                                 "a":  "You should panic because it\u0027s already too late to catch up.",
                                                                                 "b":  "There is no urgency; you can wait several years before learning these skills.",
                                                                                 "c":  "The opportunity window is open now for early adopters to gain a significant advantage, so there is urgency but not a need for panic.",
                                                                                 "d":  "The urgency only applies to new developers, not experienced ones."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter is titled \u0027Urgency Without Panic\u0027 and argues that while the \u0027opportunity window is open now,\u0027 the path is a progressive journey of learning, not an impossible race."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  28,
                                           "chapter_title":  "The Claude Code Origin Story and Paradigm Shift",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the fundamental difference between the \u0027passive assistance model\u0027 of early AI tools and the \u0027agentic assistance model\u0027 of Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "Passive AI is faster, while agentic AI is slower.",
                                                                                 "b":  "Passive AI has full access to your files, while agentic AI does not.",
                                                                                 "c":  "Passive AI provides generic advice without context, while agentic AI reads your actual codebase and proposes specific changes.",
                                                                                 "d":  "There is no difference; the terms are interchangeable."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s comparison table highlights that passive AI has \u0027No access to your files\u0027 and gives \u0027Generic best practices,\u0027 whereas agentic AI \u0027Reads your actual codebase\u0027 and provides \u0027Project-specific solutions.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is terminal integration considered essential to the agentic paradigm of Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "Because it allows for a graphical user interface.",
                                                                                 "b":  "Because it prevents the AI from accessing any files.",
                                                                                 "c":  "Because it provides direct file system access, real-time execution of commands, and integration with version control.",
                                                                                 "d":  "Because most developers prefer to work in a web browser."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists several reasons, including \u0027Direct File System Access,\u0027 \u0027Real-Time Execution,\u0027 and \u0027Version Control Integration\u0027 as key benefits of terminal integration."
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a built-in safety mechanism in Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "It automatically deletes any file it modifies.",
                                                                                 "b":  "It runs commands without asking for permission.",
                                                                                 "c":  "It requires user approval before making file changes or running commands.",
                                                                                 "d":  "It operates on the entire computer system, not just the project directory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text explicitly mentions \u0027Approval Gates\u0027 as a safeguard: \u0027Claude Code asks for your permission before making file changes or running commands—nothing happens without your explicit approval.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the example of \u0027The Lost Beginner,\u0027 how did Claude Code help solve the bug faster than a chat-based AI?",
                                                                 "options":  {
                                                                                 "a":  "By providing a link to a generic tutorial on debugging.",
                                                                                 "b":  "By reading the actual script, identifying the specific line with the error, explaining it, and offering to fix it.",
                                                                                 "c":  "By rewriting the entire script from scratch.",
                                                                                 "d":  "By telling the beginner to ask a senior developer for help."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example demonstrates the power of context: \u0027Claude reads the actual file, identifies that `sum()` is being called on a string column... shows them the exact line... and offers to fix it.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main paradigm shift that Claude Code\u0027s success revealed?",
                                                                 "options":  {
                                                                                 "a":  "AI is best used as a separate tool that developers consult occasionally.",
                                                                                 "b":  "The most powerful AI assistance comes from removing friction and integrating the AI directly into the development environment.",
                                                                                 "c":  "Developers no longer need to understand their own code.",
                                                                                 "d":  "The command line is an outdated interface for development."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes, \u0027The paradigm shift is this: We\u0027re moving from \u0027AI as a separate tool you consult\u0027 to \u0027AI as an integrated part of your development environment.\u0027\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  29,
                                           "chapter_title":  "Installing and Authenticating Claude Code",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the recommended and platform-independent method for installing Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "Downloading a .exe file from a website.",
                                                                                 "b":  "Using the NPM (Node Package Manager) command `npm install -g @anthropic-ai/claude-code`.",
                                                                                 "c":  "Compiling it from source code.",
                                                                                 "d":  "Using a platform-specific app store."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly states, \u0027Recommended: NPM installation (works on all platforms)\u0027 and provides the corresponding command."
                                                             },
                                                             {
                                                                 "question":  "After successfully installing Claude Code, what command should you run to verify the installation?",
                                                                 "options":  {
                                                                                 "a":  "`claude --help`",
                                                                                 "b":  "`claude --version`",
                                                                                 "c":  "`claude start`",
                                                                                 "d":  "`claude status`"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson instructs the user to \u0027Verify Installation\u0027 by running `claude --version`."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the `CLAUDE.md` file?",
                                                                 "options":  {
                                                                                 "a":  "It is a log file that records all errors.",
                                                                                 "b":  "It is a configuration file for setting the terminal theme.",
                                                                                 "c":  "It acts as the project\u0027s \u0027memory,\u0027 containing context, standards, and instructions for Claude Code.",
                                                                                 "d":  "It is a marketing document for the project."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines it as a \u0027special file that acts as your project\u0027s \u0027memory\u0027 for Claude Code,\u0027 containing project overview, coding standards, and other context."
                                                             },
                                                             {
                                                                 "question":  "Which command initiates the authentication flow for a user with a standard `Claude.ai` account?",
                                                                 "options":  {
                                                                                 "a":  "`claude login --api-key`",
                                                                                 "b":  "`claude auth`",
                                                                                 "c":  "`claude` (run by itself)",
                                                                                 "d":  "`claude configure`"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The instructions for \u0027Authentication Method A\u0027 show that simply running `claude` will start the interactive authentication process."
                                                             },
                                                             {
                                                                 "question":  "What is the primary benefit of creating and maintaining a `CLAUDE.md` file?",
                                                                 "options":  {
                                                                                 "a":  "It makes the project folder look more organized.",
                                                                                 "b":  "It saves time by preventing the need to repeat project context in every new session with Claude.",
                                                                                 "c":  "It is required for Claude Code to run.",
                                                                                 "d":  "It allows you to use Claude Code offline."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter highlights the time savings: \u0027Time saved: 2-5 minutes per session (no more repeating project context).\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  30,
                                           "chapter_title":  "Core Commands, Custom Commands \u0026 Workflows",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In Claude Code, what is the purpose of the `@filename` syntax?",
                                                                 "options":  {
                                                                                 "a":  "To create a new file.",
                                                                                 "b":  "To delete a file.",
                                                                                 "c":  "To tell Claude to reference the content of a specific file for context.",
                                                                                 "d":  "To save the conversation to a file."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The command reference table and explanation state that `@filename` is used to \u0027Reference a specific file\u0027 and \u0027Give Claude context about a file.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the difference between the `/clear` and `/compact` commands?",
                                                                 "options":  {
                                                                                 "a":  "`/clear` deletes files, while `/compact` compresses them.",
                                                                                 "b":  "`/clear` starts a new conversation with no context, while `/compact` summarizes the current conversation to save tokens while keeping context.",
                                                                                 "c":  "`/compact` is an alias for `/clear`.",
                                                                                 "d":  "`/clear` requires admin privileges, while `/compact` does not."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains the distinction: \u0027vs. `/clear`: `/compact` keeps context (summarized), `/clear` removes all context.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is a custom slash command in Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "A built-in command that cannot be changed.",
                                                                                 "b":  "A reusable prompt template stored in the `.claude/commands/` directory for automating repetitive tasks.",
                                                                                 "c":  "A command that can only be used by the project administrator.",
                                                                                 "d":  "A command that connects to an external service."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines them as \u0027reusable prompt templates you create for tasks you do repeatedly\u0027 and specifies their storage location."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the `/permissions` command?",
                                                                 "options":  {
                                                                                 "a":  "To see how much of your usage plan you have consumed.",
                                                                                 "b":  "To set the color theme of the terminal.",
                                                                                 "c":  "To control what actions Claude Code is allowed to perform, such as reading/writing files or executing commands.",
                                                                                 "d":  "To initialize a new project."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The command\u0027s purpose is described as to \u0027Set what Claude Code can access and do,\u0027 which is a key security feature."
                                                             },
                                                             {
                                                                 "question":  "How do you use a variable in a custom slash command to pass in arguments?",
                                                                 "options":  {
                                                                                 "a":  "By using the `%ARG%` placeholder.",
                                                                                 "b":  "By using the `$ARGUMENTS` placeholder.",
                                                                                 "c":  "By using the `{{INPUT}}` placeholder.",
                                                                                 "d":  "Custom commands do not support arguments."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example for creating a custom command shows the use of `$ARGUMENTS` to insert the user\u0027s input into the prompt template."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  31,
                                           "chapter_title":  "Understanding and Using Subagents",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary problem that subagents are designed to solve?",
                                                                 "options":  {
                                                                                 "a":  "The inability of Claude Code to write code.",
                                                                                 "b":  "The \u0027context pollution\u0027 that occurs in a long, multi-task conversation in the main chat.",
                                                                                 "c":  "The lack of a graphical user interface.",
                                                                                 "d":  "The slow speed of the main AI model."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter opens by identifying the core challenge: \u0027you\u0027ll encounter a common challenge: **context pollution**.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the key difference between a subagent and the main Claude Code conversation?",
                                                                 "options":  {
                                                                                 "a":  "Subagents can only be used for debugging, while the main conversation is for everything else.",
                                                                                 "b":  "Subagents have isolated context and a custom system prompt that defines their specialized role.",
                                                                                 "c":  "Subagents are less powerful and have less access to files.",
                                                                                 "d":  "There is no difference; they are the same thing."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines a subagent as having \u0027isolated context separate from the main conversation\u0027 and a \u0027custom system prompt.\u0027"
                                                             },
                                                             {
                                                                 "question":  "When is it most appropriate to use a subagent instead of the main conversation?",
                                                                 "options":  {
                                                                                 "a":  "For exploratory work and one-off questions.",
                                                                                 "b":  "For repetitive, specialized tasks with a clear scope, like code reviews or test generation.",
                                                                                 "c":  "When you are a beginner and not yet comfortable with the main interface.",
                                                                                 "d":  "When you want to have a casual chat with the AI."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The comparison table advises using subagents for \u0027Repetitive specialized tasks with clear scope.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Where are subagents stored, allowing them to be shared with a team via version control?",
                                                                 "options":  {
                                                                                 "a":  "In a global cloud service.",
                                                                                 "b":  "In the user\u0027s home directory.",
                                                                                 "c":  "In the `.claude/agents/` directory within the project.",
                                                                                 "d":  "They are not stored as files."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027Subagent Architecture\u0027 section states that subagents are stored as files in `.claude/agents/`."
                                                             },
                                                             {
                                                                 "question":  "What is a major benefit of using a \u0027code-reviewer\u0027 subagent with a pre-defined system prompt?",
                                                                 "options":  {
                                                                                 "a":  "It provides inconsistent and unpredictable reviews.",
                                                                                 "b":  "It ensures that specific standards (like PEP 8, type hints, and security checks) are applied consistently to every review.",
                                                                                 "c":  "It can only review code written in JavaScript.",
                                                                                 "d":  "It makes the code review process much slower."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter highlights \u0027Specialization and Consistency\u0027 as a key benefit, using a code reviewer example to show how standards can be encoded and applied reliably."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  32,
                                           "chapter_title":  "Creating and Using Agent Skills",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary difference between an Agent Skill and a Subagent?",
                                                                 "options":  {
                                                                                 "a":  "Skills are invoked explicitly by the user, while subagents are discovered automatically.",
                                                                                 "b":  "Skills are discovered and suggested autonomously by Claude Code, while subagents are typically for focused, explicit execution.",
                                                                                 "c":  "Skills cannot be shared with a team, but subagents can.",
                                                                                 "d":  "Subagents are for simple tasks, while skills are for complex ones."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The comparison table clearly states that a Skill\u0027s invocation is \u0027Autonomous: Claude discovers and suggests,\u0027 while a Subagent\u0027s is \u0027Explicit or auto-delegated.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the most important part of a `SKILL.md` file for enabling autonomous discovery?",
                                                                 "options":  {
                                                                                 "a":  "The examples section.",
                                                                                 "b":  "The skill instructions checklist.",
                                                                                 "c":  "The discoverable description, which tells Claude when to suggest the skill.",
                                                                                 "d":  "The file name of the skill."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter emphasizes the \u0027Discoverable Description\u0027 as the \u0027most important\u0027 section, as it contains the trigger for Claude to suggest the skill."
                                                             },
                                                             {
                                                                 "question":  "Where should you store skills that are meant to be shared with your team and version-controlled with the project?",
                                                                 "options":  {
                                                                                 "a":  "In your personal home directory (`~/.claude/skills/`).",
                                                                                 "b":  "In the project-specific directory (`.claude/skills/`).",
                                                                                 "c":  "In a private cloud storage bucket.",
                                                                                 "d":  "Skills cannot be shared with a team."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Skill Scopes\u0027 section identifies the project directory as the \u0027Most common for team collaboration\u0027 and notes that skills there are \u0027Committed to version control.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How do Agent Skills provide a \u0027strategic competitive advantage\u0027 for a company?",
                                                                 "options":  {
                                                                                 "a":  "By making the codebase larger and more complex.",
                                                                                 "b":  "By allowing senior developers to keep their knowledge to themselves.",
                                                                                 "c":  "By encoding unique domain expertise (e.g., for compliance or security) into a reusable, automated format that scales across the team.",
                                                                                 "d":  "By replacing the need for all developers."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains that skills allow a company\u0027s \u0027unique domain knowledge\u0027 to become an \u0027automated advantage,\u0027 giving examples like a `compliance-checker` or `hipaa-privacy-auditor`."
                                                             },
                                                             {
                                                                 "question":  "What is the relationship between Skills and Subagents?",
                                                                 "options":  {
                                                                                 "a":  "They are mutually exclusive and cannot be used together.",
                                                                                 "b":  "A Skill is just another name for a Subagent.",
                                                                                 "c":  "Skills provide ambient, automatically applied expertise, while Subagents handle focused, isolated execution, and Claude can delegate to a subagent if a task matches its description.",
                                                                                 "d":  "Subagents create Skills automatically."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter clarifies their relationship: \u0027Subagents: isolated context, task ownership... Skills: ambient capabilities that refine outputs... Claude discovers skills... and can delegate to subagents...\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  33,
                                           "chapter_title":  "Connecting MCP Servers and Common Workflows",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of the Model Context Protocol (MCP)?",
                                                                 "options":  {
                                                                                 "a":  "To allow Claude Code to work offline without an internet connection.",
                                                                                 "b":  "To act as a bridge that lets Claude Code safely use external tools and data sources like websites and documentation.",
                                                                                 "c":  "To enforce a specific coding style on the user.",
                                                                                 "d":  "To manage user authentication for the Claude.ai website."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines MCP as \u0027the bridge that lets Claude Code safely use external tools and data—so it can truly collaborate with you on real tasks.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the key distinction between an MCP Server and an Agent Skill?",
                                                                 "options":  {
                                                                                 "a":  "Skills work with external systems, while MCP servers only work with local files.",
                                                                                 "b":  "MCP servers provide access to external data and tools, while skills provide expertise based on local file context.",
                                                                                 "c":  "There is no difference; they are the same.",
                                                                                 "d":  "MCP servers are less secure than skills."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The comparison table clearly shows that MCP Servers are for \u0027External data access\u0027 from \u0027External systems,\u0027 while Skills and Subagents work with \u0027Local files only.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the hands-on section, what two MCP servers are added to Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "A server for playing music and a server for ordering food.",
                                                                                 "b":  "A server for accessing GitHub and a server for accessing a database.",
                                                                                 "c":  "The Playwright MCP for browsing the web and the Context7 MCP for fetching documentation.",
                                                                                 "d":  "The lesson does not involve adding any MCP servers."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027Hands-On\u0027 section provides the exact commands to add the Playwright and Context7 MCP servers."
                                                             },
                                                             {
                                                                 "question":  "In the \u0027Shop Together\u0027 workflow example, what does the Playwright MCP enable Claude Code to do?",
                                                                 "options":  {
                                                                                 "a":  "Purchase items directly from Amazon.",
                                                                                 "b":  "Browse the Amazon website, extract details about products, and return a summary.",
                                                                                 "c":  "Access your Amazon account history.",
                                                                                 "d":  "Write a review for a product on Amazon."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example prompt asks Claude to \u0027browse Amazon. Find 3 men\u0027s casual shirts... Share links, prices, main features...\u0027 which is a web browsing and data extraction task."
                                                             },
                                                             {
                                                                 "question":  "According to the \u0027Strategic Decision Framework,\u0027 when should you use an MCP Server?",
                                                                 "options":  {
                                                                                 "a":  "When you have a repetitive task with clear rules.",
                                                                                 "b":  "When you need to access external tools, data, or websites.",
                                                                                 "c":  "For any exploratory or one-off task.",
                                                                                 "d":  "When you want expertise to be applied automatically."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The framework starts with the question, \u0027Need external tools/data (web, docs, database)?\u0027 and directs the user to \u0027Use MCP Server\u0027 if the answer is yes."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  34,
                                           "chapter_title":  "Hooks: Automating Before \u0026 After Actions",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary function of a \u0027hook\u0027 in Claude Code?",
                                                                 "options":  {
                                                                                 "a":  "To provide a graphical interface for running commands.",
                                                                                 "b":  "To be an automation trigger that runs a command before or after Claude Code executes a tool.",
                                                                                 "c":  "To connect to an external API.",
                                                                                 "d":  "To define the personality of an AI agent."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines a hook as \u0027an automation trigger that runs before or after Claude Code executes a tool.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the example `settings.json`, which hook event is used to run a command *after* a file has been edited?",
                                                                 "options":  {
                                                                                 "a":  "`SessionStart`",
                                                                                 "b":  "`PreToolUse`",
                                                                                 "c":  "`PostToolUse`",
                                                                                 "d":  "`UserPromptSubmit`"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The example JSON shows a `PostToolUse` hook with a `matcher: \u0027Edit\u0027` that runs a command after a file is edited."
                                                             },
                                                             {
                                                                 "question":  "Why is the `permissions` section in `.claude/settings.json` critical when using hooks?",
                                                                 "options":  {
                                                                                 "a":  "It allows you to set the color theme for the terminal.",
                                                                                 "b":  "It ensures that hooks, which can run shell commands automatically, only execute commands that you have explicitly allowed.",
                                                                                 "c":  "It is only used for billing and usage tracking.",
                                                                                 "d":  "It is not related to hooks; it is for managing user accounts."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter emphasizes the security aspect: \u0027Permissions ensure: Security: Only safe commands can run automatically.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the `matcher` property in a hook configuration do?",
                                                                 "options":  {
                                                                                 "a":  "It specifies the user who is allowed to run the hook.",
                                                                                 "b":  "It defines the shell command that the hook will execute.",
                                                                                 "c":  "It targets the hook to run only for specific tools, like \u0027Bash\u0027 or \u0027Edit\u0027.",
                                                                                 "d":  "It sets the time of day when the hook is allowed to run."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027How Matchers Work\u0027 section explains that `matcher` is used to \u0027target specific tools.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the difference between a \u0027Project Hook\u0027 and a \u0027Global Hook\u0027?",
                                                                 "options":  {
                                                                                 "a":  "There is no difference; they are the same.",
                                                                                 "b":  "Project hooks are more powerful than global hooks.",
                                                                                 "c":  "Project hooks apply only to the current project, while global hooks apply to all projects on the machine.",
                                                                                 "d":  "Global hooks are stored in the project directory, and project hooks are stored in the home directory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter distinguishes them by their scope: \u0027Project Hooks... Applies to: Only this project\u0027 versus \u0027Global Hooks... Applies to: ALL projects on your machine.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  35,
                                           "chapter_title":  "Plugins: Composing Commands, Agents, Skills \u0026 Hooks",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of a Claude Code \u0027plugin\u0027?",
                                                                 "options":  {
                                                                                 "a":  "To change the visual theme of the terminal.",
                                                                                 "b":  "To package commands, agents, skills, and hooks into a single, reusable, and shareable workflow.",
                                                                                 "c":  "To provide access to a single, isolated command.",
                                                                                 "d":  "To connect to a single external API."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines a plugin as \u0027a composable package that bundles commands, agents, skills, and hooks into a single reusable workflow.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How do plugins differ from individual skills or subagents?",
                                                                 "options":  {
                                                                                 "a":  "Plugins are less powerful than skills or subagents.",
                                                                                 "b":  "Plugins are for one-off tasks, while skills and subagents are for complex workflows.",
                                                                                 "c":  "Plugins compose all other extension types (commands, agents, skills, hooks) to orchestrate a complete, multi-step workflow.",
                                                                                 "d":  "Plugins can only be created by Anthropic, not by users."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter emphasizes composition: \u0027Every plugin packages four things together... How they work together: Hook triggers → Command invokes → Agent executes → Skills apply.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the built-in `code-review` plugin do?",
                                                                 "options":  {
                                                                                 "a":  "It allows you to write a review for the Claude Code tool itself.",
                                                                                 "b":  "It automatically reviews pull requests by running multiple specialized agents in parallel and reports high-confidence issues.",
                                                                                 "c":  "It only checks for spelling and grammar in code comments.",
                                                                                 "d":  "It deletes any code that it determines to be low quality."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The description of the `code-review` plugin states that it \u0027launches 4 review agents in parallel\u0027 and \u0027Only issues with ≥80 confidence are reported.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the `feature-dev` plugin?",
                                                                 "options":  {
                                                                                 "a":  "To list all available features in Claude Code.",
                                                                                 "b":  "To guide a developer through a structured, 7-phase workflow for building a new feature from start to finish.",
                                                                                 "c":  "To automatically generate random feature ideas.",
                                                                                 "d":  "To remove a feature from the codebase."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes its function: \u0027Guides you through a structured 7-phase workflow for building features, automatically delegating to specialized agents at each phase.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the \u0027Real Workflow: PR Review Automation\u0027 example, what is the main benefit of using plugins?",
                                                                 "options":  {
                                                                                 "a":  "It makes the process more manual and requires more steps.",
                                                                                 "b":  "It significantly reduces the time and manual effort required for a thorough PR review by automating the process.",
                                                                                 "c":  "It increases the number of bugs introduced into the codebase.",
                                                                                 "d":  "It requires the developer to have deep expertise in all areas of the review."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example contrasts the 45+ minute manual workflow with the 15-minute automated workflow enabled by plugins, highlighting the time savings."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  36,
                                           "chapter_title":  "Why Gemini CLI Matters?",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary difference between Claude Code and Gemini CLI regarding their source code?",
                                                                 "options":  {
                                                                                 "a":  "Claude Code is open source, while Gemini CLI is proprietary.",
                                                                                 "b":  "Gemini CLI is fully open source (Apache 2.0), while Claude Code is proprietary.",
                                                                                 "c":  "Both are proprietary.",
                                                                                 "d":  "Both are open source."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \u0027Claude Code is proprietary software... Gemini CLI is fully open source under the Apache 2.0 license.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What key advantage does Gemini CLI\u0027s free tier offer to students and learners?",
                                                                 "options":  {
                                                                                 "a":  "It provides access to a more powerful AI model than the paid version.",
                                                                                 "b":  "It removes the economic barrier to learning and experimentation by offering a generous number of daily requests at no cost.",
                                                                                 "c":  "It includes personalized tutoring from Google engineers.",
                                                                                 "d":  "The free tier has a larger context window than the paid tier."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text highlights that the free tier means learning can cost \u0027$0,\u0027 which \u0027remov[es] economic barriers to learning and experimentation.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Gemini CLI is built on the Model Context Protocol (MCP). What is the main benefit of this?",
                                                                 "options":  {
                                                                                 "a":  "It locks users into using only Google\u0027s proprietary tools.",
                                                                                 "b":  "It allows developers to create their own \u0027MCP servers\u0027 to integrate custom tools, databases, and services with the AI.",
                                                                                 "c":  "It is a less secure method of connecting to external tools.",
                                                                                 "d":  "It limits the number of tools that can be integrated."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that MCP \u0027allows any tool, database, or service to connect to any AI model through a standard protocol,\u0027 enabling developers to \u0027create MCP servers that expose their tools and data.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In which scenario would Claude Code be a better choice than Gemini CLI?",
                                                                 "options":  {
                                                                                 "a":  "For a student learning to code on a tight budget.",
                                                                                 "b":  "For an open-source project where contributors want to modify the tool.",
                                                                                 "c":  "For an enterprise in a regulated industry that requires vendor support and compliance certifications.",
                                                                                 "d":  "For a project with a very large codebase that exceeds 200K tokens."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists \u0027Enterprise Features\u0027 like \u0027enterprise-grade support, SLAs, and compliance certifications\u0027 as a strength of Claude Code."
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027Open Source Ecosystem Effect\u0027 demonstrated by the creation of Qwen Code?",
                                                                 "options":  {
                                                                                 "a":  "Open source tools are always of lower quality than proprietary ones.",
                                                                                 "b":  "Open source tools evolve beyond their original creator\u0027s vision as the community forks and adapts them for new purposes.",
                                                                                 "c":  "Open source tools are difficult to install and configure.",
                                                                                 "d":  "Proprietary companies always try to shut down open source forks of their tools."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter uses the Qwen Code fork as an example of the principle that \u0027open source tools evolve beyond their creators\u0027 vision.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  37,
                                           "chapter_title":  "Installation, Authentication \u0026 First Steps",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the single command used to install Gemini CLI globally using NPM?",
                                                                 "options":  {
                                                                                 "a":  "`npm get @google/gemini-cli`",
                                                                                 "b":  "`npm install -g @google/gemini-cli`",
                                                                                 "c":  "`npm start @google/gemini-cli`",
                                                                                 "d":  "`npm build @google/gemini-cli`"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson provides the exact command: `npm install -g @google/gemini-cli`."
                                                             },
                                                             {
                                                                 "question":  "When you run `gemini` for the first time, what is the recommended authentication method for beginners to access the free tier?",
                                                                 "options":  {
                                                                                 "a":  "Using a Gemini API Key.",
                                                                                 "b":  "Using a Vertex AI service account.",
                                                                                 "c":  "Using the \u0027Google login\u0027 option, which authenticates through your browser.",
                                                                                 "d":  "The tool does not require authentication."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter guides the user to \u0027Select \u0027Google login\u0027 for the free tier. This is the beginner-friendly option.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the `/help` slash command in Gemini CLI?",
                                                                 "options":  {
                                                                                 "a":  "To show session statistics and token usage.",
                                                                                 "b":  "To clear the terminal screen.",
                                                                                 "c":  "To show all available slash commands and shortcuts.",
                                                                                 "d":  "To exit the Gemini CLI session."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The command reference table clearly states that `/help` is used to \u0027Show all available commands and shortcuts.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the `@` syntax (e.g., `@./src/app.js`) allow you to do in a prompt?",
                                                                 "options":  {
                                                                                 "a":  "Execute a shell command.",
                                                                                 "b":  "Save the conversation to a file.",
                                                                                 "c":  "Tell Gemini to read the content of a specific file or directory and include it in the conversation context.",
                                                                                 "d":  "Add a comment to your prompt that the AI will ignore."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains, \u0027When you type `@` followed by a file path, you\u0027re telling Gemini: \u0027Read this file and include it in our conversation.\u0027\u0027"
                                                             },
                                                             {
                                                                 "question":  "What does the `!` syntax (e.g., `!git status`) allow you to do?",
                                                                 "options":  {
                                                                                 "a":  "Reference a file.",
                                                                                 "b":  "Start a new conversation.",
                                                                                 "c":  "Execute a shell command from within Gemini CLI, with safety confirmations.",
                                                                                 "d":  "Ignore the rest of the line."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter introduces this syntax by stating, \u0027When you type `!` followed by a command, you\u0027re telling Gemini: \u0027Execute this shell command in my terminal.\u0027\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  38,
                                           "chapter_title":  "Core Commands \u0026 Slash Commands",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary function of the `/chat save \u003ctag\u003e` and `/chat resume \u003ctag\u003e` commands?",
                                                                 "options":  {
                                                                                 "a":  "To manage the visual theme of the terminal.",
                                                                                 "b":  "To save the current conversation state to a checkpoint and restore it later, allowing work to persist across sessions.",
                                                                                 "c":  "To add permanent facts about a project to the AI\u0027s memory.",
                                                                                 "d":  "To export the conversation to a PDF file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes these as \u0027Conversation Checkpointing\u0027 commands used to \u0027Save conversations and resume them later without re-explaining context.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the difference between the `/compress` and `/clear` commands?",
                                                                 "options":  {
                                                                                 "a":  "`/compress` deletes the conversation, while `/clear` only hides it.",
                                                                                 "b":  "`/compress` intelligently summarizes the conversation to free up tokens while keeping key context, whereas `/clear` only clears the terminal display.",
                                                                                 "c":  "`/clear` saves the conversation, while `/compress` does not.",
                                                                                 "d":  "They are aliases for the same command."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that `/compress` is for reducing context size while `/clear` is for clearing the screen display without affecting the context."
                                                             },
                                                             {
                                                                 "question":  "Which command would you use to see a list of all external tools and integrations Gemini CLI is connected to?",
                                                                 "options":  {
                                                                                 "a":  "`/tools`",
                                                                                 "b":  "`/settings`",
                                                                                 "c":  "`/mcp`",
                                                                                 "d":  "`/help`"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The reference table shows that `/mcp` is used to \u0027Show MCP servers \u0026 tools.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the `/directory add \u003cpath\u003e` command?",
                                                                 "options":  {
                                                                                 "a":  "To create a new directory on the file system.",
                                                                                 "b":  "To delete a directory.",
                                                                                 "c":  "To include additional directories, like a shared library, in Gemini\u0027s context discovery for a monorepo.",
                                                                                 "d":  "To list the files within a directory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains this is useful \u0027If you work with monorepos or shared libraries, tell Gemini where to find them.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What happens if you close Gemini CLI without using `/chat save`?",
                                                                 "options":  {
                                                                                 "a":  "The conversation is automatically saved.",
                                                                                 "b":  "You are prompted to save the conversation before exiting.",
                                                                                 "c":  "The conversation history for that session is lost.",
                                                                                 "d":  "The conversation is saved to a temporary file that can be recovered later."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027Common Questions\u0027 section explicitly warns, \u0027If I close Gemini without using `/chat save`? A: Your conversation is lost.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  39,
                                           "chapter_title":  "GEMINI.md Context Files: Automatic Project Understanding",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of a `GEMINI.md` file?",
                                                                 "options":  {
                                                                                 "a":  "It is the main source code file for a Gemini CLI project.",
                                                                                 "b":  "It is a log file that records all commands run during a session.",
                                                                                 "c":  "It is a special markdown file that automatically provides project-specific context, conventions, and architecture to Gemini CLI.",
                                                                                 "d":  "It is a file for writing user documentation."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines it as \u0027a special markdown file that tells Gemini about your project automatically.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the difference between a global `GEMINI.md` (`~/.gemini/GEMINI.md`) and a project `GEMINI.md` (`./GEMINI.md`)?",
                                                                 "options":  {
                                                                                 "a":  "The global file is for project-specific context, and the project file is for personal preferences.",
                                                                                 "b":  "The global file applies to all projects and contains personal preferences, while the project file contains context specific to that one project.",
                                                                                 "c":  "There is no difference; Gemini CLI only reads one of them.",
                                                                                 "d":  "The global file is for public information, and the project file is for private secrets."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter clearly distinguishes the two: \u0027Global GEMINI.md... Your personal context that applies to ALL projects\u0027 versus \u0027Project GEMINI.md... Context specific to THIS ONE PROJECT.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Which slash command would you use to see the combined content of all `GEMINI.md` files currently loaded in your session?",
                                                                 "options":  {
                                                                                 "a":  "`/init`",
                                                                                 "b":  "`/memory show`",
                                                                                 "c":  "`/chat list`",
                                                                                 "d":  "`/settings`"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that `/memory show` is used to \u0027See Loaded Context\u0027 from all active `GEMINI.md` files."
                                                             },
                                                             {
                                                                 "question":  "If you make a change to a `GEMINI.md` file while Gemini CLI is running, what command should you use to apply the changes immediately without restarting?",
                                                                 "options":  {
                                                                                 "a":  "`/restart`",
                                                                                 "b":  "`/memory add`",
                                                                                 "c":  "`/memory refresh`",
                                                                                 "d":  "The changes are applied automatically."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text states, \u0027If you update GEMINI.md, reload it without restarting Gemini CLI\u0027 using the `/memory refresh` command."
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a \u0027DO\u0027 best practice for writing a `GEMINI.md` file?",
                                                                 "options":  {
                                                                                 "a":  "Include secrets and API keys for convenience.",
                                                                                 "b":  "Copy your entire README file into it.",
                                                                                 "c":  "Write it once and never update it.",
                                                                                 "d":  "Document key architectural decisions and their trade-offs."
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The \u0027Best Practices\u0027 section lists \u0027Document decisions AND their trade-offs\u0027 as a \u0027DO,\u0027 while the others are listed as \u0027DON\u0027T\u0027s."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  40,
                                           "chapter_title":  "Saving \u0026 Resuming Conversations",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the key difference between `GEMINI.md` and a saved conversation from `/chat save`?",
                                                                 "options":  {
                                                                                 "a":  "`GEMINI.md` saves the conversation history, while `/chat save` saves project architecture.",
                                                                                 "b":  "`GEMINI.md` provides persistent project context (architecture, standards), while `/chat save` saves the history of a specific work session (what was discussed).",
                                                                                 "c":  "They are the same thing and store the same information.",
                                                                                 "d":  "`GEMINI.md` is for temporary notes, while `/chat save` is for permanent storage."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter clarifies this distinction: \u0027GEMINI.md = What Gemini should know about your PROJECT\u0027 and \u0027Saved conversations = What you\u0027ve DISCUSSED with Gemini.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is a recommended naming pattern for saved conversations?",
                                                                 "options":  {
                                                                                 "a":  "Generic names like `save1`, `save2`, `test`.",
                                                                                 "b":  "A pattern like `[feature]-[status]` or `[date]-[task]`, such as `auth-jwt-complete`.",
                                                                                 "c":  "Using random numbers as names.",
                                                                                 "d":  "The name does not matter."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Naming Your Saved Conversations\u0027 section explicitly recommends the `[feature]-[status]` pattern and gives `auth-jwt-complete` as a good example."
                                                             },
                                                             {
                                                                 "question":  "How can you share a conversation with a teammate?",
                                                                 "options":  {
                                                                                 "a":  "By using the `/chat resume` command with their username.",
                                                                                 "b":  "Saved conversations cannot be shared.",
                                                                                 "c":  "By using the `/chat share file.md` command to export the conversation to a markdown file.",
                                                                                 "d":  "By copying the contents of the terminal and pasting it into an email."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter describes the `/chat share` command for this purpose: \u0027Share what you\u0027ve discussed with others: `/chat share project-design.md`.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027Experimentation With Safety\u0027 pattern described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Trying a risky approach and hoping for the best.",
                                                                                 "b":  "Using `/chat save` to create a checkpoint of a stable state before trying a risky refactoring, allowing you to easily revert.",
                                                                                 "c":  "Asking Gemini if an approach is safe before trying it.",
                                                                                 "d":  "Only experimenting on a separate, isolated computer."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter outlines this pattern: save the current state, try the experiment, and if it fails, clear and resume the saved state."
                                                             },
                                                             {
                                                                 "question":  "Where are saved conversations stored?",
                                                                 "options":  {
                                                                                 "a":  "In the cloud, synced to your Google account.",
                                                                                 "b":  "Locally on your machine.",
                                                                                 "c":  "In the project\u0027s `GEMINI.md` file.",
                                                                                 "d":  "They are not stored; they only exist for the current session."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Common Questions\u0027 section answers this: \u0027How much storage do saved conversations use? A: Conversations are stored locally on your machine.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  41,
                                           "chapter_title":  "When Your AI Needs More: MCP and Extensions",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary business problem that the Model Context Protocol (MCP) solves?",
                                                                 "options":  {
                                                                                 "a":  "It makes the AI\u0027s responses more creative.",
                                                                                 "b":  "It allows the AI to perform tasks that require accessing external systems, like actively browsing multiple websites or querying live APIs.",
                                                                                 "c":  "It reduces the cost of using the AI.",
                                                                                 "d":  "It allows the AI to work completely offline."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that without MCP, the AI is limited to local files, but with MCP, it can access the \u0027External World,\u0027 enabling tasks like multi-competitor research."
                                                             },
                                                             {
                                                                 "question":  "What is the function of the Playwright MCP server?",
                                                                 "options":  {
                                                                                 "a":  "It gives the AI access to up-to-date technical documentation.",
                                                                                 "b":  "It allows the AI to browse websites like a human, including clicking links and navigating pages.",
                                                                                 "c":  "It connects the AI to your GitHub repository.",
                                                                                 "d":  "It allows the AI to query a database."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines the Playwright server\u0027s role: \u0027Lets your AI browse websites like a human—clicking links, navigating multiple pages, filling forms, extracting data.\u0027"
                                                             },
                                                             {
                                                                 "question":  "How does a Gemini CLI Extension differ from a single MCP server?",
                                                                 "options":  {
                                                                                 "a":  "An extension is just another name for an MCP server.",
                                                                                 "b":  "An extension is a pre-packaged bundle that can include multiple MCP servers, custom commands, and context files.",
                                                                                 "c":  "MCP servers are more powerful than extensions.",
                                                                                 "d":  "Extensions are less secure than MCP servers."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter makes this distinction: \u0027MCP servers = Individual capabilities you add... Extensions = Pre-packaged bundles that can include: MCP servers... Custom commands... Persistent context files...\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the \u0027Understanding API Changes\u0027 workflow, what does the Context7 MCP server enable Gemini to do?",
                                                                 "options":  {
                                                                                 "a":  "Browse the Stripe website for marketing information.",
                                                                                 "b":  "Query its indexed, up-to-date documentation for the Stripe API to summarize recent changes.",
                                                                                 "c":  "Automatically update your code to use the new Stripe API.",
                                                                                 "d":  "Access your company\u0027s private financial data in Stripe."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example shows Gemini using Context7 to \u0027fetch the latest Stripe API documentation\u0027 and summarize what changed."
                                                             },
                                                             {
                                                                 "question":  "What is the first and most important step in the security evaluation framework for installing a new extension?",
                                                                 "options":  {
                                                                                 "a":  "Checking the number of GitHub stars.",
                                                                                 "b":  "Reviewing the source code to see what it does and what permissions it needs.",
                                                                                 "c":  "Trusting the author without verification if they have a popular blog.",
                                                                                 "d":  "Installing it immediately to see if it works."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The framework lists \u0027Code Review\u0027 as the first step, asking \u0027Is source available on GitHub?\u0027 and \u0027Can you review the commands?\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  42,
                                           "chapter_title":  "Custom Commands \u0026 Extensions: Extending Gemini CLI",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary benefit of creating custom slash commands in Gemini CLI?",
                                                                 "options":  {
                                                                                 "a":  "To make the terminal interface look more colorful.",
                                                                                 "b":  "To automate repetitive, multi-step workflows into a single, reusable command.",
                                                                                 "c":  "To share your API keys securely with your team.",
                                                                                 "d":  "To replace all the built-in slash commands."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter introduces custom commands by showing how a manual, multi-step workflow can be reduced to a single command, stating they \u0027automate repeated patterns.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What file format is used to define custom commands for Gemini CLI?",
                                                                 "options":  {
                                                                                 "a":  "JSON",
                                                                                 "b":  "YAML",
                                                                                 "c":  "XML",
                                                                                 "d":  "TOML"
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The chapter explicitly states, \u0027Gemini CLI uses **TOML** (simple configuration format) for custom commands.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Where should you place a custom command file if you want it to be available only for a specific project and shared with your team via Git?",
                                                                 "options":  {
                                                                                 "a":  "In your global user directory (`~/.gemini/commands/`).",
                                                                                 "b":  "In the project-specific directory (`./gemini/commands/`).",
                                                                                 "c":  "In the root directory of your hard drive.",
                                                                                 "d":  "In a cloud storage service like Google Drive."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter distinguishes between User Commands and Project Commands, noting that project commands are for \u0027Project-specific workflows\u0027 and are \u0027committed to Git.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In a TOML command definition, what does the `shell` property do?",
                                                                 "options":  {
                                                                                 "a":  "It defines the main prompt to be sent to the AI model.",
                                                                                 "b":  "It specifies a shell command to be executed, whose output can then be used in the prompt.",
                                                                                 "c":  "It sets the color of the command\u0027s output in the shell.",
                                                                                 "d":  "It provides a description of the command for the `/help` menu."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The example for a command with shell integration shows `shell = \u0027!find src -name \u0027*.ts\u0027 -type f\u0027` and then uses `{{shell_result}}` in the prompt."
                                                             },
                                                             {
                                                                 "question":  "What is a Gemini CLI Extension?",
                                                                 "options":  {
                                                                                 "a":  "A single custom command.",
                                                                                 "b":  "A way to change the theme of the CLI.",
                                                                                 "c":  "A shareable bundle that can package custom commands, MCP server configurations, and `GEMINI.md` context snippets.",
                                                                                 "d":  "A hardware add-on for your computer."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines an extension as a package that includes \u0027Custom commands (TOML files), MCP server configurations, GEMINI.md context snippets, and Settings overrides.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  43,
                                           "chapter_title":  "Introducing Your AI Companion\u0027s Workspace",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of the `pwd` command in a terminal?",
                                                                 "options":  {
                                                                                 "a":  "To list all files in the current directory.",
                                                                                 "b":  "To print the working directory, showing the current folder path.",
                                                                                 "c":  "To create a new directory.",
                                                                                 "d":  "To delete a file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that `pwd` stands for \u0027print working directory\u0027 and its function is to \u0027show youâ€”or your AIâ€”the current folder path.\u0027"
                                                             },
                                                             {
                                                                 "question":  "When using the `ls -la` command, how can you distinguish a directory from a file in the output?",
                                                                 "options":  {
                                                                                 "a":  "Directories are always listed first.",
                                                                                 "b":  "Files have a `.` in their name, and directories do not.",
                                                                                 "c":  "Lines starting with `d` are directories, and lines starting with `-` are files.",
                                                                                 "d":  "Directories are highlighted in a different color."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The lesson explicitly points this out: \u0027Items starting with `d`... are directories... Items starting with `-`... are files.\u0027"
                                                             },
                                                             {
                                                                 "question":  "Why is it important to know your AI companion\u0027s location (current working directory) before it performs any operation?",
                                                                 "options":  {
                                                                                 "a":  "To make sure the AI is not using too much memory.",
                                                                                 "b":  "To ensure that operations like deleting or modifying files happen in the correct place, preventing accidental changes.",
                                                                                 "c":  "To check if the AI has an internet connection.",
                                                                                 "d":  "It is not important; the AI knows what it is doing."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter emphasizes the \u0027Supervision Pattern,\u0027 explaining that knowing the location helps prevent mistakes, such as deleting the wrong folder."
                                                             },
                                                             {
                                                                 "question":  "What is the key insight from the side-by-side comparison of you and your AI running commands like `pwd` and `ls`?",
                                                                 "options":  {
                                                                                 "a":  "The AI uses secret, more powerful commands that humans cannot run.",
                                                                                 "b":  "The AI\u0027s terminal is completely different from a human\u0027s terminal.",
                                                                                 "c":  "The AI runs the exact same commands with the same logic, making its actions verifiable and understandable.",
                                                                                 "d":  "Humans are much faster at running terminal commands than AI."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027Key insight\u0027 in the chapter is: \u0027Your AI isn\u0027t using magic. It\u0027s running the same commands you do. You can read and verify its output because you already understand what `pwd` and `ls` mean.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the \u0027supervision pattern\u0027 for safe collaboration with an AI?",
                                                                 "options":  {
                                                                                 "a":  "Trust the AI completely and let it execute commands without confirmation.",
                                                                                 "b":  "Ask the AI to perform a task and then check the results afterward.",
                                                                                 "c":  "Ask â†’ Show Location â†’ Show What\u0027s There â†’ Verify â†’ Execute.",
                                                                                 "d":  "Execute the command yourself and then ask the AI if you did it correctly."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines this pattern as: \u0027Ask â†’ Show Location â†’ Show What\u0027s There â†’ Verify â†’ Execute.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  44,
                                           "chapter_title":  "The Safety-First Dialogue Pattern",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the five steps of the Safety-First Dialogue Pattern, in the correct order?",
                                                                 "options":  {
                                                                                 "a":  "Ask, Execute, Verify, Explain, Understand.",
                                                                                 "b":  "Ask, Explain, Understand, Verify, Execute.",
                                                                                 "c":  "Explain, Ask, Verify, Understand, Execute.",
                                                                                 "d":  "Execute, Ask, Verify, Understand, Explain."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly lists the 5 steps in order: \u0027Step 1: Ask,\u0027 \u0027Step 2: Explain,\u0027 \u0027Step 3: Understand,\u0027 \u0027Step 4: Verify,\u0027 and \u0027Step 5: Execute.\u0027"
                                                             },
                                                             {
                                                                 "question":  "In the 5-step pattern, what is the purpose of the \u0027Verify\u0027 step?",
                                                                 "options":  {
                                                                                 "a":  "To confirm that you understand the AI\u0027s plan.",
                                                                                 "b":  "To ask clarifying questions about the plan, commands, and potential risks *before* the AI executes anything.",
                                                                                 "c":  "To check if the command was successful *after* it has been executed.",
                                                                                 "d":  "To tell the AI what you want it to do."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Verify\u0027 step is described as the point where \u0027You ask clarifying questions BEFORE your AI executes anything,\u0027 such as \u0027Will this affect any other files?\u0027 or \u0027Is there a way to undo this?\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main risk of skipping the \u0027Explain,\u0027 \u0027Understand,\u0027 and \u0027Verify\u0027 steps?",
                                                                 "options":  {
                                                                                 "a":  "The AI will refuse to perform the task.",
                                                                                 "b":  "The process will take much longer.",
                                                                                 "c":  "The AI might perform a destructive or incorrect action that you did not intend, without giving you a chance to stop it.",
                                                                                 "d":  "The AI will ask for more money."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The example of deleting the `old-projects` folder shows that skipping these steps can lead to the AI performing a dangerous action (`rm -rf`) without confirmation, potentially causing data loss."
                                                             },
                                                             {
                                                                 "question":  "In the real dialogue example where the user wants to organize Python files, what important limitation does the AI discover and communicate?",
                                                                 "options":  {
                                                                                 "a":  "It does not know what a Python file is.",
                                                                                 "b":  "It does not have the ability to directly create directories or move files on the user\u0027s system.",
                                                                                 "c":  "It cannot find any Python files in the project.",
                                                                                 "d":  "It refuses to organize the files because it is not a safe operation."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The dialogue shows the agent attempting to run `mkdir` and then stating, \u0027My apologies, I misspoke. It appears I don\u0027t have the ability to directly create directories or move files.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the key principle of the \u0027Ask\u0027 step in the safety pattern?",
                                                                 "options":  {
                                                                                 "a":  "You should provide the exact bash command you want the AI to run.",
                                                                                 "b":  "You should describe WHAT you want to accomplish in plain language, not HOW to do it.",
                                                                                 "c":  "You should ask the AI if it is capable of the task before explaining what it is.",
                                                                                 "d":  "You should always ask for the riskiest operation first."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises for Step 1 (Ask): \u0027Describe WHAT you want, not which commands to use. Let your AI decide the approach.\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  45,
                                           "chapter_title":  "Understanding File Navigation Through Dialogue",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the difference between an absolute path and a relative path?",
                                                                 "options":  {
                                                                                 "a":  "Absolute paths are shorter than relative paths.",
                                                                                 "b":  "An absolute path is a complete address from the root, while a relative path is a direction from\n         your current location.",
                                                                                 "c":  "Only AI can use absolute paths; humans can only use relative paths.",
                                                                                 "d":  "Absolute paths are for files, and relative paths are for directories."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter uses the analogy of a street address, explaining that an absolute path is a\n         \"complete address\" while a relative path is \"directions from where you are now.\""
                                                             },
                                                             {
                                                                 "question":  "What does the cd .. command do?",
                                                                 "options":  {
                                                                                 "a":  "It navigates to the user\u0027s home directory.",
                                                                                 "b":  "It deletes the current directory.",
                                                                                 "c":  "It navigates up one level to the parent folder.",
                                                                                 "d":  "It lists the contents of the current directory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text explains that .. is a \"relative path special symbol meaning \u0027parent folder\u0027\n         (one level up from where you are).\""
                                                             },
                                                             {
                                                                 "question":  "Why is understanding paths crucial for safety when working with an AI?",
                                                                 "options":  {
                                                                                 "a":  "It allows you to move files faster.",
                                                                                 "b":  "It ensures you can prevent the AI from making mistakes, like deleting a folder in the wrong\n         location, by verifying its position first.",
                                                                                 "c":  "It is the only way to give the AI commands.",
                                                                                 "d":  "It helps the AI use less memory."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter provides a safety scenario: \"By understanding paths—knowing exactly where\n         your AI is—you prevent mistakes.\""
                                                             },
                                                             {
                                                                 "question":  "If you are in the directory /Users/yourname/projects and you run the command cd my-app, what\n      is the new working directory?",
                                                                 "options":  {
                                                                                 "a":  "/Users/yourname/my-app",
                                                                                 "b":  "/my-app",
                                                                                 "c":  "/Users/yourname/projects/my-app",
                                                                                 "d":  "The command will fail because it\u0027s not an absolute path."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "my-app is a relative path, so the command changes the directory relative to the current\n         location, /Users/yourname/projects."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the pwd command in the context of file navigation?",
                                                                 "options":  {
                                                                                 "a":  "To change the password for the current user.",
                                                                                 "b":  "To list the files in the parent directory.",
                                                                                 "c":  "To confirm your current location (working directory) after a cd command.",
                                                                                 "d":  "To create a new directory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter repeatedly uses pwd after cd to \"confirm your location\" and verify that the\n         navigation was successful."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  46,
                                           "chapter_title":  "Understanding File Operations Safely",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "According to the chapter, which file operation is the safest and why?",
                                                                 "options":  {
                                                                                 "a":  "rm (delete), because it cleans up your file system.",
                                                                                 "b":  "mv (move), because it organizes your files.",
                                                                                 "c":  "cp (copy), because the original file remains untouched.",
                                                                                 "d":  "All operations have the same level of risk."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explicitly states that cp (copy) is the \"safest file operation because the\n         original stays in place.\""
                                                             },
                                                             {
                                                                 "question":  "What does the -r flag do when used with the cp command (e.g., cp -r src/ src-backup/)?",
                                                                 "options":  {
                                                                                 "a":  "It renames the file instead of copying it.",
                                                                                 "b":  "It makes the copy operation \"recursive,\" meaning it copies the entire folder and all its\n         contents.",
                                                                                 "c":  "It removes the original file after copying.",
                                                                                 "d":  "It makes the copy operation run faster."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains, \"The -r flag means \u0027recursive\u0027—copy everything inside the folder and\n         all its subfolders.\""
                                                             },
                                                             {
                                                                 "question":  "What is the most critical step in the safety pattern before performing any file operation?",
                                                                 "options":  {
                                                                                 "a":  "Closing your eyes and hoping for the best.",
                                                                                 "b":  "Asking the AI to explain the command after it has run.",
                                                                                 "c":  "Verifying the location with pwd and listing the affected files with ls before execution.",
                                                                                 "d":  "Immediately running the command to see what happens."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter emphasizes the supervision pattern, which involves verifying the location\n         and files before any action is taken to prevent mistakes."
                                                             },
                                                             {
                                                                 "question":  "If you ask your AI to copy a file named report.docx to report_final.docx, how would you verify\n      the operation was successful?",
                                                                 "options":  {
                                                                                 "a":  "By asking the AI if it worked.",
                                                                                 "b":  "By running the ls command and checking that both report.docx and report_final.docx exist.",
                                                                                 "c":  "By trying to delete the original file.",
                                                                                 "d":  "By restarting your computer."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The examples for both user and AI show using ls after the cp command to verify that both\n         the original and the new copy are present."
                                                             },
                                                             {
                                                                 "question":  "Why is the rm (delete) command considered a high-risk operation?",
                                                                 "options":  {
                                                                                 "a":  "It is difficult to type correctly.",
                                                                                 "b":  "It can only be used by system administrators.",
                                                                                 "c":  "It is often difficult or impossible to undo, meaning the file is permanently gone.",
                                                                                 "d":  "It uses a lot of system memory."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The risk table in the chapter lists rm as \"High\" risk with \"Difficult to undo\" as the\n         recovery option."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  47,
                                           "chapter_title":  "Understanding Configuration and Secrets Safely",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary danger of \"hardcoding\" secrets like API keys or passwords directly into\n      your source code?",
                                                                 "options":  {
                                                                                 "a":  "It makes the code harder to read.",
                                                                                 "b":  "If the code is shared or committed to a repository like GitHub, the secrets are exposed to anyone\n         with access.",
                                                                                 "c":  "It can cause the program to run more slowly.",
                                                                                 "d":  "It is not dangerous; it is a common best practice."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter warns, \"If this code reaches GitHub, anyone with access to your repository\n         gets your secrets.\""
                                                             },
                                                             {
                                                                 "question":  "What is the difference between using the export command and a .env file to set environment\n      variables?",
                                                                 "options":  {
                                                                                 "a":  "export is permanent, while .env is temporary.",
                                                                                 "b":  "export sets a variable only for the current terminal session (temporary), while a .env file\n         stores variables persistently.",
                                                                                 "c":  "Only .env files can be used for storing secrets.",
                                                                                 "d":  "There is no functional difference."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that export is temporary and the variable is \"gone\" when the\n         terminal closes, whereas .env files \"persist across terminal restarts.\""
                                                             },
                                                             {
                                                                 "question":  "In a Python script, what is the correct way to access an environment variable named API_KEY?",
                                                                 "options":  {
                                                                                 "a":  "api_key = \"sk-abc123def456\"",
                                                                                 "b":  "api_key = os.getenv(\u0027API_KEY\u0027)",
                                                                                 "c":  "api_key = read_file(\u0027.env\u0027)",
                                                                                 "d":  "api_key = API_KEY"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Good code\" example shows the safe way to access the variable: import os; api_key =\n         os.getenv(\u0027API_KEY\u0027)."
                                                             },
                                                             {
                                                                 "question":  "How can you prevent your .env file, which contains secrets, from being accidentally committed\n      to a Git repository?",
                                                                 "options":  {
                                                                                 "a":  "By naming the file secrets.txt instead of .env.",
                                                                                 "b":  "By adding the filename .env to your .gitignore file.",
                                                                                 "c":  "By encrypting the .env file before committing it.",
                                                                                 "d":  "Git automatically ignores all .env files."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Try With AI\" section mentions that a key safety step is to \"Add .env to .gitignore\n         to prevent accidental commits.\""
                                                             },
                                                             {
                                                                 "question":  "If you set a variable with export MY_VAR=\"test\", how do you display its value in the terminal?",
                                                                 "options":  {
                                                                                 "a":  "echo MY_VAR",
                                                                                 "b":  "print(MY_VAR)",
                                                                                 "c":  "cat MY_VAR",
                                                                                 "d":  "echo $MY_VAR"
                                                                             },
                                                                 "correct_answer":  "d",
                                                                 "explanation":  "The examples in the chapter consistently use echo $VARIABLE_NAME to retrieve and display\n         the value of an environment variable."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  48,
                                           "chapter_title":  "Understanding Dependencies and Packages",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary role of a package manager like pip or npm?",
                                                                 "options":  {
                                                                                 "a":  "To edit and format source code.",
                                                                                 "b":  "To act as a \"supplier\" that finds, downloads, and installs software packages and their\n         dependencies automatically.",
                                                                                 "c":  "To run the code and display the output.",
                                                                                 "d":  "To back up your project files."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter uses the analogy of a supplier network and explains that package managers\n         find a requested package \"along with all its dependencies.\""
                                                             },
                                                             {
                                                                 "question":  "If you run pip install requests and five packages are installed, what does this demonstrate?",
                                                                 "options":  {
                                                                                 "a":  "That pip made a mistake and installed extra packages.",
                                                                                 "b":  "The concept of \"dependency resolution,\" where pip automatically installed the four other packages\n         that requests needs to function.",
                                                                                 "c":  "That you should have installed the other four packages manually first.",
                                                                                 "d":  "That the requests package is broken."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The dialogue in the chapter explains this exact scenario: \"The requests library depends\n         on those other four packages. pip installed them automatically. This is called dependency\n         resolution.\""
                                                             },
                                                             {
                                                                 "question":  "Which package manager is the standard for JavaScript/Node.js projects?",
                                                                 "options":  {
                                                                                 "a":  "pip",
                                                                                 "b":  "npm",
                                                                                 "c":  "brew",
                                                                                 "d":  "apt"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly states that npm \"is the standard for JavaScript/Node projects.\""
                                                             },
                                                             {
                                                                 "question":  "What are \"transitive dependencies\"?",
                                                                 "options":  {
                                                                                 "a":  "Packages that are no longer needed and can be deleted.",
                                                                                 "b":  "The dependencies of your project\u0027s dependencies.",
                                                                                 "c":  "A type of package that only works on a temporary basis.",
                                                                                 "d":  "Packages that are installed globally on your system."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines this concept by showing a dependency chain: \"urllib3 needs: (its\n         own dependencies)... The package manager traces this entire tree and installs everything needed.\n         This is called transitive dependencies.\""
                                                             },
                                                             {
                                                                 "question":  "After installing a package with pip, which command can you use to see its details, including\n      its version and the other packages it requires?",
                                                                 "options":  {
                                                                                 "a":  "pip list",
                                                                                 "b":  "pip show \u003cpackage-name\u003e",
                                                                                 "c":  "pip install \u003cpackage-name\u003e",
                                                                                 "d":  "pip verify \u003cpackage-name\u003e"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Verify Packages Are Installed Correctly\" section shows that pip show requests is\n         used to display the name, version, location, and requirements of the package."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  49,
                                           "chapter_title":  "Understanding Pipes and Complex Commands",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the function of the pipe | character in a bash command?",
                                                                 "options":  {
                                                                                 "a":  "It separates two commands that will be run at the same time.",
                                                                                 "b":  "It sends the output of the command on its left to be used as the input for the command on its\n         right.",
                                                                                 "c":  "It is a logical \"OR\" operator.",
                                                                                 "d":  "It saves the output of a command to a file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \"Output from one command becomes input to the next. You build\n         complex operations by connecting simple commands together.\""
                                                             },
                                                             {
                                                                 "question":  "In the command ls -la | grep \".py\", what is happening?",
                                                                 "options":  {
                                                                                 "a":  "The ls command is searching for files containing \".py\".",
                                                                                 "b":  "The grep command is listing all files, and ls is filtering them.",
                                                                                 "c":  "The ls command lists all files, and its output is sent to grep, which filters for lines\n         containing \".py\".",
                                                                                 "d":  "The command will fail because ls and grep cannot be used together."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter breaks this down: \"ls -la produces a list. The pipe | sends that list to\n         grep. grep filters it to show only lines containing .py.\""
                                                             },
                                                             {
                                                                 "question":  "What does the wc -l command do?",
                                                                 "options":  {
                                                                                 "a":  "It counts the number of words in its input.",
                                                                                 "b":  "It counts the number of characters in its input.",
                                                                                 "c":  "It counts the number of lines in its input.",
                                                                                 "d":  "It converts its input to lowercase."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains that wc -l stands for \"word count, line count\" and is used to\n         count the number of lines."
                                                             },
                                                             {
                                                                 "question":  "If you have a pipeline cat application.log | grep \"ERROR\", what is the expected output?",
                                                                 "options":  {
                                                                                 "a":  "The total number of errors in the log file.",
                                                                                 "b":  "The entire content of the log file.",
                                                                                 "c":  "Only the lines from the log file that contain the word \"ERROR\".",
                                                                                 "d":  "The first line of the log file."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains this exact pipeline: cat outputs the whole file, and grep \"ERROR\"\n         filters it, so the final output is just the error lines themselves."
                                                             },
                                                             {
                                                                 "question":  "What is the key benefit of using pipes to build complex commands?",
                                                                 "options":  {
                                                                                 "a":  "It makes the commands harder to read and understand.",
                                                                                 "b":  "It allows you to combine simple, single-purpose commands into a powerful, multi-step workflow.",
                                                                                 "c":  "It is the only way to run more than one command at a time.",
                                                                                 "d":  "It automatically saves the output of each step to a separate file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter highlights the power of pipes: \"You build complex operations from simple\n         commands... Pipes chain them together.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  50,
                                           "chapter_title":  "Real Project Setup and Troubleshooting—The Capstone",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In the capstone project, what is the first step the AI agent takes to set up the new project?",
                                                                 "options":  {
                                                                                 "a":  "It immediately writes the main Python script.",
                                                                                 "b":  "It installs all the necessary dependencies.",
                                                                                 "c":  "It creates the project\u0027s directory structure (src, tests, data).",
                                                                                 "d":  "It writes the README.md file."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The dialogue shows the first action is mkdir weather-project followed by creating the\n         subdirectories, establishing the project structure before adding files."
                                                             },
                                                             {
                                                                 "question":  "When the script is first run, it produces a requests.exceptions.ConnectionError. What does the\n      AI agent identify as the real cause of this error?",
                                                                 "options":  {
                                                                                 "a":  "The computer is not connected to the internet.",
                                                                                 "b":  "The requests package was not installed correctly.",
                                                                                 "c":  "The script is using a test API key that the weather service does not recognize as valid.",
                                                                                 "d":  "The URL for the API is misspelled."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The agent analyzes the error and concludes, \"The real issue is: we\u0027re using a test API\n         key that the service doesn\u0027t recognize, so the request fails.\""
                                                             },
                                                             {
                                                                 "question":  "How does the AI agent improve the script to handle errors more gracefully?",
                                                                 "options":  {
                                                                                 "a":  "It deletes the code that is causing the error.",
                                                                                 "b":  "It adds try...except blocks to catch specific errors (like ConnectionError or Timeout) and print\n         clear, helpful messages.",
                                                                                 "c":  "It tells the user to ignore all errors.",
                                                                                 "d":  "It rewrites the entire script in a different programming language."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The revised code block shows the addition of try...except blocks to catch different\n         types of exceptions and provide user-friendly error messages."
                                                             },
                                                             {
                                                                 "question":  "What is the chapter\u0027s main message about encountering errors during development?",
                                                                 "options":  {
                                                                                 "a":  "Errors are a sign of failure and mean you should give up.",
                                                                                 "b":  "Errors should be ignored.",
                                                                                 "c":  "Errors are a normal and productive part of the development process, providing valuable feedback\n         on what to fix next.",
                                                                                 "d":  "Only junior developers encounter errors."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Mindset: Errors Are Learning\" section states, \"In professional development,\n         encountering errors is not failure. It\u0027s progress... Each error message is your AI telling you what\n         to fix next.\""
                                                             },
                                                             {
                                                                 "question":  "What is the recommended troubleshooting workflow when an error occurs?",
                                                                 "options":  {
                                                                                 "a":  "Immediately try random fixes until something works.",
                                                                                 "b":  "Delete the code and start over from scratch.",
                                                                                 "c":  "Hit an error, read the message, ask the AI what it means, fix the single issue, and then run the\n         code again to find the next problem.",
                                                                                 "d":  "Ask a senior developer to fix it for you."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter summarizes the workflow as: \"1. Hit error → 2. Read error message → 3. Ask\n         \u0027What does this mean?\u0027 → 4. Fix one issue → 5. Run again, hit next issue → 6. Repeat until success.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  51,
                                           "chapter_title":  "Why Git Matters with AI Tools",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary function of Git, as described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "To automatically write code for you.",
                                                                                 "b":  "To act as a time machine for your code, allowing you to save snapshots (\"commits\") and revert to\n         them.",
                                                                                 "c":  "To test your code for bugs.",
                                                                                 "d":  "To deploy your code to a server."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \"Git is like an undo button that never forgets... You save a\n         snapshot (called a \u0027commit\u0027)... You go back to any old snapshot instantly.\""
                                                             },
                                                             {
                                                                 "question":  "Why does working with AI make using Git essential?",
                                                                 "options":  {
                                                                                 "a":  "Because AI tools are slow and require a lot of waiting.",
                                                                                 "b":  "Because AI can make many changes quickly across multiple files, and Git provides a safety net to\n         review and undo those changes if they cause problems.",
                                                                                 "c":  "Because AI tools only work on projects that are managed with Git.",
                                                                                 "d":  "Because AI tools are always perfect and never make mistakes."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text highlights that with AI, \"Changes happen in seconds... AI can modify many\n         files at once... You need a way to undo quickly. Git gives you that safety.\""
                                                             },
                                                             {
                                                                 "question":  "What is a \"commit\" in Git?",
                                                                 "options":  {
                                                                                 "a":  "A bug in the code.",
                                                                                 "b":  "A message sent to another developer.",
                                                                                 "c":  "A snapshot of your code at a specific moment in time, like a video game save point.",
                                                                                 "d":  "A command to delete a file."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines a commit as \"a snapshot of your code at one moment. Like a video\n         game save point. You can always return to it.\""
                                                             },
                                                             {
                                                                 "question":  "What is the main purpose of using a \"branch\" in Git?",
                                                                 "options":  {
                                                                                 "a":  "To permanently delete your main code.",
                                                                                 "b":  "To create a copy of your code where you can safely test changes without affecting the main\n         version.",
                                                                                 "c":  "To share your code with non-technical users.",
                                                                                 "d":  "To automatically fix all bugs in your code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that on a branch, you can \"Test AI\u0027s changes... If good: Keep\n         them. If bad: Delete the branch. Your main code stays untouched.\""
                                                             },
                                                             {
                                                                 "question":  "What is the relationship between Git and GitHub?",
                                                                 "options":  {
                                                                                 "a":  "They are the same thing.",
                                                                                 "b":  "Git is for writing code, and GitHub is for testing code.",
                                                                                 "c":  "Git is the tool for tracking changes on your local computer, while GitHub is a cloud service for\n         storing and backing up your Git repositories online.",
                                                                                 "d":  "Git is a paid service, while GitHub is free."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter distinguishes them: \"Git is a time machine for your code... GitHub stores\n         your code online... If your computer breaks, your code is safe.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  52,
                                           "chapter_title":  "Essential Setup",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the three essential setup steps before you can start using Git and GitHub?",
                                                                 "options":  {
                                                                                 "a":  "Install a code editor, buy a new computer, and create a social media account.",
                                                                                 "b":  "Install Git, create a GitHub account, and configure Git with your identity.",
                                                                                 "c":  "Learn Python, learn JavaScript, and learn HTML.",
                                                                                 "d":  "Install a web browser, create an email account, and set up a server."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter introduction lists these three exact steps: \"1. Git installed... 2. GitHub\n         account... 3. Git configured...\""
                                                             },
                                                             {
                                                                 "question":  "After installing Git, what command should you run in the terminal to verify that it was\n      installed correctly?",
                                                                 "options":  {
                                                                                 "a":  "git start",
                                                                                 "b":  "git --version",
                                                                                 "c":  "git status",
                                                                                 "d":  "git install --check"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson instructs the user to \"Verify installation\" by running git --version and\n         checking for a version number in the output."
                                                             },
                                                             {
                                                                 "question":  "When configuring your Git identity, why is it important to use the same email address as\n  your GitHub account?",
                                                                 "options":  {
                                                                                 "a":  "It is a legal requirement.",
                                                                                 "b":  "So that your commits on your local machine are linked to your GitHub profile.",
                                                                                 "c":  "It is the only way to push code to GitHub.",
                                                                                 "d":  "It allows GitHub to send you marketing emails."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises to \"Use the same email as GitHub so commits appear on your\n         profile.\""
                                                             },
                                                             {
                                                                 "question":  "Which command does Gemini CLI run to configure your global user name in Git?",
                                                                 "options":  {
                                                                                 "a":  "git user.name = \"Your Name\"",
                                                                                 "b":  "git config --global user.name \"Your Name\"",
                                                                                 "c":  "git set --user \"Your Name\"",
                                                                                 "d":  "git config user \"Your Name\""
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter shows the exact command Gemini runs: git config --global user.name \"Your\n         Name\"."
                                                             },
                                                             {
                                                                 "question":  "What is the recommended approach for handling tasks like verifying an installation or\n      troubleshooting an error?",
                                                                 "options":  {
                                                                                 "a":  "Handle them directly by searching the web for answers.",
                                                                                 "b":  "Use an AI assistant like Gemini CLI to run diagnostic commands and get guided help.",
                                                                                 "c":  "Ignore all errors and hope they go away.",
                                                                                 "d":  "Reinstall the software from scratch every time."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"What You Learned\" section contrasts \"direct methods\" for simple tasks with using\n         \"AI (Gemini CLI)\" for verification and troubleshooting."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  53,
                                           "chapter_title":  "The Daily Workflow",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In the AIDD approach to the daily Git workflow, what is the developer\u0027s primary role?",
                                                                 "options":  {
                                                                                 "a":  "To memorize all the Git commands and their flags.",
                                                                                 "b":  "To ask the AI assistant (like Gemini CLI) what they want to accomplish in plain language.",
                                                                                 "c":  "To write complex scripts to automate Git.",
                                                                                 "d":  "To avoid using Git and save files manually."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts the traditional way (memorizing commands) with the AIDD way: \"Ask\n         Gemini CLI what you want... You say: \u0027Save my work\u0027 - Gemini runs: The right Git command.\""
                                                             },
                                                             {
                                                                 "question":  "What does the git init command do?",
                                                                 "options":  {
                                                                                 "a":  "It uploads your project to GitHub.",
                                                                                 "b":  "It creates a new file called init.txt.",
                                                                                 "c":  "It starts tracking a project folder with Git by creating a hidden .git directory.",
                                                                                 "d":  "It installs Git on your computer."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Task 1: Start Tracking\" section explains that git init \"creates a .git directory\n         to track your project history.\""
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of \"staging\" a file with git add?",
                                                                 "options":  {
                                                                                 "a":  "It permanently saves the file to the cloud.",
                                                                                 "b":  "It deletes the file from your project.",
                                                                                 "c":  "It marks the file to be included in your next commit, like putting an item in a shopping cart\n         before checkout.",
                                                                                 "d":  "It runs a performance test on the file."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter uses the analogy of a shopping cart: \"Staged = marked for your next commit.\n         Like putting items in a shopping cart before checkout.\""
                                                             },
                                                             {
                                                                 "question":  "What is the difference between git commit and git push?",
                                                                 "options":  {
                                                                                 "a":  "There is no difference; they do the same thing.",
                                                                                 "b":  "git commit saves a snapshot of your changes locally on your computer, while git push uploads\n         those saved commits to a remote repository like GitHub.",
                                                                                 "c":  "git push saves changes locally, and git commit uploads them to the cloud.",
                                                                                 "d":  "git commit is for saving new files, and git push is for saving modified files."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes commit as saving a snapshot locally and push as the \"Backup to\n         Cloud\" step that uploads commits."
                                                             },
                                                             {
                                                                 "question":  "What is a key characteristic of a good commit message?",
                                                                 "options":  {
                                                                                 "a":  "It is vague and short, like \"stuff\" or \"update\".",
                                                                                 "b":  "It is a clear and descriptive summary of the changes made, like \"Add calculator module\".",
                                                                                 "c":  "It is a long and detailed essay about the code.",
                                                                                 "d":  "The commit message is not important."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter provides examples of good and bad messages, highlighting that good messages\n         are clear and describe the action taken."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  54,
                                           "chapter_title":  "Safety Net: Undoing Changes",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "Before undoing any changes, what is the first and most important step?",
                                                                 "options":  {
                                                                                 "a":  "To delete the files permanently.",
                                                                                 "b":  "To view what exactly has changed using a command like git diff.",
                                                                                 "c":  "To close your code editor and restart your computer.",
                                                                                 "d":  "To ask the AI to guess what changed."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter introduces \"Method 1: View What Changed\" first, stating, \"See what changed\n         before deciding to keep or undo. Never undo blindly.\""
                                                             },
                                                             {
                                                                 "question":  "If you have made changes to a file but have not committed them yet, what command would you ask\n      your AI to run to discard those changes?",
                                                                 "options":  {
                                                                                 "a":  "git revert HEAD",
                                                                                 "b":  "git reset --hard HEAD~1",
                                                                                 "c":  "git restore .",
                                                                                 "d":  "git commit -a"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The section \"Discard Uncommitted Changes\" shows that asking the AI to \"Discard all my\n         changes\" results in the git restore . command."
                                                             },
                                                             {
                                                                 "question":  "You have pushed a bad commit to a shared repository on GitHub. What is the safest way to undo\n      it?",
                                                                 "options":  {
                                                                                 "a":  "Permanently delete the commit using git reset --hard.",
                                                                                 "b":  "Create a new \"revert commit\" using git revert HEAD, which makes a new commit that undoes the\n         previous one.",
                                                                                 "c":  "Delete the repository on GitHub and start over.",
                                                                                 "d":  "Ask your teammates to delete their local copies of the repository."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter identifies git revert as the \"Safest for teams\" because it doesn\u0027t rewrite\n         shared history, it just adds a new commit that reverses the bad one."
                                                             },
                                                             {
                                                                 "question":  "When is it appropriate to use the dangerous git reset --hard command?",
                                                                 "options":  {
                                                                                 "a":  "For any minor mistake.",
                                                                                 "b":  "When you want to keep your changes but undo the commit.",
                                                                                 "c":  "Only when you have accidentally committed a password or secret, and you must change the secret\n         immediately after.",
                                                                                 "d":  "It is never appropriate to use this command."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter gives a strong warning about this command, stating to \"Use only when: You\n         committed a password/secret by accident. Then change the password immediately.\""
                                                             },
                                                             {
                                                                 "question":  "What does the command git reset --soft HEAD~1 do?",
                                                                 "options":  {
                                                                                 "a":  "It permanently deletes the last commit and all its changes.",
                                                                                 "b":  "It undoes the last commit but keeps the code changes in your working directory (as unstaged\n         changes).",
                                                                                 "c":  "It creates a new commit that reverses the last one.",
                                                                                 "d":  "It resets your entire project to its initial state."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes this as the safest option to undo a commit, explaining, \"The\n         commit is removed, but your code remains (unstaged).\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  55,
                                           "chapter_title":  "Branches for Experimentation",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of creating a branch in Git?",
                                                                 "options":  {
                                                                                 "a":  "To create a permanent, unchangeable version of your code.",
                                                                                 "b":  "To delete your main code and start over.",
                                                                                 "c":  "To create a safe, isolated copy of your code where you can experiment with changes without\n         affecting the main version.",
                                                                                 "d":  "To share your code with people who do not use Git."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines a branch as \"a copy of your code where you test things safely,\"\n         ensuring your \"main code stays safe.\""
                                                             },
                                                             {
                                                                 "question":  "What is the correct workflow for using a branch to test a new feature?",
                                                                 "options":  {
                                                                                 "a":  "Make changes on main → create a branch → merge the branch.",
                                                                                 "b":  "Create a branch → make changes → test the changes → if they work, merge the branch into main.",
                                                                                 "c":  "Create a branch → merge it immediately → then make changes on main.",
                                                                                 "d":  "Make changes on main → test them → if they fail, create a branch."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter outlines the workflow as: Create Branch → Make Changes → Test → Merge or\n         Discard."
                                                             },
                                                             {
                                                                 "question":  "If you are on a feature branch called test-refactor and want to see the differences between it\n      and the main branch, what command would you ask your AI to run?",
                                                                 "options":  {
                                                                                 "a":  "git diff test-refactor",
                                                                                 "b":  "git diff main",
                                                                                 "c":  "git status",
                                                                                 "d":  "git log"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter shows that to \"See what changed,\" you ask the AI to run git diff main to\n         compare your current branch to the main branch."
                                                             },
                                                             {
                                                                 "question":  "After a feature branch has been successfully tested and merged into main, what is the\n      recommended cleanup action?",
                                                                 "options":  {
                                                                                 "a":  "Keep the branch forever as a backup.",
                                                                                 "b":  "Rename the branch to archive.",
                                                                                 "c":  "Delete the branch both on GitHub and locally.",
                                                                                 "d":  "Merge the main branch back into the feature branch."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"After Merging: Clean Up\" section describes deleting the branch on GitHub and then\n         running commands to delete the local branch."
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, when should you use a branch?",
                                                                 "options":  {
                                                                                 "a":  "For every single change, no matter how small.",
                                                                                 "b":  "Only when working on a team.",
                                                                                 "c":  "When making major or experimental changes that you are not sure will work, providing a safety\n         net.",
                                                                                 "d":  "You should never use branches; all work should be done on the main branch."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"When to Use Branches\" section advises using a branch when \"AI wants to make major\n         changes,\" you\u0027re \"Trying something experimental,\" or you\u0027re \"Not sure if changes will work.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  56,
                                           "chapter_title":  "GitHub Integration",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of connecting your local Git repository to GitHub?",
                                                                 "options":  {
                                                                                 "a":  "To make your code run faster.",
                                                                                 "b":  "To create a cloud backup of your code, allowing you to access it from anywhere and keep it safe.",
                                                                                 "c":  "To automatically fix all bugs in your code.",
                                                                                 "d":  "To prevent anyone else from seeing your code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that GitHub is \"cloud backup for your code\" and lists the benefits\n         as \"Safe backup,\" \"Work from anywhere,\" and \"Collaboration.\""
                                                             },
                                                             {
                                                                 "question":  "What command does Gemini CLI run to connect a local repository to a remote GitHub repository\n      for the first time?",
                                                                 "options":  {
                                                                                 "a":  "git connect \u003cURL\u003e",
                                                                                 "b":  "git remote add origin \u003cURL\u003e",
                                                                                 "c":  "git github setup \u003cURL\u003e",
                                                                                 "d":  "git push \u003cURL\u003e"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Step 2: Connect Local Code to GitHub\" section shows this exact command: git remote\n         add origin https://github.com/username/my-project.git."
                                                             },
                                                             {
                                                                 "question":  "What is the recommended and most secure method for authenticating with GitHub from the command\n      line?",
                                                                 "options":  {
                                                                                 "a":  "Using your GitHub password directly.",
                                                                                 "b":  "Using a Personal Access Token (PAT) with the \"repo\" scope.",
                                                                                 "c":  "Disabling authentication entirely.",
                                                                                 "d":  "Using your email address as the password."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter provides a step-by-step guide for creating a Personal Access Token and\n         explicitly states to use the token, not your password, when prompted."
                                                             },
                                                             {
                                                                 "question":  "What is the difference between git push and git pull?",
                                                                 "options":  {
                                                                                 "a":  "push downloads code from GitHub, and pull uploads code to GitHub.",
                                                                                 "b":  "They are the same command.",
                                                                                 "c":  "push uploads your local commits to GitHub, and pull downloads changes from GitHub to your local\n         machine.",
                                                                                 "d":  "push is for new files, and pull is for modified files."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines push as \"Upload your commits to GitHub\" and pull as \"Get the latest\n         code from GitHub to your local computer.\""
                                                             },
                                                             {
                                                                 "question":  "If you start working on a second computer, what is the first Git command you should run to get\n      a copy of your repository from GitHub?",
                                                                 "options":  {
                                                                                 "a":  "git init",
                                                                                 "b":  "git pull",
                                                                                 "c":  "git clone \u003cURL\u003e",
                                                                                 "d":  "git push"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Working Across Multiple Computers\" workflow shows that on the second computer, the\n         first step is to \"Clone the repository\" using git clone."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  57,
                                           "chapter_title":  "Pull Requests and Code Review",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of a Pull Request (PR)?",
                                                                 "options":  {
                                                                                 "a":  "To immediately merge code into the main branch without any checks.",
                                                                                 "b":  "To serve as a final safety check and formal request to review and merge changes from a branch\n         into the main branch.",
                                                                                 "c":  "To delete a branch from the repository.",
                                                                                 "d":  "To ask a question to the project maintainers."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines a Pull Request as saying, \"I\u0027m done with these changes. Please\n         review before merging to main,\" and calls it a \"final safety check.\""
                                                             },
                                                             {
                                                                 "question":  "What are the three essential questions a good PR description should answer?",
                                                                 "options":  {
                                                                                 "a":  "Who wrote the code? When was it written? How long did it take?",
                                                                                 "b":  "What is your favorite color? What is your quest? What is the air-speed velocity of an unladen\n         swallow?",
                                                                                 "c":  "What changed? What did AI do? How to test?",
                                                                                 "d":  "Why is this change necessary? Who approved it? What is the budget?"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The section on writing a PR description explicitly lists these three questions: \"1.\n         What changed?... 2. What did AI do?... 3. How to test?\""
                                                             },
                                                             {
                                                                 "question":  "If a reviewer leaves feedback on your PR asking for changes, what is the correct way to update\n      the PR?",
                                                                 "options":  {
                                                                                 "a":  "Close the PR and create a new one with the fixes.",
                                                                                 "b":  "Make the changes locally on the same branch, commit them, and then push the branch to GitHub\n         again.",
                                                                                 "c":  "Argue with the reviewer until they approve the PR.",
                                                                                 "d":  "Merge the PR anyway and promise to fix it later."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Handling Feedback\" section details this process: make changes locally, commit, and\n         then git push. It clarifies that the \"PR automatically updates.\""
                                                             },
                                                             {
                                                                 "question":  "In a GitHub diff view, what do the green and red colored lines signify?",
                                                                 "options":  {
                                                                                 "a":  "Green lines are good code, and red lines are bad code.",
                                                                                 "b":  "Green lines are comments, and red lines are executable code.",
                                                                                 "c":  "Green lines indicate code that was added, and red lines indicate code that was removed.",
                                                                                 "d":  "Green lines are from your commits, and red lines are from other people\u0027s commits."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Review the Diff\" section explains the color coding: \"Green lines (+): Code added\"\n         and \"Red lines (-): Code removed.\""
                                                             },
                                                             {
                                                                 "question":  "What is the recommended action after a PR has been successfully merged into the main branch?",
                                                                 "options":  {
                                                                                 "a":  "Keep the feature branch forever as a backup.",
                                                                                 "b":  "Delete the feature branch on both GitHub and your local machine to keep the repository clean.",
                                                                                 "c":  "Merge the main branch back into the feature branch.",
                                                                                 "d":  "Create another PR to revert the merge."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"After Merging: Clean Up\" section advises to \"Delete the branch on GitHub\" and then\n         provides the commands to delete the local branch."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  58,
                                           "chapter_title":  "IDE Setup and Integration",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is an IDE (Integrated Development Environment)?",
                                                                 "options":  {
                                                                                 "a":  "A simple text editor with no extra features.",
                                                                                 "b":  "A code editor that integrates other tools like Git, a file explorer, and AI assistants all in one\n         place.",
                                                                                 "c":  "A command-line tool for running Git commands.",
                                                                                 "d":  "A website for hosting code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines an IDE as \"typing + Git + file explorer + AI + everything in one\n         place.\""
                                                             },
                                                             {
                                                                 "question":  "In VS Code, how can you access the \"Source Control\" panel to see Git-related changes?",
                                                                 "options":  {
                                                                                 "a":  "By clicking the File menu and selecting \"Save As\".",
                                                                                 "b":  "By clicking the branch icon (3rd icon) in the left sidebar or using a keyboard shortcut like\n         Ctrl+Shift+G.",
                                                                                 "c":  "By opening the built-in terminal.",
                                                                                 "d":  "By searching for \"Git\" in the settings."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter provides two ways to find the panel: \"Click the branch icon (3rd icon) in\n         left sidebar\" or \"Press Ctrl+Shift+G.\""
                                                             },
                                                             {
                                                                 "question":  "What is the GUI equivalent of running the git add filename command in the VS Code Source\n      Control panel?",
                                                                 "options":  {
                                                                                 "a":  "Clicking the ✓ checkmark button.",
                                                                                 "b":  "Clicking the + icon that appears when you hover over a file in the \"Changes\" list.",
                                                                                 "c":  "Clicking the \"...\" menu and selecting \"Push\".",
                                                                                 "d":  "Typing the filename into the commit message box."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Stage and Commit Using GUI\" section explicitly states that clicking the \"+\" icon\n         is \"Equivalent to: git add filename.\""
                                                             },
                                                             {
                                                                 "question":  "What is the main purpose of installing an AI coding assistant extension like GitHub Copilot in\n      your IDE?",
                                                                 "options":  {
                                                                                 "a":  "To automatically format your code.",
                                                                                 "b":  "To get AI code suggestions and completions as you type.",
                                                                                 "c":  "To change the color theme of your IDE.",
                                                                                 "d":  "To manage your GitHub account settings."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes the benefit of Copilot as getting \"AI code suggestions as you\n         type.\""
                                                             },
                                                             {
                                                                 "question":  "If you click on a modified file in the Source Control panel, what does the \"diff view\" show\n      you?",
                                                                 "options":  {
                                                                                 "a":  "The file\u0027s complete history since the project started.",
                                                                                 "b":  "A side-by-side or inline comparison showing which lines were added (green) and which were removed\n         (red).",
                                                                                 "c":  "The file\u0027s properties, such as its size and creation date.",
                                                                                 "d":  "A list of all the developers who have ever edited the file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains the diff view: \"Red: Lines removed, Green:\n         Lines added.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  59,
                                           "chapter_title":  "Capstone: Build Your First Project",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In the capstone project, what is the developer\u0027s primary role?",
                                                                 "options":  {
                                                                                 "a":  "To write all the Python code for the calculator from memory.",
                                                                                 "b":  "To manage the Git workflow (committing, branching, merging) and make decisions while the AI\n         generates the code.",
                                                                                 "c":  "To design the user interface for the calculator.",
                                                                                 "d":  "To market the finished calculator application."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The introduction states, \"AI writes code. Your job: Manage Git, make decisions, review\n         AI\u0027s work.\""
                                                             },
                                                             {
                                                                 "question":  "What is the first step in the professional workflow outlined for the project?",
                                                                 "options":  {
                                                                                 "a":  "Write the main Python code.",
                                                                                 "b":  "Push the empty project to GitHub.",
                                                                                 "c":  "Initialize the Git repository and make the first commit with a README file.",
                                                                                 "d":  "Create a feature branch for testing."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "\"Step 1: Initialize Project\" details creating the folder, running git init, creating a\n         README.md, and making the initial commit."
                                                             },
                                                             {
                                                                 "question":  "Why is a new branch (add-tests) created before generating the tests for the calculator?",
                                                                 "options":  {
                                                                                 "a":  "Because the main branch does not support test files.",
                                                                                 "b":  "To safely add and run the new tests in an isolated environment without affecting the working code\n         on the main branch.",
                                                                                 "c":  "To make the project history more complicated.",
                                                                                 "d":  "Because Git requires a new branch for every new file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "This step demonstrates the \"Branches for Experimentation\" concept from a previous\n         lesson, where changes are tested safely on a branch before being merged."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of creating a Pull Request (PR) in Step 6 of the workflow?",
                                                                 "options":  {
                                                                                 "a":  "To delete the repository from GitHub.",
                                                                                 "b":  "To provide a final, professional review of the changes (adding docstrings) before they are merged\n         into the main branch.",
                                                                                 "c":  "It is a required step to get paid for the project.",
                                                                                 "d":  "To ask the AI for permission to merge the code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The PR step is described as a \"professional workflow\" and a \"final safety check before\n         merging,\" where changes are documented and reviewed."
                                                             },
                                                             {
                                                                 "question":  "After a Pull Request is merged on GitHub, what are the two cleanup steps that should be\n      performed?",
                                                                 "options":  {
                                                                                 "a":  "Delete the entire repository and start over.",
                                                                                 "b":  "Revert the merge immediately.",
                                                                                 "c":  "Delete the remote branch on GitHub and then delete the local branch on your computer.",
                                                                                 "d":  "Create a new branch with the same name."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"After Merging: Clean Up\" section in the previous lesson (and implied in the\n         capstone) shows the process of deleting the branch on GitHub and then locally with git branch -d."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  60,
                                           "chapter_title":  "Why Markdown Matters for AI Communication",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary reason markdown is used for writing specifications for AI agents?",
                                                                 "options":  {
                                                                                 "a":  "It is a complex programming language that only experts can use.",
                                                                                 "b":  "It provides a clear, structured format that removes ambiguity for both humans and AI.",
                                                                                 "c":  "It is a proprietary format owned by Google.",
                                                                                 "d":  "It does not support code blocks or lists."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts an unstructured email with a structured markdown spec, stating,\n         \"The structure removes ambiguity. You\u0027re not teaching the AI to guess — you\u0027re giving it clear\n         labels.\""
                                                             },
                                                             {
                                                                 "question":  "In the three-layer model of AI-Driven Development (AIDD), which layer does markdown belong to?",
                                                                 "options":  {
                                                                                 "a":  "Layer 1: The Intent Layer, where humans write what they want.",
                                                                                 "b":  "Layer 2: The Reasoning Layer, where the AI plans the implementation.",
                                                                                 "c":  "Layer 3: The Implementation Layer, where the AI generates code.",
                                                                                 "d":  "Markdown is not part of the AIDD model."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter explicitly places markdown in \"Layer 1: Intent Layer (YOU write here),\"\n         explaining it\u0027s how you describe what you want."
                                                             },
                                                             {
                                                                 "question":  "What is the key difference between \"structured text\" (like markdown) and \"unstructured text\"\n      (like a plain paragraph)?",
                                                                 "options":  {
                                                                                 "a":  "Unstructured text is easier for an AI to understand.",
                                                                                 "b":  "Structured text uses clear labels (like headings and lists) that help an AI parse the information\n         and understand its meaning and hierarchy.",
                                                                                 "c":  "There is no difference; AI treats them the same.",
                                                                                 "d":  "Structured text can only be written by developers."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter compares the two versions of the weather app description, showing that the\n         structured version allows the AI to know \"Exactly 4 features\" and \"The sequence of steps.\""
                                                             },
                                                             {
                                                                 "question":  "Which of the following is NOT a real-world scenario where markdown is commonly used, according\n      to the chapter?",
                                                                 "options":  {
                                                                                 "a":  "GitHub README files.",
                                                                                 "b":  "Writing the source code for operating systems.",
                                                                                 "c":  "Specifications for AI agents.",
                                                                                 "d":  "Documentation sites."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists README files, AI specifications, documentation sites, and AI chat\n         prompts as common uses. Operating system source code is written in languages like C or C++, not\n         markdown."
                                                             },
                                                             {
                                                                 "question":  "What is the most important skill to practice when using AI to get feedback on your markdown\n      specifications?",
                                                                 "options":  {
                                                                                 "a":  "Accepting the AI\u0027s first answer without question.",
                                                                                 "b":  "Verifying the AI\u0027s answers by checking against what you know, asking for reasoning, and testing\n         its claims.",
                                                                                 "c":  "Only using one AI tool to avoid conflicting information.",
                                                                                 "d":  "Assuming the AI is always correct."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"How to Verify AI Responses\" section emphasizes that \"AI agents make mistakes\" and\n         outlines a 4-step verification framework as a critical skill."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  61,
                                           "chapter_title":  "Headings - Creating Document Hierarchy",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In markdown, how do you create a Level 1 (main title) and a Level 2 (main section) heading?",
                                                                 "options":  {
                                                                                 "a":  "* Heading 1 and ** Heading 2",
                                                                                 "b":  "\u003ch1\u003eHeading 1\u003c/h1\u003e and \u003ch2\u003eHeading 2\u003c/h2\u003e",
                                                                                 "c":  "# Heading 1 and ## Heading 2",
                                                                                 "d":  "1. Heading 1 and 2. Heading 2"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter states, \"Markdown uses the hash symbol (#) to create headings. More hash\n         symbols = smaller heading,\" and provides # Level 1 Heading and ## Level 2 Heading as examples."
                                                             },
                                                             {
                                                                 "question":  "What is the rule of \"proper hierarchy\" for headings?",
                                                                 "options":  {
                                                                                 "a":  "You can use any heading level in any order.",
                                                                                 "b":  "You must not skip levels; for example, a Level 3 heading (###) must be under a Level 2 heading\n         (##).",
                                                                                 "c":  "You should only use Level 1 headings for everything.",
                                                                                 "d":  "You should always start with the smallest heading and work your way up."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter uses a folder analogy to explain that you must not skip levels, showing a\n         \"Wrong Hierarchy Example\" where a ### appears without a ## parent."
                                                             },
                                                             {
                                                                 "question":  "How many Level 1 headings (#) should a well-structured document have?",
                                                                 "options":  {
                                                                                 "a":  "As many as you want.",
                                                                                 "b":  "Exactly one, for the main document title.",
                                                                                 "c":  "None; you should always start with Level 2.",
                                                                                 "d":  "At least two."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises, \"Level 1 (#): The document title (use once at the top)\" and lists\n         \"Using Multiple Level 1 Headings\" as a common mistake."
                                                             },
                                                             {
                                                                 "question":  "What is the most common mistake beginners make when writing heading syntax?",
                                                                 "options":  {
                                                                                 "a":  "Using too many headings.",
                                                                                 "b":  "Forgetting to put a space after the hash symbol(s).",
                                                                                 "c":  "Using lowercase letters in headings.",
                                                                                 "d":  "Making the heading text too long."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Common Mistakes to Avoid\" section lists \"Forgetting the Space\" as the first\n         mistake, showing #Heading Without Space as incorrect."
                                                             },
                                                             {
                                                                 "question":  "Why is a clear heading structure important for an AI agent reading a specification?",
                                                                 "options":  {
                                                                                 "a":  "It makes the document look prettier.",
                                                                                 "b":  "It allows the AI to parse the document\u0027s structure, find specific sections, and understand the\n         relationships between different parts of the requirements.",
                                                                                 "c":  "It is the only way an AI can read a text file.",
                                                                                 "d":  "It tells the AI which parts of the specification to ignore."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes by explaining that headings allow AI to \"Parse the structure,\"\n         \"Find specific information,\" and \"Validate completeness.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  62,
                                           "chapter_title":  "Lists - Organizing Ideas",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "When should you use an unordered (bullet point) list in a specification?",
                                                                 "options":  {
                                                                                 "a":  "When describing a sequence of steps that must be done in order.",
                                                                                 "b":  "When listing items that do not have a specific required order, such as a list of features.",
                                                                                 "c":  "You should never use unordered lists in a specification.",
                                                                                 "d":  "Only when you have more than 10 items to list."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \"Use unordered lists when you have items that don\u0027t need to be in\n         any specific order,\" and gives a feature list as a primary example."
                                                             },
                                                             {
                                                                 "question":  "How do you create an ordered (numbered) list in markdown?",
                                                                 "options":  {
                                                                                 "a":  "By starting each line with a dash (-).",
                                                                                 "b":  "By starting each line with a number followed by a period and a space (e.g., 1. ).",
                                                                                 "c":  "By manually typing the numbers and hoping the alignment is correct.",
                                                                                 "d":  "By using the \u003col\u003e HTML tag."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Basic Syntax\" for ordered lists shows the pattern 1. First step."
                                                             },
                                                             {
                                                                 "question":  "What is the key question to ask yourself to decide whether to use an ordered or unordered\n      list?",
                                                                 "options":  {
                                                                                 "a":  " \"How many items are in the list?\"",
                                                                                 "b":  " \"Does the order of the items matter?\"",
                                                                                 "c":  " \"Is the list for a human or an AI?\"",
                                                                                 "d":  " \"Are the items short or long?\""
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Choosing the Right List Type\" section provides a decision guide based on the\n         central question: \"Does order matter?\""
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a common mistake when writing markdown lists?",
                                                                 "options":  {
                                                                                 "a":  "Using a dash (-) for an unordered list.",
                                                                                 "b":  "Forgetting to put a space after the dash or number (e.g., -No space).",
                                                                                 "c":  "Using numbers for a list of steps.",
                                                                                 "d":  "Having more than five items in a list."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The first common mistake listed is \"Forgetting the Space,\" showing -No space after dash\n         as incorrect."
                                                             },
                                                             {
                                                                 "question":  "Why is using the correct list type important for an AI agent?",
                                                                 "options":  {
                                                                                 "a":  "It is not important; the AI does not understand the difference.",
                                                                                 "b":  "It helps the AI understand if there are dependencies between items (ordered list) or if they are\n         independent (unordered list).",
                                                                                 "c":  "It tells the AI how many developers are needed for the project.",
                                                                                 "d":  "It changes the color of the text that the AI generates."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes by explaining that lists help the AI \"Understand dependencies —\n         \u0027Step 2 requires Step 1 to complete first\u0027.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  63,
                                           "chapter_title":  "Code Blocks - Showing Examples",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In markdown, how do you create a \"fenced code block\" for multiple lines of code?",
                                                                 "options":  {
                                                                                 "a":  "By putting a \u003e symbol at the beginning of each line.",
                                                                                 "b":  "By indenting each line with four spaces.",
                                                                                 "c":  "By surrounding the code with triple backticks (\n  `).",
                                                                                 "d":  "By using single backticks (`) around the entire block."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s \"Basic Syntax\" section for fenced code blocks explicitly shows the use of\n         triple backticks (`) to open and close the block."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of adding a language tag (like python or bash) to a code block?",
                                                                 "options":  {
                                                                                 "a":  "It is a comment that is ignored by all tools.",
                                                                                 "b":  "It tells readers and AI agents what language the code is in and enables syntax highlighting.",
                                                                                 "c":  "It automatically translates the code to the specified language.",
                                                                                 "d":  "It prevents the code from being executed."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that language tags help \"Readers understand,\" \"AI agents know what\n         language to generate,\" and \"Code viewers apply correct syntax highlighting.\""
                                                             },
                                                             {
                                                                 "question":  "When is it appropriate to use inline code (single backticks) instead of a fenced code block?",
                                                                 "options":  {
                                                                                 "a":  "When you have multiple lines of code to display.",
                                                                                 "b":  "When you want to reference short items like variable names, function names, or commands within a\n         sentence.",
                                                                                 "c":  "Never; you should always use fenced code blocks.",
                                                                                 "d":  "When you want to add a language tag."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises using inline code for \"short code references within regular text,\"\n         listing variable names, function names, and commands as examples."
                                                             },
                                                             {
                                                                 "question":  "In the practice exercise, why is the text language tag used for the \"Expected Output\" code\n      blocks?",
                                                                 "options":  {
                                                                                 "a":  "Because the output is written in a programming language called \"Text\".",
                                                                                 "b":  "Because the block contains plain text output from a program, not code to be executed.",
                                                                                 "c":  "It is a mistake; it should have been python.",
                                                                                 "d":  "To prevent the text from being displayed."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that text is for \"Plain output (no code).\" The expected output of\n         the program is what the user sees, which is plain text."
                                                             },
                                                             {
                                                                 "question":  "What is a common mistake when creating a fenced code block?",
                                                                 "options":  {
                                                                                 "a":  "Adding a language tag.",
                                                                                 "b":  "Forgetting to add the closing triple backticks (\n  `).",
                                                                                 "c":  "Putting more than one line of code inside it.",
                                                                                 "d":  "Using it to show expected output."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Common Mistakes to Avoid\" section lists \"Forgetting Closing Backticks\" as the first\n         mistake."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  64,
                                           "chapter_title":  "Links, Images \u0026 Your First Complete Specification",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the correct markdown syntax for creating a hyperlink?",
                                                                 "options":  {
                                                                                 "a":  "(link text)[url]",
                                                                                 "b":  "\u003ca href=\"url\"\u003elink text\u003c/a\u003e",
                                                                                 "c":  "[link text](url)",
                                                                                 "d":  "[[url | link text]]"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s \"The Syntax (Direct Teaching)\" section for links explicitly shows the\n         [link text](url) format."
                                                             },
                                                             {
                                                                 "question":  "How does the markdown syntax for an image differ from the syntax for a link?",
                                                                 "options":  {
                                                                                 "a":  "An image uses square brackets for the URL and parentheses for the alt text.",
                                                                                 "b":  "An image starts with an exclamation mark (!) before the first square bracket.",
                                                                                 "c":  "There is no difference in the syntax.",
                                                                                 "d":  "An image does not have alt text."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \"Markdown images use almost the same syntax as links, with one\n         difference - an exclamation mark ! at the start: ![alt text](image-url).\""
                                                             },
                                                             {
                                                                 "question":  "In a specification, when is it most appropriate to use bold emphasis?",
                                                                 "options":  {
                                                                                 "a":  "For entire paragraphs to make them stand out.",
                                                                                 "b":  "For terms that are critical to understanding, such as feature names or important constraints.",
                                                                                 "c":  "For words you are unsure about.",
                                                                                 "d":  "For all headings."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter advises using bold for \"Feature names,\" \"Important constraints,\" \"Key\n         terms,\" and \"Action words.\""
                                                             },
                                                             {
                                                                 "question":  "What is the main purpose of creating a complete, well-structured specification document before\n      starting to code?",
                                                                 "options":  {
                                                                                 "a":  "To make the project take longer.",
                                                                                 "b":  "To provide a clear, unambiguous \"Intent Layer\" that allows an AI agent to generate accurate code\n         that matches your requirements.",
                                                                                 "c":  "To replace the need for a README file.",
                                                                                 "d":  "To have a document to print and put on the wall."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes by stating that a clear specification is the \"bridge between what\n         you want (Layer 1) and what gets built (Layer 3)\" and that it \"reduces misunderstandings and helps AI\n         agents generate more accurate code.\""
                                                             },
                                                             {
                                                                 "question":  "The capstone exercise for the Task Tracker App combines skills from four lessons. What does\n      this integrated approach demonstrate?",
                                                                 "options":  {
                                                                                 "a":  "That markdown is too complicated for a single document.",
                                                                                 "b":  "That real specifications are built iteratively, combining structure, organization, examples, and\n         emphasis to create a complete and clear document.",
                                                                                 "c":  "That you should only use one type of markdown element per document.",
                                                                                 "d":  "That AI cannot understand documents with multiple types of formatting."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The exercise is framed as a cumulative task, showing that \"real specifications are built\n         — iteratively, adding detail at each stage\" by combining headings, lists, code blocks, and other\n         elements."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  65,
                                           "chapter_title":  "Understanding AI Coding Agents as Collaborative Partners",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the key difference between an AI coding agent and a traditional search engine like\n      Google?",
                                                                 "options":  {
                                                                                 "a":  "A search engine generates new code, while an AI agent only finds existing answers.",
                                                                                 "b":  "An AI agent generates new, tailored code for a specific situation, while a search engine finds\n         existing answers written by others.",
                                                                                 "c":  "They are functionally the same.",
                                                                                 "d":  "An AI agent can only answer questions, while a search engine can write code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts them: \"Search Engine: \u0027Here are answers that exist\u0027\" versus \"AI\n         Agent: \u0027I\u0027ll generate a new answer for your specific situation\u0027.\""
                                                             },
                                                             {
                                                                 "question":  "What is a \"context window\" for an AI agent?",
                                                                 "options":  {
                                                                                 "a":  "The graphical user interface of the AI.",
                                                                                 "b":  "The AI agent\u0027s \"short-term memory,\" which includes the current conversation and any files it has\n         been shown.",
                                                                                 "c":  "A special type of file that stores the AI\u0027s source code.",
                                                                                 "d":  "The total number of users the AI can talk to at once."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines it using an analogy: \"Imagine you have a conversation with a\n         colleague, and they can only remember the last 5 minutes... A context window is the AI agent\u0027s\n         \u0027short-term memory.\u0027\""
                                                             },
                                                             {
                                                                 "question":  "Why does providing clear, specific prompts to an AI agent lead to better code?",
                                                                 "options":  {
                                                                                 "a":  "Because AI agents build code \"token-by-token,\" and a vague prompt forces the AI to make\n         assumptions at each step, which can lead to errors.",
                                                                                 "b":  "Because clear prompts use more tokens, which makes the AI work harder.",
                                                                                 "c":  "It does not lead to better code; prompt quality is irrelevant.",
                                                                                 "d":  "Because vague prompts are more difficult for the AI to read."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter explains that because of token-by-token generation, \"If your request is\n         vague, the AI makes assumptions at each step, and those assumptions compound.\""
                                                             },
                                                             {
                                                                 "question":  "In the new paradigm of AI-native development, what is the developer\u0027s primary role?",
                                                                 "options":  {
                                                                                 "a":  "To be a \"code typist\" who memorizes syntax.",
                                                                                 "b":  "To be an \"AI orchestrator\" who communicates clearly, validates outputs, and iterates with the AI.",
                                                                                 "c":  "To manually write every single line of code without assistance.",
                                                                                 "d":  "To build and train large language models from scratch."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes the shift: \"You\u0027re not abandoning development—you\u0027re upgrading\n         your role... you\u0027re becoming the person who: 1. Thinks strategically... 2. Communicates clearly...\n         3. Validates intelligently... 4. Iterates efficiently.\""
                                                             },
                                                             {
                                                                 "question":  "What is the most important skill for a developer to have when working with AI, according to\n      the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Fast typing speed.",
                                                                                 "b":  "The ability to memorize complex algorithms.",
                                                                                 "c":  "Clear communication.",
                                                                                 "d":  "Knowledge of multiple programming languages."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s central theme is that \"clear communication with AI is more valuable than\n         typing ability.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  66,
                                           "chapter_title":  "HIDDEN SKILLS METADATA (Institutional Integration Layer)",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of \"Hidden Skills Metadata\" in an educational context like this book?",
                                                                 "options":  {
                                                                                 "a":  "To provide additional reading material for students.",
                                                                                 "b":  "To track and map the skills taught in each chapter to external educational standards or institutional requirements.",
                                                                                 "c":  "To hide complex technical details from the reader.",
                                                                                 "d":  "To generate random quiz questions."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Hidden skills metadata is typically used for behind-the-scenes tracking and alignment with broader educational frameworks, making the curriculum measurable and transferable."
                                                             },
                                                             {
                                                                 "question":  "Why might this metadata be \"hidden\" from the direct view of the student?",
                                                                 "options":  {
                                                                                 "a":  "It contains sensitive information that students should not see.",
                                                                                 "b":  "It is primarily for administrative or institutional use, to avoid overwhelming students with technical details about curriculum mapping.",
                                                                                 "c":  "It is not yet complete and is under development.",
                                                                                 "d":  "It is a secret code for the AI."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The term \"hidden\" suggests it\u0027s not part of the primary learning content but serves an organizational or administrative function."
                                                             },
                                                             {
                                                                 "question":  "Which of the following could be an example of information contained within \"Skills Metadata\"?",
                                                                 "options":  {
                                                                                 "a":  "The author\u0027s favorite programming language.",
                                                                                 "b":  "CEFR (Common European Framework of Reference) levels, Bloom\u0027s Taxonomy cognitive levels, or specific industry certifications.",
                                                                                 "c":  "The number of pages in the chapter.",
                                                                                 "d":  "The publication date of the book."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Skills metadata often involves mapping learning outcomes to recognized frameworks for standardized assessment and transferability."
                                                             },
                                                             {
                                                                 "question":  "How does \"Institutional Integration Layer\" relate to \"Skills Metadata\"?",
                                                                 "options":  {
                                                                                 "a":  "It\u0027s a layer where institutions directly write new chapters.",
                                                                                 "b":  "It signifies that the skills metadata is designed to facilitate the integration of the book\u0027s curriculum with larger institutional learning management systems or accreditation bodies.",
                                                                                 "c":  "It refers to the physical location of the educational institution.",
                                                                                 "d":  "It\u0027s a security layer to protect student data."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"integration layer\" implies a bridge between the book\u0027s content and external educational systems, which is enabled by structured metadata."
                                                             },
                                                             {
                                                                 "question":  "What is a potential benefit of having well-defined \"Skills Metadata\" for an educational program?",
                                                                 "options":  {
                                                                                 "a":  "It makes the program more expensive.",
                                                                                 "b":  "It allows for competency-based assessment, easier curriculum alignment, and potentially portable credentials for learners.",
                                                                                 "c":  "It reduces the need for teachers.",
                                                                                 "d":  "It makes the content harder to update."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Structured skills metadata provides clear, measurable learning outcomes that can be used for various educational and administrative purposes."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  67,
                                           "chapter_title":  "HIDDEN SKILLS METADATA (Institutional Integration Layer)",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary audience for the \"Institutional Integration Layer\" aspect of skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "Students learning the material.",
                                                                                 "b":  "Educators, curriculum designers, and institutional administrators.",
                                                                                 "c":  "AI agents generating code.",
                                                                                 "d":  "Technical writers creating documentation."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Institutional Integration Layer\" implies that this metadata is designed to serve the needs of educational institutions for curriculum management and accreditation."
                                                             },
                                                             {
                                                                 "question":  "How does skills metadata contribute to the \"portability\" of learning achievements?",
                                                                 "options":  {
                                                                                 "a":  "By making course materials available online.",
                                                                                 "b":  "By providing a standardized, machine-readable description of learned skills that can be recognized across different institutions or employers.",
                                                                                 "c":  "By allowing students to download their grades.",
                                                                                 "d":  "By reducing the size of educational files."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Standardized metadata allows for easier recognition and transfer of skills, making learning achievements more portable."
                                                             },
                                                             {
                                                                 "question":  "Which international standard is often used to describe language proficiency and could be mapped in skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "ISO 9001",
                                                                                 "b":  "CEFR (Common European Framework of Reference for Languages)",
                                                                                 "c":  "HTTP/2",
                                                                                 "d":  "GDPR"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "CEFR is a widely recognized standard for describing language proficiency, and similar frameworks exist for other skill domains."
                                                             },
                                                             {
                                                                 "question":  "What is a key challenge in implementing an \"Institutional Integration Layer\" for skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "Getting students to read the metadata.",
                                                                                 "b":  "Ensuring interoperability and consistent interpretation of metadata across diverse institutional systems and platforms.",
                                                                                 "c":  "Making the metadata visually appealing.",
                                                                                 "d":  "Limiting the amount of data stored in the metadata."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Integrating data across different systems always presents challenges related to standards, formats, and consistent interpretation."
                                                             },
                                                             {
                                                                 "question":  "If a chapter\u0027s skills metadata indicates a \"Bloom\u0027s Taxonomy\" level of \"Apply,\" what does this suggest about the learning objective?",
                                                                 "options":  {
                                                                                 "a":  "Students should be able to recall facts about the topic.",
                                                                                 "b":  "Students should be able to use the learned information in a new situation or solve a problem.",
                                                                                 "c":  "Students should be able to evaluate the quality of the information.",
                                                                                 "d":  "Students should be able to create something entirely new."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  " \"Apply\" in Bloom\u0027s Taxonomy refers to the ability to use knowledge in practical scenarios."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  68,
                                           "chapter_title":  "Lesson 4: Specifying Logic - Implementation Steps for Real Features",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary goal of \"specifying logic\" in AI-native development?",
                                                                 "options":  {
                                                                                 "a":  "To write the code directly.",
                                                                                 "b":  "To provide clear, unambiguous instructions for an AI agent to implement a feature.",
                                                                                 "c":  "To design the user interface.",
                                                                                 "d":  "To debug existing code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Specifying logic is about defining *what* needs to be built in a way that an AI can understand and implement, rather than *how* to code it."
                                                             },
                                                             {
                                                                 "question":  "When breaking down a complex feature into \"implementation steps,\" what is a key consideration?",
                                                                 "options":  {
                                                                                 "a":  "Making each step as long and detailed as possible.",
                                                                                 "b":  "Ensuring each step is atomic and clearly defines an input, a process, and an output.",
                                                                                 "c":  "Focusing only on the visual aspects of the feature.",
                                                                                 "d":  "Avoiding any mention of data or variables."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Effective logic specification requires breaking down features into manageable, unambiguous steps that an AI can process."
                                                             },
                                                             {
                                                                 "question":  "Why is it important to define inputs and expected outputs when specifying logic for an AI?",
                                                                 "options":  {
                                                                                 "a":  "To make the specification longer.",
                                                                                 "b":  "To allow the AI to guess the correct data types.",
                                                                                 "c":  "To provide clear boundaries and success criteria for the AI\u0027s implementation, enabling validation.",
                                                                                 "d":  "To confuse the AI with unnecessary details."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Clear inputs and outputs are crucial for the AI to understand the scope of its task and for the developer to validate the AI\u0027s generated code."
                                                             },
                                                             {
                                                                 "question":  "Which of the following best describes an \"implementation step\" in the context of specifying logic?",
                                                                 "options":  {
                                                                                 "a":  "A high-level overview of the entire feature.",
                                                                                 "b":  "A detailed, step-by-step instruction for the AI to perform a specific part of the feature\u0027s logic.",
                                                                                 "c":  "A list of programming languages to use.",
                                                                                 "d":  "A description of the project\u0027s architecture."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Implementation steps are granular instructions that guide the AI through the logical flow of a feature."
                                                             },
                                                             {
                                                                 "question":  "What role does \"validation\" play after an AI implements logic based on a specification?",
                                                                 "options":  {
                                                                                 "a":  "It is unnecessary, as AI always implements perfectly.",
                                                                                 "b":  "It involves checking if the AI\u0027s generated code correctly fulfills the specified logic and meets expected outputs.",
                                                                                 "c":  "It is only for identifying syntax errors.",
                                                                                 "d":  "It is a step performed by the AI itself, not the developer."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Validation is a critical human role in AI-native development, ensuring the AI\u0027s output aligns with the specified requirements."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  69,
                                           "chapter_title":  "HIDDEN SKILLS METADATA (Institutional Integration Layer)",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary benefit of mapping educational content to standardized skill frameworks (e.g., DigComp, ESCO) using metadata?",
                                                                 "options":  {
                                                                                 "a":  "It makes the content more entertaining for students.",
                                                                                 "b":  "It allows for cross-referencing, comparison, and recognition of skills across different educational programs and national boundaries.",
                                                                                 "c":  "It reduces the amount of content that needs to be written.",
                                                                                 "d":  "It automatically translates the content into multiple languages."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Standardized frameworks provide a common language for describing skills, facilitating global recognition and transferability of qualifications."
                                                             },
                                                             {
                                                                 "question":  "How can \"Skills Metadata\" assist in personalizing learning paths for students?",
                                                                 "options":  {
                                                                                 "a":  "By forcing all students to follow the same curriculum.",
                                                                                 "b":  "By identifying a student\u0027s existing proficiencies and gaps, allowing for tailored recommendations of content or exercises.",
                                                                                 "c":  "By randomly assigning chapters to students.",
                                                                                 "d":  "By making all content optional."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Detailed skill mapping can help pinpoint individual learning needs and suggest relevant resources to address them."
                                                             },
                                                             {
                                                                 "question":  "What does the \"Institutional Integration Layer\" imply about the design of the skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "It is designed to be manually updated by each student.",
                                                                                 "b":  "It is structured in a way that can be programmatically accessed and processed by Learning Management Systems (LMS) or other institutional platforms.",
                                                                                 "c":  "It is only accessible to the book\u0027s authors.",
                                                                                 "d":  "It is a physical layer within the institution\u0027s building."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "An \"integration layer\" suggests an API or structured data format that allows different systems to communicate and exchange information about skills."
                                                             },
                                                             {
                                                                 "question":  "If a skill is mapped to a \"Bloom\u0027s Taxonomy\" level of \"Analyze,\" what kind of assessment would be most appropriate?",
                                                                 "options":  {
                                                                                 "a":  "A simple multiple-choice question recalling a definition.",
                                                                                 "b":  "An essay requiring students to break down information into its constituent parts and determine how they relate.",
                                                                                 "c":  "A practical task requiring the creation of a new product.",
                                                                                 "d":  "A true/false quiz."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "\"Analyze\" involves breaking down information and understanding relationships, which is best assessed through tasks requiring critical thinking and explanation."
                                                             },
                                                             {
                                                                 "question":  "What is a potential long-term vision for the use of \"Skills Metadata\" in education?",
                                                                 "options":  {
                                                                                 "a":  "To replace all human teachers with AI.",
                                                                                 "b":  "To create a global, interoperable system for recognizing and validating individual competencies, fostering lifelong learning and career mobility.",
                                                                                 "c":  "To standardize all educational content worldwide into a single format.",
                                                                                 "d":  "To eliminate the need for formal education."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The ultimate goal of robust skills metadata is often to create a more flexible and recognized system for skills acquisition and validation across various contexts."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  70,
                                           "chapter_title":  "Required import (add to top of file):",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary reason for placing \"import\" statements at the top of a file in most programming languages?",
                                                                 "options":  {
                                                                                 "a":  "It makes the file size smaller.",
                                                                                 "b":  "It ensures that all necessary modules, libraries, or components are available before any code that uses them is executed.",
                                                                                 "c":  "It improves the aesthetic appeal of the code.",
                                                                                 "d":  "It is a historical convention with no practical purpose today."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Placing imports at the top ensures dependencies are resolved early, preventing runtime errors and making code easier to understand."
                                                             },
                                                             {
                                                                 "question":  "In the context of AI-generated code, why is it crucial for the AI to correctly identify and place \"required imports\"?",
                                                                 "options":  {
                                                                                 "a":  "To make the generated code longer.",
                                                                                 "b":  "Incorrect or missing imports will lead to immediate compilation or runtime errors, making the AI\u0027s output unusable.",
                                                                                 "c":  "To demonstrate the AI\u0027s knowledge of syntax.",
                                                                                 "d":  "To confuse the human developer."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Imports are fundamental for code functionality; without them, AI-generated code will fail to execute."
                                                             },
                                                             {
                                                                 "question":  "What is a common consequence if a \"required import\" is missing from a code file?",
                                                                 "options":  {
                                                                                 "a":  "The program will run slower but without errors.",
                                                                                 "b":  "The program will execute successfully but produce incorrect results.",
                                                                                 "c":  "A \"NameError\" or similar error indicating an undefined variable/function will occur when the program tries to use the unimported component.",
                                                                                 "d":  "The operating system will crash."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Missing imports typically result in errors because the program cannot find the definitions for the components it\u0027s trying to use."
                                                             },
                                                             {
                                                                 "question":  "If an AI agent is tasked with generating a Python script that uses external libraries, what should the developer explicitly check regarding imports?",
                                                                 "options":  {
                                                                                 "a":  "That the AI has used the most obscure libraries possible.",
                                                                                 "b":  "That all necessary `import` statements for the external libraries are correctly placed at the top of the file.",
                                                                                 "c":  "That the AI has avoided all import statements.",
                                                                                 "d":  "That the imports are commented out."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Developers must validate that AI-generated code includes all required imports to ensure functionality and adherence to best practices."
                                                             },
                                                             {
                                                                 "question":  "Beyond functionality, what is another benefit of consistently adding \"required imports\" at the top of a file?",
                                                                 "options":  {
                                                                                 "a":  "It makes the code harder to read.",
                                                                                 "b":  "It provides a quick overview of the file\u0027s external dependencies, improving code readability and maintainability for human developers.",
                                                                                 "c":  "It prevents the file from being modified.",
                                                                                 "d":  "It automatically installs missing packages."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "A clear list of imports at the top serves as a manifest of external dependencies, aiding human understanding and maintenance."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  71,
                                           "chapter_title":  "HIDDEN SKILLS METADATA (Institutional Integration Layer)",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary benefit of using a standardized \"Institutional Integration Layer\" for skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "It allows for direct code generation by the institution.",
                                                                                 "b":  "It enables seamless data exchange and reporting of student skill attainment to various institutional systems (e.g., student information systems, accreditation bodies).",
                                                                                 "c":  "It replaces the need for human instructors.",
                                                                                 "d":  "It automatically updates the book\u0027s content."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "An integration layer facilitates the flow of skill-related data between the learning content and the broader institutional ecosystem."
                                                             },
                                                             {
                                                                 "question":  "How does \"Skills Metadata\" support the concept of \"micro-credentials\" or \"digital badges\"?",
                                                                 "options":  {
                                                                                 "a":  "By making it harder to verify small achievements.",
                                                                                 "b":  "By providing granular, verifiable data about specific skills acquired, which can be bundled into micro-credentials.",
                                                                                 "c":  "By replacing traditional degrees entirely.",
                                                                                 "d":  "By only tracking large, complex skills."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Micro-credentials rely on precise definitions of skills, which metadata can provide, allowing for the recognition of smaller, specific achievements."
                                                             },
                                                             {
                                                                 "question":  "What role does \"governance\" play in the effective use of \"Institutional Integration Layer\" for skills metadata?",
                                                                 "options":  {
                                                                                 "a":  "It dictates the programming languages used in the curriculum.",
                                                                                 "b":  "It establishes rules, standards, and processes for how skills are defined, mapped, and integrated across the institution to ensure consistency and quality.",
                                                                                 "c":  "It controls student access to learning materials.",
                                                                                 "d":  "It is solely concerned with the financial aspects of education."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Governance ensures that the skills metadata system is well-maintained, consistent, and serves its intended purpose across the institution."
                                                             },
                                                             {
                                                                 "question":  "If a learning objective is mapped to a \"Bloom\u0027s Taxonomy\" level of \"Evaluate,\" what kind of task would best assess this?",
                                                                 "options":  {
                                                                                 "a":  "Listing facts about a topic.",
                                                                                 "b":  "Explaining a concept in one\u0027s own words.",
                                                                                 "c":  "Judging the value or quality of a solution, argument, or product based on criteria.",
                                                                                 "d":  "Creating a new solution to a problem."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  " \"Evaluate\" involves making judgments based on criteria, which requires critical assessment."
                                                             },
                                                             {
                                                                 "question":  "What is a key challenge in maintaining \"Skills Metadata\" over time within a dynamic curriculum?",
                                                                 "options":  {
                                                                                 "a":  "The metadata is too simple to change.",
                                                                                 "b":  "Ensuring that the metadata remains accurate, up-to-date, and aligned with evolving content and educational standards.",
                                                                                 "c":  "Students frequently request changes to the metadata.",
                                                                                 "d":  "The metadata takes up too much storage space."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Curricula and standards evolve, so the metadata must be regularly reviewed and updated to remain relevant and useful."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  72,
                                           "chapter_title":  "Step 1: Let Claude scan your project structure",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of \"letting Claude scan your project structure\" as an initial step?",
                                                                 "options":  {
                                                                                 "a":  "To automatically fix all errors in the project.",
                                                                                 "b":  "To provide the AI with a foundational understanding of the codebase layout, file types, and organizational patterns before it performs any tasks.",
                                                                                 "c":  "To delete unnecessary files from the project.",
                                                                                 "d":  "To generate a new project from scratch."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Scanning the project structure allows the AI to build an internal map of the codebase, which is crucial for context and effective task execution."
                                                             },
                                                             {
                                                                 "question":  "Why is understanding the \"project structure\" important for an AI coding agent?",
                                                                 "options":  {
                                                                                 "a":  "It helps the AI choose a random file to modify.",
                                                                                 "b":  "It enables the AI to locate relevant files, understand dependencies, adhere to project conventions, and propose changes that fit the existing architecture.",
                                                                                 "c":  "It is only for human readability.",
                                                                                 "d":  "It prevents the AI from accessing any files."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "A clear understanding of the project structure is essential for the AI to operate intelligently and integrate its work seamlessly."
                                                             },
                                                             {
                                                                 "question":  "What kind of information would \"Claude\" typically gather during a \"project structure scan\"?",
                                                                 "options":  {
                                                                                 "a":  "The user\u0027s personal browsing history.",
                                                                                 "b":  "File names, directory hierarchy, file types, and potentially the presence of configuration files or READMEs.",
                                                                                 "c":  "The current weather forecast.",
                                                                                 "d":  "The latest stock market data."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "A project structure scan focuses on the organizational and descriptive elements of the codebase."
                                                             },
                                                             {
                                                                 "question":  "What is a direct benefit for the human developer when the AI has a clear understanding of the \"project structure\"?",
                                                                 "options":  {
                                                                                 "a":  "The developer no longer needs to understand the project structure.",
                                                                                 "b":  "The AI can provide more accurate suggestions, navigate the codebase more effectively, and require less explicit guidance on file locations.",
                                                                                 "c":  "The AI will automatically write all future code.",
                                                                                 "d":  "The project will become open source."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "A well-informed AI can be a more effective and autonomous collaborator, reducing the cognitive load on the human developer."
                                                             },
                                                             {
                                                                 "question":  "If \"Claude\" identifies a `.gitignore` file during its scan, what is its likely interpretation of that file\u0027s purpose?",
                                                                 "options":  {
                                                                                 "a":  "A list of files to prioritize for modification.",
                                                                                 "b":  "A list of files and directories that should be ignored by version control and potentially by the AI itself during certain operations.",
                                                                                 "c":  "A file containing important project secrets.",
                                                                                 "d":  "A file that needs to be deleted immediately."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The `.gitignore` file explicitly tells version control (and by extension, intelligent agents) which files are intentionally untracked."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  73,
                                           "chapter_title":  "What is Context Engineering?",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the fundamental concept behind \"Context Engineering\" in AI-driven development?",
                                                                 "options":  {
                                                                                 "a":  "Designing the user interface for AI tools.",
                                                                                 "b":  "The deliberate and strategic management of information provided to an AI to guide its understanding and output.",
                                                                                 "c":  "Optimizing AI models for faster performance.",
                                                                                 "d":  "Automating the deployment of AI applications."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Context Engineering is about carefully crafting the input (context) given to an AI to ensure it produces relevant and accurate results."
                                                             },
                                                             {
                                                                 "question":  "Why is \"context\" crucial for an AI agent to perform tasks effectively?",
                                                                 "options":  {
                                                                                 "a":  "AI agents can only function with a large amount of random data.",
                                                                                 "b":  "Context provides the necessary background, constraints, and examples for the AI to understand the problem and generate appropriate solutions.",
                                                                                 "c":  "Without context, AI agents cannot connect to the internet.",
                                                                                 "d":  "Context helps AI agents learn new programming languages."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Just like humans, AI needs context to understand the nuances of a request and to produce outputs that align with the user\u0027s intent."
                                                             },
                                                             {
                                                                 "question":  "Which of the following is an example of \"context\" provided to an AI agent?",
                                                                 "options":  {
                                                                                 "a":  "The current date and time.",
                                                                                 "b":  "A detailed specification document, relevant code snippets, and previous conversation turns.",
                                                                                 "c":  "The AI agent\u0027s internal code.",
                                                                                 "d":  "The operating system\u0027s kernel."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Context includes all the information that helps the AI understand the current task, such as specifications, code, and conversational history."
                                                             },
                                                             {
                                                                 "question":  "What is a potential pitfall of providing insufficient or irrelevant context to an AI agent?",
                                                                 "options":  {
                                                                                 "a":  "The AI agent will refuse to respond.",
                                                                                 "b":  "The AI agent might generate code that is off-topic, incorrect, or makes incorrect assumptions.",
                                                                                 "c":  "The AI agent will become slower.",
                                                                                 "d":  "The AI agent will ask too many clarifying questions."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Insufficient context forces the AI to \"guess,\" leading to suboptimal or erroneous outputs. Irrelevant context can confuse the AI."
                                                             },
                                                             {
                                                                 "question":  "In the context of AI-native development, who is primarily responsible for \"engineering\" the context?",
                                                                 "options":  {
                                                                                 "a":  "The AI agent itself.",
                                                                                 "b":  "The end-user of the software.",
                                                                                 "c":  "The human developer collaborating with the AI.",
                                                                                 "d":  "The server hosting the AI model."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The human developer plays a crucial role in curating and providing the right context to the AI for effective collaboration."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  74,
                                           "chapter_title":  "Understanding Context Windows",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What does the term \"context window\" refer to in the context of Large Language Models (LLMs)?",
                                                                 "options":  {
                                                                                 "a":  "The graphical interface where you type your prompts.",
                                                                                 "b":  "The maximum amount of text (tokens) an LLM can process or \"remember\" at any given time during an interaction.",
                                                                                 "c":  "A pop-up window that provides helpful tips.",
                                                                                 "d":  "The time limit for an AI to respond."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The context window is the fundamental limit on how much information an LLM can consider in a single interaction, acting as its short-term memory."
                                                             },
                                                             {
                                                                 "question":  "If an interaction with an LLM exceeds its context window, what is the most likely outcome?",
                                                                 "options":  {
                                                                                 "a":  "The LLM will automatically expand its context window.",
                                                                                 "b":  "The LLM will ignore the oldest parts of the conversation or provided documents, leading to a loss of relevant information.",
                                                                                 "c":  "The LLM will ask the user to summarize the entire conversation.",
                                                                                 "d":  "The LLM will crash and restart."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "When the context window is exceeded, LLMs typically employ a \"sliding window\" approach, dropping older information to make space for new input, which can lead to the AI \"forgetting\" crucial details."
                                                             },
                                                             {
                                                                 "question":  "Why is understanding the context window important for effective \"Context Engineering\"?",
                                                                 "options":  {
                                                                                 "a":  "It helps developers choose the fastest LLM.",
                                                                                 "b":  "It allows developers to strategically manage the information provided to the AI, ensuring critical details remain within the active context.",
                                                                                 "c":  "It is only relevant for AI model developers, not users.",
                                                                                 "d":  "It dictates the programming language used for the project."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Knowing the context window limits allows developers to prioritize and condense information, ensuring the AI always has access to the most relevant data for the task at hand."
                                                             },
                                                             {
                                                                 "question":  "Which of the following strategies can help manage interactions within a limited context window?",
                                                                 "options":  {
                                                                                 "a":  "Sending extremely long, unedited documents to the AI.",
                                                                                 "b":  "Summarizing previous interactions, providing only essential new information, and referencing external documents.",
                                                                                 "c":  "Constantly switching between different AI models.",
                                                                                 "d":  "Ignoring the AI\u0027s responses and re-prompting."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Techniques like summarization, incremental context provision, and referencing external knowledge bases are key to working effectively within context window constraints."
                                                             },
                                                             {
                                                                 "question":  "What is a \"token\" in the context of LLMs and context windows?",
                                                                 "options":  {
                                                                                 "a":  "A unit of time measured in seconds.",
                                                                                 "b":  "A small piece of text, often a word, part of a word, or punctuation, that an LLM processes.",
                                                                                 "c":  "A unique identifier for an AI model.",
                                                                                 "d":  "A type of cryptocurrency used to pay for AI services."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Tokens are the basic units of text that LLMs operate on, and the context window size is typically measured in the number of tokens."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  75,
                                           "chapter_title":  "The Six Components of AIDD Context",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "Which of the following is NOT typically considered a core component of AIDD Context?",
                                                                 "options":  {
                                                                                 "a":  "User Intent/Prompt",
                                                                                 "b":  "Project Files/Codebase",
                                                                                 "c":  "AI Model\u0027s Internal Architecture",
                                                                                 "d":  "Conversation History"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "While the AI\u0027s architecture is relevant to its capabilities, it\u0027s not a component *provided as context* by the user to guide the AI\u0027s task execution."
                                                             },
                                                             {
                                                                 "question":  "Why is \"User Intent/Prompt\" a critical component of AIDD Context?",
                                                                 "options":  {
                                                                                 "a":  "It tells the AI what programming language to use.",
                                                                                 "b":  "It directly communicates the user\u0027s goal and specific request to the AI, guiding its entire response.",
                                                                                 "c":  "It is used to measure the AI\u0027s processing speed.",
                                                                                 "d":  "It helps the AI generate random code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The prompt is the initial and most direct form of context, defining the task the user wants the AI to perform."
                                                             },
                                                             {
                                                                 "question":  "How does \"Project Files/Codebase\" contribute to AIDD Context?",
                                                                 "options":  {
                                                                                 "a":  "It provides the AI with a list of all available software.",
                                                                                 "b":  "It gives the AI an understanding of the existing code, structure, and conventions, allowing it to generate consistent and integrated solutions.",
                                                                                 "c":  "It is only used for storing large datasets.",
                                                                                 "d":  "It helps the AI learn about the project\u0027s financial status."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Access to the codebase ensures the AI\u0027s generated code fits seamlessly into the existing project, adhering to its style and dependencies."
                                                             },
                                                             {
                                                                 "question":  "What is the role of \"Conversation History\" as an AIDD Context component?",
                                                                 "options":  {
                                                                                 "a":  "To allow the AI to repeat previous answers.",
                                                                                 "b":  "To enable the AI to maintain continuity, remember past decisions, and build upon previous interactions within a session.",
                                                                                 "c":  "To record all user errors.",
                                                                                 "d":  "To provide a list of all developers who worked on the project."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Conversation history acts as the AI\u0027s short-term memory for the current session, allowing for iterative refinement and context retention."
                                                             },
                                                             {
                                                                 "question":  "Which of the following would be an example of \"External Knowledge/Documentation\" as an AIDD Context component?",
                                                                 "options":  {
                                                                                 "a":  "A user\u0027s personal preferences for coffee.",
                                                                                 "b":  "Links to official API documentation, relevant research papers, or project-specific style guides.",
                                                                                 "c":  "The AI\u0027s internal training data.",
                                                                                 "d":  "A list of all installed software on the user\u0027s machine."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "External knowledge provides the AI with authoritative information beyond the immediate project or conversation, ensuring accuracy and adherence to standards."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  76,
                                           "chapter_title":  "Progressive Context Loading",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary motivation behind \"Progressive Context Loading\" in AI interactions?",
                                                                 "options":  {
                                                                                 "a":  "To load all possible context at the beginning of an interaction.",
                                                                                 "b":  "To manage the AI\u0027s context window efficiently by providing information incrementally, as it becomes relevant.",
                                                                                 "c":  "To reduce the computational power required by the AI model.",
                                                                                 "d":  "To speed up the AI\u0027s initial response time."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Progressive context loading is a strategy to avoid overwhelming the AI\u0027s context window and to ensure that the most relevant information is always available when needed."
                                                             },
                                                             {
                                                                 "question":  "In a scenario where a project has thousands of files, how would \"Progressive Context Loading\" typically be applied?",
                                                                 "options":  {
                                                                                 "a":  "All files are sent to the AI at once.",
                                                                                 "b":  "Only the currently active file is sent, and other files are loaded only if the AI explicitly requests them or if they become relevant to the task.",
                                                                                 "c":  "The developer manually summarizes all files before sending them.",
                                                                                 "d":  "The AI is expected to find all relevant files on its own."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "This approach prevents exceeding the context window and focuses the AI on the most pertinent information for the immediate task."
                                                             },
                                                             {
                                                                 "question":  "What is a benefit of loading context progressively rather than all at once?",
                                                                 "options":  {
                                                                                 "a":  "It guarantees the AI will never make a mistake.",
                                                                                 "b":  "It reduces token usage, improves AI focus on the current task, and helps manage the limitations of the context window.",
                                                                                 "c":  "It makes the AI interaction more complex for the user.",
                                                                                 "d":  "It eliminates the need for the AI to ask clarifying questions."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "By providing context as needed, token costs are reduced, the AI is less likely to be distracted by irrelevant information, and the context window is better utilized."
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a common technique used in \"Progressive Context Loading\"?",
                                                                 "options":  {
                                                                                 "a":  "Sending the entire project documentation in a single prompt.",
                                                                                 "b":  "Using tools that dynamically fetch and inject relevant code snippets or documentation based on the AI\u0027s current focus or query.",
                                                                                 "c":  "Manually deleting old conversation turns to free up space.",
                                                                                 "d":  "Increasing the AI model\u0027s context window size indefinitely."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Dynamic context injection, often facilitated by specialized tools or frameworks, is a core mechanism for progressive context loading."
                                                             },
                                                             {
                                                                 "question":  "If an AI agent asks for more information about a specific function during a task, what does this indicate in the context of \"Progressive Context Loading\"?",
                                                                 "options":  {
                                                                                 "a":  "The AI is confused and cannot proceed.",
                                                                                 "b":  "The progressive loading mechanism is working, and the AI is requesting additional, relevant context as needed.",
                                                                                 "c":  "The initial prompt was too vague.",
                                                                                 "d":  "The AI has forgotten previous information."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Such a request signifies that the AI has processed the current context and identified a need for more specific information to continue, which is a natural part of progressive context loading."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  77,
                                           "chapter_title":  "Context Compression \u0026 Isolation",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary purpose of Context Compression?",
                                                                 "options":  {
                                                                                 "a":  "To make your code files smaller on your hard drive.",
                                                                                 "b":  "To summarize a long conversation into a concise checkpoint, freeing up space in the context window to continue working.",
                                                                                 "c":  "To delete your conversation history permanently.",
                                                                                 "d":  "To encrypt your conversation for security."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines it as \"the process of summarizing your session\u0027s progress, saving it as a checkpoint, and starting a fresh session with just the essential summary.\""
                                                             },
                                                             {
                                                                 "question":  "What is Context Isolation?",
                                                                 "options":  {
                                                                                 "a":  "Working with the AI without an internet connection.",
                                                                                 "b":  "Using a single, massive AI session for all of your tasks for the day.",
                                                                                 "c":  "Using separate, focused AI sessions or environments for different, unrelated tasks to prevent context from mixing.",
                                                                                 "d":  "Preventing the AI from accessing any of your local files."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Context Isolation is defined as \"the practice of using separate \u0027context environments\u0027 for different tasks, so information doesn\u0027t mix or interfere.\""
                                                             },
                                                             {
                                                                 "question":  "Which of the following is a recommended trigger for performing context compression?",
                                                                 "options":  {
                                                                                 "a":  "As soon as you start a new session.",
                                                                                 "b":  "After every single message you send.",
                                                                                 "c":  "After about 90 minutes of work or 10-15 interactions, or when you notice the AI slowing down.",
                                                                                 "d":  "You should never compress context."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \u0027When to Compress\u0027 section lists these triggers: \u0027Every 10-15 interactions,\u0027 \u0027After completing a major milestone,\u0027 and \u0027When you notice context degradation signs.\u0027"
                                                             },
                                                             {
                                                                 "question":  "If you need to fix a critical bug in your authentication system while also designing a new UI for the marketing page, which strategy is most appropriate?",
                                                                 "options":  {
                                                                                 "a":  "Context Compression",
                                                                                 "b":  "Context Isolation",
                                                                                 "c":  "Progressive Loading",
                                                                                 "d":  "All-at-Once Loading"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "These are two unrelated tasks. The chapter advises using Context Isolation (e.g., separate terminal sessions) to \u0027Keep contexts focused and separate\u0027 and \u0027Prevents Cross-Contamination.\u0027"
                                                             },
                                                             {
                                                                 "question":  "What is the main purpose of creating and maintaining memory files like DECISIONS.md and PATTERNS.md?",
                                                                 "options":  {
                                                                                 "a":  "They are required by the AI model to function.",
                                                                                 "b":  "To create extra work for the developer.",
                                                                                 "c":  "To document key architectural decisions and code conventions in a way that persists across sessions and can be loaded as context.",
                                                                                 "d":  "To share your project on social media."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "These files serve as a form of \u0027Agentic Memory\u0027 that prevents the AI from \u0027forgetting\u0027 key decisions and patterns between sessions."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  78,
                                           "chapter_title":  "Advanced Context Strategies",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is \"Context Curation\"?",
                                                                 "options":  {
                                                                                 "a":  "Allowing the AI to read every file in the project.",
                                                                                 "b":  "Explicitly controlling which specific files the AI reads to keep the context focused and relevant.",
                                                                                 "c":  "Deleting files from your project to reduce context.",
                                                                                 "d":  "Writing all your code in a single file."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines Context Curation as when \"You explicitly control which files AI reads,\" contrasting it with the bad practice of asking the AI to \"Read all files.\""
                                                             },
                                                             {
                                                                 "question":  "What is the principle of \"Example-Driven Context\"?",
                                                                 "options":  {
                                                                                 "a":  "Describing a coding pattern to the AI using only words.",
                                                                                 "b":  "Providing the AI with concrete code examples of a pattern instead of just describing it, to ensure it generates new code in the same style.",
                                                                                 "c":  "Asking the AI to find examples on the internet.",
                                                                                 "d":  "Giving the AI a link to a tutorial."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states the principle is to \"Show, Don\u0027t Tell,\" and provides examples of giving the AI code snippets to teach it a pattern."
                                                             },
                                                             {
                                                                 "question":  "A \"Multi-Agent Architecture\" involves what approach to solving a complex problem?",
                                                                 "options":  {
                                                                                 "a":  "Using one single, very large AI session for all parts of the problem.",
                                                                                 "b":  "Using separate, specialized AI agents (or sessions) with isolated contexts for different concerns like architecture, implementation, and testing.",
                                                                                 "c":  "Asking multiple different AI models the same question and comparing the answers.",
                                                                                 "d":  "Having multiple human developers work with a single AI agent."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter describes using different agents for different roles: an \"Architecture Agent,\" an \"Implementation Agent,\" and a \"Testing Agent,\" each with a focused context."
                                                             },
                                                             {
                                                                 "question":  "What is \"Just-In-Time Context Fetching\"?",
                                                                 "options":  {
                                                                                 "a":  "Loading every possible file into the context at the very beginning of the session.",
                                                                                 "b":  "Letting the AI tell you what context it needs as it works, and then providing only that specific information.",
                                                                                 "c":  "A strategy where context is only loaded at the end of the project.",
                                                                                 "d":  "A feature that automatically deletes context every five minutes."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines this as letting the \"AI tell you what context it needs, then provide only that,\" contrasting it with loading everything upfront."
                                                             },
                                                             {
                                                                 "question":  "If you are starting a new feature and want to ensure it follows the project\u0027s established coding patterns, which advanced strategy is most directly applicable?",
                                                                 "options":  {
                                                                                 "a":  "Just-In-Time Fetching",
                                                                                 "b":  "Multi-Agent Architecture",
                                                                                 "c":  "Example-Driven Context",
                                                                                 "d":  "Audio \u0026 Speech"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Example-Driven Context is the strategy of showing the AI concrete examples of existing patterns to ensure the new code it generates is consistent."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  79,
                                           "chapter_title":  "Context Enables Better Specifications",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \"hidden connection\" that this chapter reveals?",
                                                                 "options":  {
                                                                                 "a":  "That good context is only necessary for debugging, not for writing new features.",
                                                                                 "b":  "That clear specifications can be written without any understanding of the project\u0027s context.",
                                                                                 "c":  "That rich context engineering is the essential foundation for being able to write clear, effective specifications.",
                                                                                 "d":  "That prompt engineering and context engineering are the same skill."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The introduction states the crucial insight: \"Context engineering... is the foundation for writing clear specifications.\""
                                                             },
                                                             {
                                                                 "question":  "In the comparison of Developer A and Developer B, what was the fundamental flaw in Developer A\u0027s approach?",
                                                                 "options":  {
                                                                                 "a":  "Developer A\u0027s prompt was too long and detailed.",
                                                                                 "b":  "Developer A immediately asked the AI to implement a feature without first establishing any context about the existing project.",
                                                                                 "c":  "Developer A used the wrong AI tool for the job.",
                                                                                 "d":  "Developer A\u0027s project was too simple for an AI to understand."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter shows Developer A \"Immediately jumps to asking AI\" without providing any context, leading to generic code and hours of rework."
                                                             },
                                                             {
                                                                 "question":  "Why can\u0027t a developer write a good specification without first understanding the context?",
                                                                 "options":  {
                                                                                 "a":  "Because specifications are not important in AI-native development.",
                                                                                 "b":  "Because without understanding the existing system, patterns, and constraints, any specification they write will be vague and disconnected from the project\u0027s reality.",
                                                                                 "c":  "Because the AI can write the specification for them without any context.",
                                                                                 "d":  "Because good specifications can only be written after the code is complete."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter argues, \"You can\u0027t specify what you don\u0027t understand,\" explaining that good specs require knowledge of the system, which comes from context."
                                                             },
                                                             {
                                                                 "question":  "What is the \"Context-First Specification\" workflow?",
                                                                 "options":  {
                                                                                 "a":  "A workflow where you write the code first, and then load context to write the specification.",
                                                                                 "b":  "A workflow where you load all relevant context to gain a deep understanding of the project before you write the specification.",
                                                                                 "c":  "A workflow where the AI writes the specification without any human input.",
                                                                                 "d":  "A workflow that skips writing a specification altogether."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines this as \"the practice of loading all relevant context BEFORE writing a specification.\""
                                                             },
                                                             {
                                                                 "question":  "What is the relationship between the quality of the developer\u0027s understanding and the quality of the AI\u0027s output?",
                                                                 "options":  {
                                                                                 "a":  "They are unrelated; a powerful AI can produce good code regardless of the developer\u0027s understanding.",
                                                                                 "b":  "The AI\u0027s output quality is directly related to the developer\u0027s understanding, because if the developer\u0027s thinking is vague (due to poor context), their prompts and specs will be vague, leading to vague AI output.",
                                                                                 "c":  "A developer with poor understanding gets better results because the AI has more freedom.",
                                                                                 "d":  "Only the AI\u0027s understanding matters, not the developer\u0027s."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \"If your thinking is vague, the AI\u0027s output will be vague too.\" Good context leads to clear thinking, which leads to clear specs and good code."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  80,
                                           "chapter_title":  "Claude Code vs Gemini CLI - Choosing the Right Tool",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary analogy used in the chapter to explain the difference between Claude Code and Gemini CLI?",
                                                                               "options":  {
                                                                                               "a":  "Car vs. Bicycle",
                                                                                               "b":  "Chef\u0027s knife vs. Bread knife",
                                                                                               "c":  "Hammer vs. Screwdriver",
                                                                                               "d":  "Microscope vs. Telescope"
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter uses the analogy of \u0027Kitchen knives: Chef\u0027s knife vs. Bread knife\u0027 to illustrate that neither AI tool is inherently better, but designed for different scenarios."
                                                                           },
                                                                           {
                                                                               "question":  "According to the chapter, what is a key strength of Claude Code?",
                                                                               "options":  {
                                                                                               "a":  "Massive context window for bulk loading entire directories.",
                                                                                               "b":  "Deep reasoning and problem-solving for complex logical tasks.",
                                                                                               "c":  "Efficiently finding patterns across hundreds of files.",
                                                                                               "d":  "Generating comprehensive documentation from a large codebase."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter highlights \u0027Deep Reasoning and Problem-Solving\u0027 as a core strength of Claude Code, suitable for tasks like designing authentication systems with multiple edge cases."
                                                                           },
                                                                           {
                                                                               "question":  "For which type of task is Gemini CLI particularly strong?",
                                                                               "options":  {
                                                                                               "a":  "Designing complex algorithms from scratch.",
                                                                                               "b":  "Refactoring a single, messy code file.",
                                                                                               "c":  "Analyzing a 200-file legacy codebase for architecture and code quality.",
                                                                                               "d":  "Implementing a new feature with test-driven development."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "Gemini CLI excels at \u0027Large Codebase Analysis,\u0027 being able to ingest and analyze entire projects, making it ideal for understanding legacy codebases."
                                                                           },
                                                                           {
                                                                               "question":  "What is the approximate context window size for Gemini CLI (Gemini 1.5 Pro) mentioned in the chapter?",
                                                                               "options":  {
                                                                                               "a":  "200,000 tokens",
                                                                                               "b":  "500,000 tokens",
                                                                                               "c":  "1,000,000 to 2,000,000 tokens",
                                                                                               "d":  "50,000 tokens"
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Context Window Comparison Table\u0027 and text state Gemini CLI has a context window of \u0027~1,000,000 tokens (~750,000 words) for Gemini 1.5 Pro, ~2,000,000 for Flash\u0027."
                                                                           },
                                                                           {
                                                                               "question":  "Which hybrid workflow pattern involves using Gemini CLI to find all instances of a problem across a codebase, and then using Claude Code to fix each instance with proper reasoning?",
                                                                               "options":  {
                                                                                               "a":  "Analysis ? Implementation",
                                                                                               "b":  "Design ? Bulk Generation ? Refinement",
                                                                                               "c":  "Bulk Detection ? Targeted Fixes",
                                                                                               "d":  "Sequential Development"
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter describes \u0027Pattern 3: Bulk Detection ? Targeted Fixes\u0027 where Gemini finds problems (e.g., SQL injection vulnerabilities) and Claude fixes them individually with deep reasoning."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  81,
                                           "chapter_title":  "Validation, Pitfalls \u0026 Best Practices",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the most common context engineering mistake made by beginners?",
                                                                 "options":  {
                                                                                 "a":  "Loading too little context.",
                                                                                 "b":  "Loading all project files into the context window at the start of a session.",
                                                                                 "c":  "Never restarting an AI session.",
                                                                                 "d":  "Using memory files to document decisions."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter identifies \"Mistake #1: Loading All Files Upfront\" as the most common issue, explaining that it overloads the AI and degrades performance."
                                                             },
                                                             {
                                                                 "question":  "\u0027Context rot\u0027 refers to the degradation of AI performance in a long session. What is the recommended strategy to combat this?",
                                                                 "options":  {
                                                                                 "a":  "Continuing to work in the same session until it completely breaks.",
                                                                                 "b":  "Using context compression: summarizing the session\u0027s progress into a checkpoint and starting a fresh session with the summary.",
                                                                                 "c":  "Speaking to the AI instead of typing to save tokens.",
                                                                                 "d":  "Closing the tool and taking a break for an hour before resuming."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Context compression is presented as the solution to long sessions, allowing you to \"transport\" your progress into a fresh, performant session."
                                                             },
                                                             {
                                                                 "question":  "What is the primary purpose of using memory files like DECISIONS.md and PATTERNS.md?",
                                                                 "options":  {
                                                                                 "a":  "To make the project directory more cluttered.",
                                                                                 "b":  "To document key decisions and code conventions so that this critical context persists across different AI sessions.",
                                                                                 "c":  "They serve as the main source code for the application.",
                                                                                 "d":  "To log every error that occurs during development."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that memory files solve the problem of the AI \"forgetting\" what was decided in previous sessions by creating a persistent record."
                                                             },
                                                             {
                                                                 "question":  "Which of the \u00275-Point Context Health Check\u0027 questions helps you identify if you are loading irrelevant information?",
                                                                 "options":  {
                                                                                 "a":  "Context Fill Level",
                                                                                 "b":  "Context Relevance",
                                                                                 "c":  "Context Recency",
                                                                                 "d":  "Context Clarity"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \u0027Context Relevance\u0027 check specifically asks, \u0027Is everything in context relevant to current task?\u0027 to diagnose if you are loading unnecessary files."
                                                             },
                                                             {
                                                                 "question":  "What is the key difference between the \u0027code-first\u0027 (old) way of thinking and the \u0027context-first\u0027 (new) way of thinking?",
                                                                 "options":  {
                                                                                 "a":  "The code-first approach is faster for all projects.",
                                                                                 "b":  "In the context-first approach, a developer immediately starts coding. In the code-first approach, they plan first.",
                                                                                 "c":  "In the context-first approach, a developer\u0027s first step is to understand the project context before writing a specification or code.",
                                                                                 "d":  "There is no difference."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explicitly contrasts the two: code-first is \u0027I\u0027ll just start coding,\u0027 while context-first is \u0027First, what context do I need?\u0027"
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  82,
                                           "chapter_title":  "Why UV? Understanding Modern Python Package Management",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary problem in the Python tooling landscape that UV aims to solve?",
                                                                 "options":  {
                                                                                 "a":  "There are not enough package managers to choose from.",
                                                                                 "b":  "The existing tools are too fast.",
                                                                                 "c":  "The ecosystem is fragmented with multiple, often incompatible, tools for managing dependencies and environments (pip, venv, poetry, etc.).",
                                                                                 "d":  "Python packages are not available for download."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter highlights \"Python\u0027s Fragmented Tooling Landscape\" as the core problem, listing pip, venv, poetry, and conda as different tools that UV unifies."
                                                             },
                                                             {
                                                                 "question":  "What is the main reason for UV\u0027s significant speed advantage (10-100x faster) over traditional tools like pip?",
                                                                 "options":  {
                                                                                 "a":  "It is written in Python, which is a very fast language.",
                                                                                 "b":  "It downloads packages from a faster, private server.",
                                                                                 "c":  "It is written in Rust and uses parallel dependency resolution and efficient caching.",
                                                                                 "d":  "It installs fewer dependencies for each package."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains, \"UV is written in Rust,\" and leverages \"Parallel dependency resolution\" and \"Efficient caching\" for its speed."
                                                             },
                                                             {
                                                                 "question":  "How does UV handle virtual environments differently from the traditional python -m venv .venv and source .venv/bin/activate workflow?",
                                                                 "options":  {
                                                                                 "a":  "UV does not use virtual environments.",
                                                                                 "b":  "UV requires you to manually activate the environment before every command.",
                                                                                 "c":  "UV automatically creates and uses a project-specific virtual environment without needing manual activation commands.",
                                                                                 "d":  "UV uses a single global environment for all projects."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text emphasizes, \"You never manually activate virtual environments with UV. It automatically creates and uses a project-specific environment.\""
                                                             },
                                                             {
                                                                 "question":  "According to the decision framework, when is it recommended to use conda instead of UV?",
                                                                 "options":  {
                                                                                 "a":  "For all new web application projects.",
                                                                                 "b":  "For data science projects that require non-Python dependencies like CUDA or R libraries.",
                                                                                 "c":  "For publishing a library to PyPI.",
                                                                                 "d":  "For quick, simple scripts."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The table explicitly recommends conda for \"Data science project with specialized packages\" because it \"Handles non-Python dependencies.\""
                                                             },
                                                             {
                                                                 "question":  "What is the core principle of the AI-driven approach to learning UV taught in this book?",
                                                                 "options":  {
                                                                                 "a":  "Memorizing all uv commands and their flags.",
                                                                                 "b":  "Understanding the core concepts of package management and using AI to handle the specific command syntax.",
                                                                                 "c":  "Avoiding the use of AI and figuring everything out from documentation.",
                                                                                 "d":  "Only using the graphical user interface for UV."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts the traditional approach of memorization with the AI-driven approach of understanding concepts, expressing intent, and letting AI generate commands."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  83,
                                           "chapter_title":  "Installing UV with AI Collaboration",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the three conceptual things that happen during a command-line tool installation like UV\u0027s?",
                                                                 "options":  {
                                                                                 "a":  "Your computer is formatted, the OS is reinstalled, and your files are deleted.",
                                                                                 "b":  "A license key is purchased, a user account is created, and a subscription is activated.",
                                                                                 "c":  "The program is downloaded, it\u0027s placed in a standard location, and the system\u0027s PATH is modified.",
                                                                                 "d":  "The code is compiled, linked against libraries, and a desktop shortcut is created."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter breaks down the process into three steps: \"1. Download... 2. Extract and Place... 3. PATH Modification.\""
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the PATH environment variable?",
                                                                 "options":  {
                                                                                 "a":  "To store your project\u0027s source code.",
                                                                                 "b":  "To act as a registry of directories that your system searches to find executable programs.",
                                                                                 "c":  "To keep a history of every command you have ever run.",
                                                                                 "d":  "To define the visual theme of your terminal."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text explains, \"Think of PATH as your computer\u0027s command registry�a list of directories where your system looks for programs when you type a command.\""
                                                             },
                                                             {
                                                                 "question":  "What is the recommended AI-native way to install UV on your specific operating system?",
                                                                 "options":  {
                                                                                 "a":  "To search Google for the correct command and copy-paste it without understanding it.",
                                                                                 "b":  "To ask your AI companion for the platform-specific command, an explanation of what it does, and verification steps.",
                                                                                 "c":  "To guess the command based on other installers you have used.",
                                                                                 "d":  "To download the source code and compile it yourself."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"AI-Driven Installation Workflow\" section guides the user to ask the AI for the command and an explanation, emphasizing understanding over memorization."
                                                             },
                                                             {
                                                                 "question":  "If you run uv --version after installation and get a \"command not found\" error, what is the most likely cause and the first troubleshooting step?",
                                                                 "options":  {
                                                                                 "a":  "Your internet is down; you should check your connection.",
                                                                                 "b":  "The UV installation failed completely; you must delete everything and start over.",
                                                                                 "c":  "The installation worked, but your current terminal session hasn\u0027t reloaded the updated PATH variable; you should restart the terminal.",
                                                                                 "d":  "You don\u0027t have administrator privileges."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The troubleshooting section identifies \"PATH Not Updated in Current Session\" as the first and most common issue, with the solution being to \"Restart your terminal.\""
                                                             },
                                                             {
                                                                 "question":  "Why does the UV installer typically place the executable in a user-profile directory (like ~/.local/bin/) instead of a system-wide directory?",
                                                                 "options":  {
                                                                                 "a":  "Because user directories are faster and more performant.",
                                                                                 "b":  "So that the installation does not require administrator/sudo privileges and does not affect other users on the same machine.",
                                                                                 "c":  "To make the program harder to find and use.",
                                                                                 "d":  "This is an error; it should always be installed in a system-wide directory."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains the benefits of user-directory installation: \"No admin/sudo privileges needed\" and \"Your installation doesn\u0027t affect other users.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  84,
                                           "chapter_title":  "Creating Your First UV Project with AI",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What are the three essential components of a professionally structured Python project as described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "A single Python script, a text file for notes, and a folder for images.",
                                                                                 "b":  "Configuration (pyproject.toml), Code (src/), and an isolated Environment (.venv/).",
                                                                                 "c":  "A Jupyter notebook, a CSV file, and a plot image.",
                                                                                 "d":  "A main.py file, a LICENSE file, and a .git directory."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson opens by defining a Python project with these three components: \"1. Configuration... 2. Code... 3. Environment...\""
                                                             },
                                                             {
                                                                 "question":  "What is the primary role of the pyproject.toml file in a modern Python project?",
                                                                 "options":  {
                                                                                 "a":  "It contains the main Python source code for the application.",
                                                                                 "b":  "It is a lockfile that pins the exact versions of all dependencies.",
                                                                                 "c":  "It is the central project configuration file that specifies metadata, dependencies, and build settings.",
                                                                                 "d":  "It is a script for activating the virtual environment."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Anatomy of a UV Project\" section describes pyproject.toml as the \"Project configuration file\" containing metadata, dependencies, and build settings."
                                                             },
                                                             {
                                                                 "question":  "What does the uv run command do that makes it different from just running python script.py?",
                                                                 "options":  {
                                                                                 "a":  "It runs the script with administrator privileges.",
                                                                                 "b":  "It automatically detects and uses the project\u0027s isolated virtual environment (.venv/) without requiring manual activation.",
                                                                                 "c":  "It compiles the Python script to a faster executable before running it.",
                                                                                 "d":  "It only runs the script if it has no errors."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"UV Auto-Activation\" section explains that uv run handles environment activation automatically, whereas a plain python command would use the global environment."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the uv.lock file?",
                                                                 "options":  {
                                                                                 "a":  "To list the high-level dependencies that the developer wants for the project.",
                                                                                 "b":  "To prevent other developers from making changes to the project.",
                                                                                 "c":  "To record the exact versions of every package and sub-dependency installed, ensuring reproducible environments.",
                                                                                 "d":  "To store secret API keys and passwords."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter states that the lockfile \"records exact versions of every package installed\" and \"Guarantees reproducible environments.\""
                                                             },
                                                             {
                                                                 "question":  "Why do modern Python projects use a src/ layout for code?",
                                                                 "options":  {
                                                                                 "a":  "It is the only folder name that Python recognizes.",
                                                                                 "b":  "It is a best practice that helps prevent common import problems and clearly separates project code from configuration files.",
                                                                                 "c":  "It is a legacy requirement from older Python versions.",
                                                                                 "d":  "To make the project directory structure more complex."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text notes that UV \"uses a src/ layout (best practice for Python projects) instead of putting code in the project root,\" which is a standard convention for ensuring clean and reliable imports."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  85,
                                           "chapter_title":  "Managing Dependencies with AI",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the difference between a \"production dependency\" and a \"development dependency\"?",
                                                                 "options":  {
                                                                                 "a":  "Production dependencies are paid, while development dependencies are free.",
                                                                                 "b":  "A production dependency is needed for the application to run, while a development dependency is only needed for tasks like testing and linting.",
                                                                                 "c":  "There is no difference; all dependencies are treated the same.",
                                                                                 "d":  "Production dependencies are more secure than development dependencies."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines production dependencies as what \"your application needs to run in production\" and development dependencies as what \"developers need for building/testing.\""
                                                             },
                                                             {
                                                                 "question":  "How do you add a package like pytest as a development-only dependency using UV?",
                                                                 "options":  {
                                                                                 "a":  "uv add pytest --production",
                                                                                 "b":  "uv install --dev pytest",
                                                                                 "c":  "uv add --dev pytest",
                                                                                 "d":  "uv require --test pytest"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The lesson shows the specific command: uv add --dev pytest pytest-cov, explaining that the --dev flag marks it as a development dependency."
                                                             },
                                                             {
                                                                 "question":  "What are \"transitive dependencies\"?",
                                                                 "options":  {
                                                                                 "a":  "Dependencies that are outdated and need to be updated.",
                                                                                 "b":  "The dependencies of your dependencies, which are installed automatically by the package manager.",
                                                                                 "c":  "Dependencies that are used for testing only.",
                                                                                 "d":  "Dependencies that are optional for the project to run."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines them with an example: \"You add requests... requests depends on certifi, urllib3... UV automatically installs all five.\""
                                                             },
                                                             {
                                                                 "question":  "If you see a \"dependency conflict\" error, what does it mean?",
                                                                 "options":  {
                                                                                 "a":  "You have installed too many packages.",
                                                                                 "b":  "Two or more packages in your project require incompatible versions of a shared dependency.",
                                                                                 "c":  "You have a typo in your pyproject.toml file.",
                                                                                 "d":  "The package you are trying to install does not exist."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Understanding Conflicts\" section describes a scenario where package-a requires shared-lib\u003e=3.0 and package-b requires shared-lib\u003c3.0, creating a conflict that has no solution."
                                                             },
                                                             {
                                                                 "question":  "What is the primary role of the uv.lock file in a team setting?",
                                                                 "options":  {
                                                                                 "a":  "To provide a human-readable list of desired packages.",
                                                                                 "b":  "To ensure that every team member who runs uv sync gets the exact same versions of all dependencies, creating a reproducible environment.",
                                                                                 "c":  "To document the project\u0027s features.",
                                                                                 "d":  "To prevent anyone else on the team from changing dependencies."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter emphasizes that the lockfile\u0027s purpose is \"Reproducibility,\" ensuring that when a teammate runs uv sync, they get an \"Identical environment to original developer.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  86,
                                           "chapter_title":  "Running Python Code in UV Projects with AI",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "In a UV-managed project, what is the correct command to run a Python script named main.py?",
                                                                 "options":  {
                                                                                 "a":  "python main.py",
                                                                                 "b":  "uv run main.py",
                                                                                 "c":  "source .venv/bin/activate \u0026\u0026 python main.py",
                                                                                 "d":  "uv python main.py"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts the traditional workflow with the UV workflow, showing uv run script.py as the correct, automatic method."
                                                             },
                                                             {
                                                                 "question":  "What does the uv run command do automatically?",
                                                                 "options":  {
                                                                                 "a":  "It deletes the virtual environment after the script finishes.",
                                                                                 "b":  "It activates the project\u0027s isolated virtual environment (.venv/) for the command and deactivates it afterward.",
                                                                                 "c":  "It installs all the latest versions of the dependencies before running the script.",
                                                                                 "d":  "It runs the script using the global system-wide Python installation."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text lists the steps uv run performs, including \"Activates temporarily\" and \"Deactivates automatically.\""
                                                             },
                                                             {
                                                                 "question":  "If you run a Python script and get a ModuleNotFoundError: No module named \u0027pandas\u0027, what is the most likely cause and solution in a UV project?",
                                                                 "options":  {
                                                                                 "a":  "The Python installation is broken; you need to reinstall Python.",
                                                                                 "b":  "The pandas package is not listed as a dependency in pyproject.toml and installed in the virtual environment; the fix is to run uv add pandas.",
                                                                                 "c":  "You have a syntax error in your script.",
                                                                                 "d":  "You should run the script with sudo to fix permission issues."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The troubleshooting section explicitly covers this error, explaining the cause is a missing dependency and the solution is uv add \u003cpackage\u003e."
                                                             },
                                                             {
                                                                 "question":  "How would you run your pytest test suite in a UV project?",
                                                                 "options":  {
                                                                                 "a":  "python -m pytest",
                                                                                 "b":  "pytest",
                                                                                 "c":  "uv run pytest",
                                                                                 "d":  "uv test"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The section on running tests shows the command uv run pytest and explains that UV will use the pytest executable from within the virtual environment."
                                                             },
                                                             {
                                                                 "question":  "Why would running python src/my_script.py fail with an import error, while uv run src/my_script.py works perfectly?",
                                                                 "options":  {
                                                                                 "a":  "Because uv run has a special flag to ignore all import errors.",
                                                                                 "b":  "Because the python command is an old, deprecated version.",
                                                                                 "c":  "Because the plain python command uses the global Python environment which may not have the required packages, whereas uv run uses the project\u0027s isolated .venv/ where the packages are installed.",
                                                                                 "d":  "Because the script has a typo that only uv run can fix automatically."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Comparing uv run vs. Regular python\" section provides a side-by-side experiment demonstrating this exact scenario, showing that one fails with a ModuleNotFoundError while the other succeeds."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  87,
                                           "chapter_title":  "Team Collaboration and Reproducible Environments with AI",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the \"works on my machine\" problem, and how do lockfiles solve it?",
                                                                 "options":  {
                                                                                 "a":  "It\u0027s when code works for one developer but fails for a teammate because they have different dependency versions; lockfiles solve this by ensuring everyone installs the exact same versions.",
                                                                                 "b":  "It\u0027s a hardware issue with a specific computer.",
                                                                                 "c":  "It\u0027s when a developer forgets to save their files.",
                                                                                 "d":  "Lockfiles cause this problem by locking the code to one machine."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "The chapter introduces the \"works on my machine\" problem with a scenario where different developers have different package versions. It then presents lockfiles as the solution for creating \"Identical environments, identical behavior.\""
                                                             },
                                                             {
                                                                 "question":  "When a teammate clones a UV project from Git, what is the single command they need to run to install all the correct dependencies and set up their environment?",
                                                                 "options":  {
                                                                                 "a":  "uv install",
                                                                                 "b":  "pip install -r requirements.txt",
                                                                                 "c":  "uv sync",
                                                                                 "d":  "uv add --all"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Teammate Setup Flow\" section explains that the new developer runs uv sync, which \"Reads uv.lock... Creates .venv/... Installs all packages with exact versions...\""
                                                             },
                                                             {
                                                                 "question":  "Which two files are essential to commit to Git to ensure a reproducible environment for your team?",
                                                                 "options":  {
                                                                                 "a":  ".venv/ and src/",
                                                                                 "b":  "pyproject.toml and uv.lock",
                                                                                 "c":  "README.md and .gitignore",
                                                                                 "d":  "uv.lock and main.py"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explicitly states to \"Always commit both: pyproject.toml (your dependency specifications) and uv.lock (exact versions for reproducibility).\""
                                                             },
                                                             {
                                                                 "question":  "When deploying an application to a production server, what command should you use to install only the necessary runtime dependencies and exclude development tools like pytest?",
                                                                 "options":  {
                                                                                 "a":  "uv sync",
                                                                                 "b":  "uv sync --production",
                                                                                 "c":  "uv sync --no-dev",
                                                                                 "d":  "uv add --prod"
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Production Deployments\" section shows the command uv sync --no-dev and explains that it \"Installs only packages in [project.dependencies] section\" and \"Skips packages in... dev group.\""
                                                             },
                                                             {
                                                                 "question":  "If you manually edit pyproject.toml to change a dependency\u0027s version constraint, and uv.lock is now out of sync, what command can you run to regenerate the lockfile?",
                                                                 "options":  {
                                                                                 "a":  "You must delete the uv.lock file and start over.",
                                                                                 "b":  "uv add \u003cpackage\u003e for every package.",
                                                                                 "c":  "uv lock --upgrade",
                                                                                 "d":  "The lockfile cannot be regenerated."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Under \"Lockfile Maintenance,\" the text says if you manually edit pyproject.toml, you should run uv lock --upgrade to regenerate the lockfile."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  88,
                                           "chapter_title":  "What is Python and Why AIDD Needs It",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "Which of the following best describes Python?",
                                                                 "options":  {
                                                                                 "a":  "A low-level language that requires manual memory management.",
                                                                                 "b":  "A high-level, readable, interpreted programming language.",
                                                                                 "c":  "A language used exclusively for creating web pages.",
                                                                                 "d":  "A compiled language that is difficult for beginners to learn."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines Python as a \"high-level, readable, interpreted programming language\" and explains what each of those terms means."
                                                             },
                                                             {
                                                                 "question":  "What is the primary reason Python became the dominant language for AI development?",
                                                                 "options":  {
                                                                                 "a":  "It was the fastest language available.",
                                                                                 "b":  "It was the only language with a large community.",
                                                                                 "c":  "Its readability and clarity made it ideal for large, collaborative research teams working on complex systems.",
                                                                                 "d":  "It was created by Google specifically for AI."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains that Python won in AI because \"readability mattered more than raw speed\" and \"in AI development, human understanding beats machine speed.\""
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of \"type hints\" in modern Python (e.g., name: str)?",
                                                                 "options":  {
                                                                                 "a":  "They are comments that the Python interpreter ignores.",
                                                                                 "b":  "They are a way to declare what type of data a variable is expected to hold, making the code clearer and acting as a form of embedded specification.",
                                                                                 "c":  "They automatically convert data from one type to another.",
                                                                                 "d":  "They are only used for printing text to the screen."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text states, \"The : str tells us that name will be text data.\" and calls them \"specifications embedded in code.\""
                                                             },
                                                             {
                                                                 "question":  "The chapter states that \"Python code reads almost like a specification.\" Why is this important for AI-Driven Development (AIDD)?",
                                                                 "options":  {
                                                                                 "a":  "It makes the code more difficult for the AI to understand.",
                                                                                 "b":  "It allows developers to validate AI-generated code easily because the code\u0027s intent is clear and matches the original specification.",
                                                                                 "c":  "It means you no longer need to write separate specification documents.",
                                                                                 "d":  "It is not important; readability is just a matter of personal preference."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter connects readability to validation: \"When you ask Claude Code to generate Python code, you can read and validate it immediately... This is crucial for AI partnership.\""
                                                             },
                                                             {
                                                                 "question":  "What is an \"interpreted\" language?",
                                                                 "options":  {
                                                                                 "a":  "A language that must be compiled into machine code before it can be run.",
                                                                                 "b":  "A language that can be written and executed immediately without a separate compilation step.",
                                                                                 "c":  "A language that can only be understood by AI.",
                                                                                 "d":  "A language that is translated into multiple other languages automatically."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines interpreted as meaning \"Python code doesn\u0027t need to be compiled... You can write Python code and execute it immediately.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  89,
                                           "chapter_title":  "Installing Python and Setting Up Your Environment",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "When installing Python on Windows, what is the critical checkbox you must check in the installer?",
                                                                 "options":  {
                                                                                 "a":  "Install for all users.",
                                                                                 "b":  "Create desktop shortcuts.",
                                                                                 "c":  "Add Python 3.14 to PATH.",
                                                                                 "d":  "Install debugging symbols."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter highlights this as a \"Critical Step,\" explaining that it \"tells Windows where to find Python when you type commands.\""
                                                             },
                                                             {
                                                                 "question":  "After installing Python, what command should you run in your terminal to verify that the installation was successful?",
                                                                 "options":  {
                                                                                 "a":  "python --run",
                                                                                 "b":  "python --version (or python3 --version on macOS/Linux)",
                                                                                 "c":  "python install --verify",
                                                                                 "d":  "python check"
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Verify Installation\" step for all operating systems instructs the user to run python --version or python3 --version."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the PATH environment variable?",
                                                                 "options":  {
                                                                                 "a":  "It stores the path to your current project folder.",
                                                                                 "b":  "It is a list of directories your system searches to find executable programs when you type a command.",
                                                                                 "c":  "It is a security feature that prevents unauthorized programs from running.",
                                                                                 "d":  "It is a variable that stores your Python code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \"Think of PATH as your computer\u0027s command registry�a list of directories where your system looks for programs...\""
                                                             },
                                                             {
                                                                 "question":  "If you type python --version and get a \"command not found\" error, what is the most likely problem?",
                                                                 "options":  {
                                                                                 "a":  "Your computer does not have enough memory to run Python.",
                                                                                 "b":  "The Python installation directory was not correctly added to your system\u0027s PATH.",
                                                                                 "c":  "You have a typo in the word \"python\".",
                                                                                 "d":  "Python is not compatible with your operating system."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The troubleshooting section explains that this error means \"UV is installed but not in your PATH, or your current terminal session hasn\u0027t reloaded PATH yet.\" The same logic applies to the Python installation itself."
                                                             },
                                                             {
                                                                 "question":  "What is the recommended way to install Python on macOS if you already have Homebrew installed?",
                                                                 "options":  {
                                                                                 "a":  "Download the installer from python.org.",
                                                                                 "b":  "Run the command brew install python@3.14.",
                                                                                 "c":  "Build Python from source code.",
                                                                                 "d":  "Use the version of Python that comes with macOS."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter presents Homebrew as the recommended method for macOS users who have it, providing the command brew install python@3.14."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  90,
                                           "chapter_title":  "Your First Program",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What does the print(\"Hello, World!\") command do in Python?",
                                                                 "options":  {
                                                                                 "a":  "It saves the text \"Hello, World!\" to a file.",
                                                                                 "b":  "It displays the text \"Hello, World!\" on the screen.",
                                                                                 "c":  "It asks the user to type \"Hello, World!\".",
                                                                                 "d":  "It checks if the text \"Hello, World!\" exists on the computer."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that this program \"prints the text \u0027Hello, World!\u0027 to the screen.\""
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of the input() function in Python?",
                                                                 "options":  {
                                                                                 "a":  "To display text to the user.",
                                                                                 "b":  "To pause the program and wait for the user to type something.",
                                                                                 "c":  "To import other Python files.",
                                                                                 "d":  "To calculate a mathematical result."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text describes the input() function as asking the user a question and \"waits for them to type something.\""
                                                             },
                                                             {
                                                                 "question":  "What is the fundamental pattern of all programs described in the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Input ? Processing ? Output.",
                                                                                 "b":  "Start ? End.",
                                                                                 "c":  "Read ? Write ? Delete.",
                                                                                 "d":  "Define ? Call ? Return."
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "After the first complete program example, the chapter concludes, \"This is the fundamental pattern of all programs: input ? processing ? output.\""
                                                             },
                                                             {
                                                                 "question":  "What does the f before a string (e.g., f\"Hello, {name}\") signify in modern Python?",
                                                                 "options":  {
                                                                                 "a":  "It stands for \"file\" and saves the string to a file.",
                                                                                 "b":  "It stands for \"format\" and creates an f-string, which makes it easy to embed variables directly into the string.",
                                                                                 "c":  "It stands for \"function\" and turns the string into a callable function.",
                                                                                 "d":  "It is a comment and has no effect on the code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains that \"the f before quotes lets us insert variables easily\" and calls it an \"f-string.\""
                                                             },
                                                             {
                                                                 "question":  "Why are type hints (like : str) considered a form of \"specification embedded in code\"?",
                                                                 "options":  {
                                                                                 "a":  "Because they are required for the code to run.",
                                                                                 "b":  "Because they document the programmer\u0027s intent, telling both humans and AI what type of data a variable is expected to hold.",
                                                                                 "c":  "Because they automatically convert the data to the specified type.",
                                                                                 "d":  "Because they are only used in specification documents, not in actual code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \"The : str tells anyone reading this code: \u0027The variable name will hold text data.\u0027 This is a specification embedded in code�it documents your intent.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  91,
                                           "chapter_title":  "Thinking Like an AI-First Developer",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the core difference between the \"Code-First\" approach and the \"Specification-First\" approach?",
                                                                 "options":  {
                                                                                 "a":  "Code-First is faster for all projects.",
                                                                                 "b":  "Specification-First involves writing a clear plan or \"intent\" before writing any code.",
                                                                                 "c":  "Only senior developers use the Specification-First approach.",
                                                                                 "d":  "The Code-First approach does not involve any testing."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter contrasts the two, stating that the Specification-First approach begins with \"Write what you want (specification)\" before any code is generated."
                                                             },
                                                             {
                                                                 "question":  "In the \"Specification ? AI ? Validation\" pattern, what is the developer\u0027s role in the \"Validation\" phase?",
                                                                 "options":  {
                                                                                 "a":  "To blindly accept the code generated by the AI.",
                                                                                 "b":  "To check if the AI-generated code correctly matches the original specification.",
                                                                                 "c":  "To rewrite the entire code from scratch.",
                                                                                 "d":  "To ask the AI to validate its own code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The \"Phase 4: You Validate\" section describes the process: \"Now you check: Does the code match my specification?\""
                                                             },
                                                             {
                                                                 "question":  "Why is the Specification-First pattern particularly effective when working with an AI partner?",
                                                                 "options":  {
                                                                                 "a":  "Because AI partners are best at guessing what the developer wants.",
                                                                                 "b":  "Because it forces the developer to think clearly, and a clear specification allows the AI to generate accurate code that matches the developer\u0027s intent.",
                                                                                 "c":  "Because AI partners can only understand code, not plain language specifications.",
                                                                                 "d":  "Because this pattern makes the AI generate more creative and unpredictable code."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter explains, \"When you write the specification first, you\u0027re forced to think clearly... When you then see code that implements your thought, you understand it because it matches your intent exactly.\""
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, why is it important to learn the Specification-First pattern from the very beginning?",
                                                                 "options":  {
                                                                                 "a":  "Because it is the only way to write Python code.",
                                                                                 "b":  "Because habits formed with small programs persist, and learning this professional pattern early makes it natural.",
                                                                                 "c":  "Because the Code-First approach is more difficult for beginners.",
                                                                                 "d":  "Because AI tools will not work without a specification."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The text argues, \"The book starts teaching this pattern NOW because habits formed with small programs persist. If you learn specification-first from your first program, it becomes natural.\""
                                                             },
                                                             {
                                                                 "question":  "What is the most valuable professional skill in the AI-native world, according to the chapter?",
                                                                 "options":  {
                                                                                 "a":  "Typing code faster than anyone else.",
                                                                                 "b":  "Memorizing the syntax of many programming languages.",
                                                                                 "c":  "Thinking clearly about what you want to build and capturing that clarity in specifications.",
                                                                                 "d":  "Being able to debug code without any assistance."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter concludes, \"The professional skill that makes you valuable in an AI-native world isn\u0027t typing code faster. It\u0027s thinking more clearly about what you want to build. That clarity�captured in specifications�is how you partner effectively with AI.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  92,
                                           "chapter_title":  "Vague Code and the AI Partner Problem",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the core problem with \"vibe coding\" when working with an AI coding agent?",
                                                                 "options":  {
                                                                                 "a":  "It is too slow and requires too much planning upfront.",
                                                                                 "b":  "The AI agent has no ability to infer unstated requirements, so it builds exactly what was vaguely described, leading to incomplete or incorrect features.",
                                                                                 "c":  "It only works for very large, complex projects.",
                                                                                 "d":  "AI agents refuse to work with vague, conversational prompts."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter highlights that the AI is a \"literal-minded pair programmer\" that \"can only work from what you explicitly stated,\" which is the root of the problem with vague prompts."
                                                             },
                                                             {
                                                                 "question":  "In the login system example, what was the user\u0027s incorrect assumption?",
                                                                 "options":  {
                                                                                 "a":  "That the AI would ask for more details before starting.",
                                                                                 "b":  "That features like password reset and email verification are \"obvious\" and implied in a request for a \"login system.\"",
                                                                                 "c":  "That the AI would automatically use the most secure password hashing method.",
                                                                                 "d":  "That the login system would be written in JavaScript instead of Python."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states: \"You assumed a login system obviously includes password reset. You didn\u0027t spell it out because it seemed implied.\""
                                                             },
                                                             {
                                                                 "question":  "What is the main cost of providing vague specifications to an AI agent?",
                                                                 "options":  {
                                                                                 "a":  "It uses significantly more API credits because the prompts are longer.",
                                                                                 "b":  "It forces the developer to learn a new programming language.",
                                                                                 "c":  "It leads to a long and frustrating cycle of iterations, debugging, and refactoring to fix all the things the AI missed.",
                                                                                 "d":  "It produces code that is syntactically incorrect and will not run."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Cost of Vagueness\" section calculates the total time, showing that multiple iterations to add missing features can turn a 4-hour task into a 20-hour one."
                                                             },
                                                             {
                                                                 "question":  "What is the proposed solution to the \"vibe coding\" problem?",
                                                                 "options":  {
                                                                                 "a":  "To use a more advanced AI model that can read the developer\u0027s mind.",
                                                                                 "b":  "To abandon AI and write all code manually.",
                                                                                 "c":  "To collaborate with the AI to create a clear, detailed specification before generating any code.",
                                                                                 "d":  "To provide the AI with hundreds of examples of login systems."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter\u0027s solution is to \"collaborate on Clear Specifications,\" where the developer and AI work together to define requirements upfront."
                                                             },
                                                             {
                                                                 "question":  "How does an AI companion help in creating a better specification?",
                                                                 "options":  {
                                                                                 "a":  "By writing the entire specification for you without any input.",
                                                                                 "b":  "By refusing to generate code until the specification is perfect.",
                                                                                 "c":  "By asking clarifying questions, identifying edge cases, and suggesting best practices that the developer might have missed.",
                                                                                 "d":  "By providing a single, unchangeable template for all specifications."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The \"Key insight\" section explains that AI helps write better specs by \"Asking clarifying questions,\" \"Identifying edge cases,\" and \"Suggesting standard patterns.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  93,
                                           "chapter_title":  "What Is Specification-Driven Development?",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the core definition of Specification-Driven Development (SDD)?",
                                                                 "options":  {
                                                                                 "a":  "A methodology where documentation is written after the code is finished.",
                                                                                 "b":  "A process of writing very long and detailed prompts for an AI.",
                                                                                 "c":  "A methodology where a structured, machine-readable specification is created first, acting as a contract for code generation and validation.",
                                                                                 "d":  "A set of tools for automatically debugging code."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines SDD as a methodology where \"development begins with a specification � a structured, machine-readable description of how the code should behave.\""
                                                             },
                                                             {
                                                                 "question":  "Which of the following is NOT a characteristic of a \"Real SDD\" approach?",
                                                                 "options":  {
                                                                                 "a":  "Using structured artifacts that follow a consistent pattern.",
                                                                                 "b":  "Being behavior-oriented, focusing on what the system should do.",
                                                                                 "c":  "The specification is used once as an initial prompt and then discarded.",
                                                                                 "d":  "The specification acts as a source of truth throughout the development process."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists \"Source of truth\" as a key characteristic, meaning the spec is authoritative throughout development, not just a one-time input."
                                                             },
                                                             {
                                                                 "question":  "What is the main difference between \"Memory Banks\" (or Constitutions) and \"Specs\"?",
                                                                 "options":  {
                                                                                 "a":  "Specs are permanent rules, while memory banks are for specific features.",
                                                                                 "b":  "Memory banks are for storing code, while specs are for storing documentation.",
                                                                                 "c":  "Memory banks contain permanent, system-wide rules, while specs are for specific features or changes.",
                                                                                 "d":  "There is no difference; the terms are interchangeable."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "A comparison table explicitly states that memory banks have a \"codebase\" scope and are \"Permanent,\" while specs have a \"feature/change\" scope and are \"Temporary.\""
                                                             },
                                                             {
                                                                 "question":  "In an SDD workflow where an AI agent is a partner, what is the role of the specification?",
                                                                 "options":  {
                                                                                 "a":  "It is a suggestion that the AI can choose to ignore.",
                                                                                 "b":  "It is a secondary document created after the code is complete.",
                                                                                 "c":  "It is the primary interface and an \"executable contract\" that drives the AI\u0027s code generation and validation.",
                                                                                 "d":  "It is a manual for the end-user of the software."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter states, \"it is an executable contract that drives the entire development lifecycle,\" and later, that \"specs become the primary interface for AI collaboration.\""
                                                             },
                                                             {
                                                                 "question":  "What does the \"Spec-as-source\" implementation level of SDD imply?",
                                                                 "options":  {
                                                                                 "a":  "The spec is written first and then used to guide manual coding.",
                                                                                 "b":  "The spec is kept alongside the code for documentation purposes.",
                                                                                 "c":  "The spec is the only artifact that the human developer edits; the code is always regenerated from the spec.",
                                                                                 "d":  "The source code is converted into a spec automatically."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter defines \"Spec-as-source\" as the level where \"only the spec is edited by the human; the human never touches the code.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  94,
                                           "chapter_title":  "Build Your First Spec: Basic Calculator",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the first step in the spec-first workflow presented in the lesson?",
                                                                 "options":  {
                                                                                 "a":  "Writing Acceptance Criteria.",
                                                                                 "b":  "Writing User Stories to express what the user wants to accomplish.",
                                                                                 "c":  "Writing the Python code for the calculator.",
                                                                                 "d":  "Identifying edge cases and error conditions."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson outlines the workflow as starting with \"1. USER STORIES ? Express what users want to do.\""
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of writing \"Acceptance Criteria\" in the BDD format (GIVEN/WHEN/THEN)?",
                                                                 "options":  {
                                                                                 "a":  "To provide a high-level, vague idea of the feature.",
                                                                                 "b":  "To define specific, testable conditions that must be true for a user story to be considered \"done.\"",
                                                                                 "c":  "To list the developers who will be working on the feature.",
                                                                                 "d":  "To document the history of the project."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter defines acceptance criteria as \"specific conditions that must be true for the story to be \u0027done\u0027.\""
                                                             },
                                                             {
                                                                 "question":  "What kind of issue does the edge case of 0.1 + 0.2 force the developer to specify?",
                                                                 "options":  {
                                                                                 "a":  "How to handle division by zero.",
                                                                                 "b":  "The behavior of negative numbers.",
                                                                                 "c":  "The expected behavior regarding floating-point precision inaccuracies.",
                                                                                 "d":  "The maximum number the calculator can handle."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text notes that this specific case is included \"to document IEEE 754 precision behavior,\" which is a classic floating-point issue."
                                                             },
                                                             {
                                                                 "question":  "According to the lesson, what is the most important role of test scenarios in a specification?",
                                                                 "options":  {
                                                                                 "a":  "They are just suggestions for the QA team.",
                                                                                 "b":  "They define what \"correct\" means in an executable, contractual form.",
                                                                                 "c":  "They are primarily for documenting the \"happy path.\"",
                                                                                 "d":  "They are only necessary for complex mathematical operations."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states, \"The spec isn\u0027t separate from tests; tests ARE the specification in executable form.\""
                                                             },
                                                             {
                                                                 "question":  "What is the \"co-learning\" feedback loop in specification development?",
                                                                 "options":  {
                                                                                 "a":  "A process where the developer writes a perfect spec on the first try.",
                                                                                 "b":  "A cycle where the developer drafts a spec, the AI generates code, the developer validates the output, identifies gaps or ambiguities in the spec, and then refines the spec with the AI\u0027s help.",
                                                                                 "c":  "An AI agent learns from another AI agent.",
                                                                                 "d":  "A process where the code is generated first, and then a spec is written to match it."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The lesson describes the feedback loop as: Spec ? Generate ? Validate ? Refine Spec. It notes that an AI generating wrong code indicates an ambiguous spec, which is a learning opportunity."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  95,
                                           "chapter_title":  "Your Team Needs Shared Rules: Memory Banks and Constitutions",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary problem that a \"Constitution\" or \"Memory Bank\" solves for a development team?",
                                                                 "options":  {
                                                                                 "a":  "It helps developers write code faster by providing boilerplate templates.",
                                                                                 "b":  "It ensures that every developer on the team follows the same high-level rules for security, architecture, and quality, preventing inconsistency.",
                                                                                 "c":  "It serves as a chat room for team communication.",
                                                                                 "d":  "It automatically generates user stories for new features."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter introduces Constitutions as the solution to the problem where different developers interpret \"secure hashing\" differently, leading to an inconsistent and insecure system."
                                                             },
                                                             {
                                                                 "question":  "What is the key difference between a Specification (Spec) and a Constitution?",
                                                                 "options":  {
                                                                                 "a":  "A spec is a system-wide rule, while a Constitution is for a specific feature.",
                                                                                 "b":  "A Constitution is a system-wide set of rules that rarely changes, while a spec contains the requirements for a single, specific feature.",
                                                                                 "c":  "Specs are written by developers, while Constitutions are written by managers.",
                                                                                 "d":  "There is no difference; the terms are interchangeable."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states: \"Specifications are feature-specific. Constitutions are system-wide.\""
                                                             },
                                                             {
                                                                 "question":  "Which of the following would be an appropriate rule to include in a Constitution?",
                                                                 "options":  {
                                                                                 "a":  "The password reset token must expire in 30 minutes.",
                                                                                 "b":  "ALL user passwords must be hashed with bcrypt (cost factor 12+).",
                                                                                 "c":  "The /users/{id} endpoint should return a user\u0027s name and email.",
                                                                                 "d":  "The color of the login button should be blue."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists ALL passwords hashed with bcrypt as a \"Non-Negotiable\" security rule suitable for a Constitution, whereas the other options are feature-specific implementation details."
                                                             },
                                                             {
                                                                 "question":  "What is the purpose of an Architectural Decision Record (ADR)?",
                                                                 "options":  {
                                                                                 "a":  "To document immutable, permanent rules for the entire system.",
                                                                                 "b":  "To track every prompt and response between a developer and an AI.",
                                                                                 "c":  "To document the \"why\" behind significant, but potentially changeable, architectural choices and their trade-offs.",
                                                                                 "d":  "To list the tasks required to complete a feature."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "ADRs are defined as documenting \"The rationale behind mutable decisions,\" such as \"Why did we choose this approach?\""
                                                             },
                                                             {
                                                                 "question":  "How does having a Constitution and ADRs help AI agents work more effectively?",
                                                                 "options":  {
                                                                                 "a":  "It makes the AI\u0027s job harder because it has to read more documents.",
                                                                                 "b":  "These documents are only for humans; AI agents cannot read them.",
                                                                                 "c":  "They provide the AI with clear, consistent rules and reasoning, so it can make choices that align with the team\u0027s philosophy without having to guess.",
                                                                                 "d":  "They allow the AI to ignore all user-provided specifications."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter explains that when an AI agent faces a choice, it can reference the ADR to understand the team\u0027s philosophy and the Constitution for non-negotiable rules."
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  96,
                                           "chapter_title":  "Ask: Why Do Specs Matter NOW? The AI Moment",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "What is the primary reason that Specification-Driven Development (SDD) is becoming essential now, in 2025, even though specifications have existed for decades?",
                                                                 "options":  {
                                                                                 "a":  "Because developers have only just learned how to write.",
                                                                                 "b":  "Because AI agents are now capable enough to generate correct code from specs, and they are literal-minded, so they need explicit instructions more than humans do.",
                                                                                 "c":  "Because older methodologies like Agile have been proven to be completely ineffective.",
                                                                                 "d":  "Because of a new law requiring all software to have a specification."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter lists three converging forces, primarily that \"AI got good enough to generate production code\" and \"AI agents are literal-minded (need specs more than humans do).\""
                                                             },
                                                             {
                                                                 "question":  "Why did previous attempts at spec-based development, like 1970s Formal Methods, largely fail for mainstream use?",
                                                                 "options":  {
                                                                                 "a":  "They were not written in English.",
                                                                                 "b":  "They were too simple and lacked detail.",
                                                                                 "c":  "They were too rigid, required PhD-level math, and were impractical for normal software development.",
                                                                                 "d":  "The computers of the 1970s were not powerful enough to run the code."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text states that Formal Methods \"Required PhD-level math, impractical for normal software.\""
                                                             },
                                                             {
                                                                 "question":  "How does the current SDD approach, which uses natural language specs, differ from the 2000s Model-Driven Development (MDD) which used UML models?",
                                                                 "options":  {
                                                                                 "a":  "SDD with natural language is more rigid and formal than UML.",
                                                                                 "b":  "SDD with natural language creates more tool lock-in.",
                                                                                 "c":  "SDD with natural language is more flexible, has less tool lock-in, and allows for faster feedback loops with modern LLMs.",
                                                                                 "d":  "There is no difference; MDD and SDD are the same."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The chapter lists several reasons why SDD succeeds where MDD failed, including \"Natural language specs,\" \"Less lock-in,\" and \"Faster feedback.\""
                                                             },
                                                             {
                                                                 "question":  "According to the chapter, what is the key shift in mindset that makes specs so important in the age of AI?",
                                                                 "options":  {
                                                                                 "a":  "Specs are now less important because AI can improvise.",
                                                                                 "b":  "Specs have become the essential interface between humans and literal-minded AI agents, making them mandatory, not optional.",
                                                                                 "c":  "Specs are only for documentation and are not read by the AI.",
                                                                                 "d":  "Writing specs is now slower and more expensive than iterating with vague prompts."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter\u0027s \"Key Shift\" insight is: \"Before AI: Specs were nice but not essential... With AI: Specs became essential (AI can\u0027t improvise).\""
                                                             },
                                                             {
                                                                 "question":  "Besides improving code quality, what is the major \"scalability breakthrough\" that specifications enable for teams?",
                                                                 "options":  {
                                                                                 "a":  "They make the codebase smaller.",
                                                                                 "b":  "They allow team members or AI agents to work on different features independently and in parallel because the interfaces are clearly defined.",
                                                                                 "c":  "They eliminate the need for any meetings.",
                                                                                 "d":  "They automatically translate the code into different programming languages."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter concludes with this insight, explaining that with specs, \"Developer A works on Feature A, Developer B works on Feature B... They integrate at defined interfaces (no constant meetings needed).\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  97,
                                           "chapter_title":  "Which SDD Framework or Tool Fits YOUR Work?",
                                           "skipped":  false,
                                           "questions":  [
                                                             {
                                                                 "question":  "The chapter presents four SDD frameworks. Which framework is described as being the simplest, with low friction, and a good starting point for solo developers?",
                                                                 "options":  {
                                                                                 "a":  "Kiro",
                                                                                 "b":  "Spec-Kit (GitHub)",
                                                                                 "c":  "Spec-Kit Plus (Panaversity)",
                                                                                 "d":  "Tesel"
                                                                             },
                                                                 "correct_answer":  "a",
                                                                 "explanation":  "Kiro is described with the philosophy \"Start Simple\" and is recommended for \"Solo developer or tiny team\" and \"Learning SDD for the first time.\""
                                                             },
                                                             {
                                                                 "question":  "What is the core principle of GitHub\u0027s Spec-Kit framework?",
                                                                 "options":  {
                                                                                 "a":  "That code should be generated automatically and never edited by hand.",
                                                                                 "b":  "A \"Constitution\" of immutable, system-wide rules provides strong governance for all development work.",
                                                                                 "c":  "To have as little documentation as possible.",
                                                                                 "d":  "To track every AI interaction in a detailed log."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "The chapter states that Spec-Kit is \"built around a Constitution � a document of immutable rules that apply to EVERYTHING in your codebase.\""
                                                             },
                                                             {
                                                                 "question":  "How does Spec-Kit Plus extend GitHub\u0027s Spec-Kit?",
                                                                 "options":  {
                                                                                 "a":  "It removes the Constitution to make the process simpler.",
                                                                                 "b":  "It is a completely different framework with no relation to Spec-Kit.",
                                                                                 "c":  "It adds Architectural Decision Records (ADRs), Prompt History Records (PHRs), and domain-specific Intelligence Templates.",
                                                                                 "d":  "It is focused only on writing user stories."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "The text explicitly lists these three additions: \"ADRs (capture architectural \u0027why\u0027)\", \"PHRs (capture AI interaction \u0027how\u0027)\", and \"Intelligence Templates (domain expertise).\""
                                                             },
                                                             {
                                                                 "question":  "According to the \"what to use when\" guide, which framework is most suitable for a team in a regulated domain like healthcare or finance that needs auditable decisions?",
                                                                 "options":  {
                                                                                 "a":  "Kiro",
                                                                                 "b":  "Spec-Kit Plus",
                                                                                 "c":  "The \"no framework\" vibe coding approach.",
                                                                                 "d":  "Tesel (in its current beta stage)."
                                                                             },
                                                                 "correct_answer":  "b",
                                                                 "explanation":  "Spec-Kit Plus is described as an excellent fit for teams \"in a regulated domain\" because its ADRs and PHRs create an \"audit trail for compliance and learning.\""
                                                             },
                                                             {
                                                                 "question":  "What is the defining philosophy of the Tesel framework?",
                                                                 "options":  {
                                                                                 "a":  "To have as little structure as possible.",
                                                                                 "b":  "To focus entirely on writing better prompts.",
                                                                                 "c":  "That the specification is the only source of truth, and the code is always auto-generated from it and never edited by hand.",
                                                                                 "d":  "To use a large number of different files for each feature to ensure traceability."
                                                                             },
                                                                 "correct_answer":  "c",
                                                                 "explanation":  "Tesel is described with the philosophy: \"Specs are the only source of truth. Code is generated, never hand-edited.\""
                                                             }
                                                         ]
                                       },
                                       {
                                           "chapter_id":  98,
                                           "chapter_title":  "Installation \u0026 Setup - AI-Native SDD Toolkit",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the core distinction between Spec-Kit Plus and an AI tool like Claude Code or Gemini CLI?",
                                                                               "options":  {
                                                                                               "a":  "Spec-Kit Plus is a programming language, while AI tools are IDEs.",
                                                                                               "b":  "Spec-Kit Plus is an opinionated methodology framework, while AI tools are the orchestrators that execute its commands and workflow.",
                                                                                               "c":  "Spec-Kit Plus is a hardware component, and AI tools are software.",
                                                                                               "d":  "There is no distinction; they are the same product."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter clarifies that Spec-Kit Plus is an \u0027opinionated methodology framework\u0027 that works with various AI tools, which act as the \u0027main collaborator\u0027 or orchestrator."
                                                                           },
                                                                           {
                                                                               "question":  "What is the purpose of \u0027Horizontal Intelligence\u0027 in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "To manage the AI\u0027s subagents.",
                                                                                               "b":  "To capture decisions and learnings in a permanent, searchable form (like ADRs and PHRs) so future team members can learn from past work.",
                                                                                               "c":  "To execute slash commands.",
                                                                                               "d":  "To generate code automatically."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Horizontal intelligence \u0027captures decisions and learnings in a permanent, searchable form\u0027 through ADRs and PHRs, ensuring knowledge persists across time."
                                                                           },
                                                                           {
                                                                               "question":  "In the \u0027Vertical Intelligence\u0027 architecture, what is the primary role of \u0027YOU\u0027 (the human developer)?",
                                                                               "options":  {
                                                                                               "a":  "To write all the code manually.",
                                                                                               "b":  "To memorize all framework commands and patterns.",
                                                                                               "c":  "To think clearly about intent and validate results, acting as the Architect/Validator.",
                                                                                               "d":  "To train the AI models from scratch."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter states, \u0027Your job is thinking clearly about intent and validating results, not memorizing frameworks,\u0027 positioning the human as the Architect/Validator."
                                                                           },
                                                                           {
                                                                               "question":  "Which command is used to initialize a new Spec-Kit Plus project?",
                                                                               "options":  {
                                                                                               "a":  "pip install specifyplus",
                                                                                               "b":  "specifyplus init \u003cproject-name\u003e",
                                                                                               "c":  "python -m venv .venv",
                                                                                               "d":  "claude init \u003cproject-name\u003e"
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Step 3 of the installation process explicitly states: \u0027specifyplus init calculator-project\u0027 to create a new project."
                                                                           },
                                                                           {
                                                                               "question":  "What is a common mistake beginners make regarding Spec-Kit Plus and AI tools?",
                                                                               "options":  {
                                                                                               "a":  "Assuming Spec-Kit Plus is only for advanced users.",
                                                                                               "b":  "Confusing Spec-Kit Plus (the framework) with Claude Code or Gemini CLI (the AI tool).",
                                                                                               "c":  "Not installing Python 3.12+.",
                                                                                               "d":  "Forgetting to create a .gitignore file."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Mistake 1 is identified as \u0027Confusing Spec-Kit Plus with Claude Code,\u0027 emphasizing that they are separate entities: one is a framework, the other is an AI tool."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  99,
                                           "chapter_title":  "Constitution Phase - Project-Wide Rules",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary purpose of a \u0027Constitution\u0027 in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "To define specific feature requirements for a single task.",
                                                                                               "b":  "To establish immutable, project-wide standards and rules that apply to all features.",
                                                                                               "c":  "To document architectural decisions that are subject to change.",
                                                                                               "d":  "To record the history of AI collaboration sessions."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter defines a Constitution as a document that \u0027defines immutable standards applying to all features in a project,\u0027 serving as a project-wide rulebook."
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u0027cascade\u0027 effect in the context of a project\u0027s Constitution?",
                                                                               "options":  {
                                                                                               "a":  "It refers to the waterfall development model.",
                                                                                               "b":  "It describes how the quality of the Constitution directly impacts the quality of all downstream artifacts (specifications, plans, tasks, code).",
                                                                                               "c":  "It\u0027s a method for automatically generating code from a Constitution.",
                                                                                               "d":  "It\u0027s a process for reverting changes to the Constitution."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter explains the \u0027cascade\u0027 as \u0027Clear Constitution ? Clear Specification ? Clear Plan ? Clear Tasks ? Working Code,\u0027 where a weak Constitution leads to issues in subsequent phases."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following is an example of a rule that belongs in a \u0027Constitution\u0027 rather than a \u0027Specification\u0027?",
                                                                               "options":  {
                                                                                               "a":  "The calculator must support add, subtract, multiply, divide.",
                                                                                               "b":  "Power operation handles negative exponents.",
                                                                                               "c":  "All functions must include type hints on parameters and return types.",
                                                                                               "d":  "Results return float with 6-decimal precision."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The Constitution defines global standards like \u0027All functions must include type hints,\u0027 which apply across the entire project, unlike feature-specific requirements found in a Specification."
                                                                           },
                                                                           {
                                                                               "question":  "What is the recommended best practice regarding committing the Constitution to Git?",
                                                                               "options":  {
                                                                                               "a":  "Commit it after all features are complete.",
                                                                                               "b":  "Commit it only if major changes are made.",
                                                                                               "c":  "Always commit the Constitution before starting any feature work.",
                                                                                               "d":  "Do not commit the Constitution to Git; keep it local."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter emphasizes \u0027Always commit the Constitution before starting feature work\u0027 to ensure immutability, clarity, and traceability."
                                                                           },
                                                                           {
                                                                               "question":  "What is a common mistake when writing a Constitution?",
                                                                               "options":  {
                                                                                               "a":  "Making the rules too specific.",
                                                                                               "b":  "Including too many technical details.",
                                                                                               "c":  "Copying a Constitution from another project without customization, making it irrelevant to the current project.",
                                                                                               "d":  "Not using enough examples in the Constitution."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "Mistake 1 is \u0027Copying Constitution from Another Project Without Customization,\u0027 highlighting that Constitutions are project-specific and need tailored rules."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  100,
                                           "chapter_title":  "Specify Phase - Writing Complete Specifications",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary value of writing a clear specification in AI-native development?",
                                                                               "options":  {
                                                                                               "a":  "It allows the AI to guess what the developer wants.",
                                                                                               "b":  "It is more valuable than writing code, as a bad spec breaks everything downstream.",
                                                                                               "c":  "It is only for documentation purposes after the code is written.",
                                                                                               "d":  "It helps in choosing the programming language."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter states, \u0027your ability to write a clear specification is more valuable than your ability to write code. Bad code can be refactored - but a bad spec breaks everything downstream.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is the purpose of the \u0027pre-specification conversation\u0027 with an AI companion?",
                                                                               "options":  {
                                                                                               "a":  "To generate the entire code automatically.",
                                                                                               "b":  "To formally define technical details and code structure.",
                                                                                               "c":  "To informally clarify success criteria and explore the problem space before writing a formal specification.",
                                                                                               "d":  "To decide on the project\u0027s budget and timeline."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "This informal human-AI conversation \u0027clarifies intent\u0027 and helps \u0027explore the problem space\u0027 to build a Specification V0, focusing on what success looks like."
                                                                           },
                                                                           {
                                                                               "question":  "What does the acronym SMART stand for in the context of acceptance criteria?",
                                                                               "options":  {
                                                                                               "a":  "Simple, Manageable, Artistic, Reliable, Timely",
                                                                                               "b":  "Specific, Measurable, Achievable, Relevant, Time-bound",
                                                                                               "c":  "Strategic, Meaningful, Actionable, Realistic, Testable",
                                                                                               "d":  "Systematic, Modular, Agile, Responsive, Transparent"
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter emphasizes using \u0027SMART criteria (Specific, Measurable, Achievable, Relevant, Time-bound)\u0027 to avoid vague acceptance criteria."
                                                                           },
                                                                           {
                                                                               "question":  "Why is documenting edge cases crucial in a specification?",
                                                                               "options":  {
                                                                                               "a":  "Because edge cases are rarely encountered in real-world applications.",
                                                                                               "b":  "Because edge cases cause 80% of bugs, and if not specified, AI won\u0027t handle them.",
                                                                                               "c":  "Because they make the specification longer and more impressive.",
                                                                                               "d":  "Because they are only relevant for complex mathematical operations."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter highlights that \u0027Edge cases cause 80% of bugs. If you don\u0027t specify them, AI won\u0027t handle them.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is a key characteristic of a \u0027good spec\u0027 in relation to the project\u0027s Constitution?",
                                                                               "options":  {
                                                                                               "a":  "It ignores the Constitution to allow for more flexibility.",
                                                                                               "b":  "It is written before the Constitution is even considered.",
                                                                                               "c":  "It ensures that the specification\u0027s constraints are aligned with the Constitution\u0027s rules.",
                                                                                               "d":  "It only focuses on the \u0027happy path\u0027 scenarios."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "A good spec has \u0027Constraint alignment (specifications respect Constitution),\u0027 ensuring that the feature requirements adhere to the project\u0027s global rules."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  101,
                                           "chapter_title":  "Clarify Phase - Refining Specs with /sp.clarify",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary purpose of the `/sp.clarify` command in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "To automatically generate code from a specification.",
                                                                                               "b":  "To analyze a specification for ambiguities, missing assumptions, and incomplete requirements before planning.",
                                                                                               "c":  "To create a new project Constitution.",
                                                                                               "d":  "To commit changes to Git."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter describes `/sp.clarify` as a \u0027quick check\u0027 where the AI acts as a \u0027devil\u0027s advocate\u0027 to find gaps in your specification before moving to planning."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following is NOT a type of issue that `/sp.clarify` typically identifies?",
                                                                               "options":  {
                                                                                               "a":  "Ambiguous Terms",
                                                                                               "b":  "Missing Assumptions",
                                                                                               "c":  "Syntax errors in the Python code",
                                                                                               "d":  "Edge Case Gaps"
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "`/sp.clarify` focuses on the specification itself, identifying issues like ambiguous terms, missing assumptions, incomplete requirements, constraint conflicts, and edge case gaps. It does not check for syntax errors in Python code, as that\u0027s a later implementation concern."
                                                                           },
                                                                           {
                                                                               "question":  "What is the recommended approach when `/sp.clarify` suggests changes to your specification?",
                                                                               "options":  {
                                                                                               "a":  "Blindly accept all suggestions to save time.",
                                                                                               "b":  "Reject all suggestions, as the AI might be wrong.",
                                                                                               "c":  "Evaluate each suggestion critically, then decide to Accept, Reject, or Modify based on necessity and alignment with the Constitution.",
                                                                                               "d":  "Ignore the suggestions and proceed to the next phase."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Common Mistakes\u0027 section advises against \u0027Accepting All AI Suggestions Without Critical Thinking\u0027 and instead recommends evaluating each suggestion for its impact on clarity, complexity, and alignment with the Constitution."
                                                                           },
                                                                           {
                                                                               "question":  "How many rounds of clarification are typically needed for most specifications?",
                                                                               "options":  {
                                                                                               "a":  "Zero, if the initial spec is perfect.",
                                                                                               "b":  "One to two rounds.",
                                                                                               "c":  "Five or more rounds.",
                                                                                               "d":  "It depends on the AI model used."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter states, \u0027Most specifications need 1-2 clarification rounds. After that, they\u0027re ready for planning.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is the main benefit of using `/sp.clarify` before moving to the planning phase?",
                                                                               "options":  {
                                                                                               "a":  "It reduces the need for a project Constitution.",
                                                                                               "b":  "It ensures the specification is so clear that the planning phase can generate a perfect plan.",
                                                                                               "c":  "It automates the entire code generation process.",
                                                                                               "d":  "It helps in choosing the right AI tool for the project."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The goal of `/sp.clarify` is to \u0027Make your specification so clear that the planning phase can generate a perfect plan,\u0027 thereby improving the cascade quality."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  102,
                                           "chapter_title":  "Plan Phase - Architecture Decisions and ADRs",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary output of the `/sp.plan` command in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "A new project Constitution.",
                                                                                               "b":  "A detailed implementation plan that breaks the specification into architectural components, phases, and dependencies.",
                                                                                               "c":  "The final working code for the feature.",
                                                                                               "d":  "A list of all known bugs in the project."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter states that `/sp.plan` generates an implementation plan that breaks your specification into architectural components, implementation phases, dependencies, and design decisions."
                                                                           },
                                                                           {
                                                                               "question":  "What is an Architectural Decision Record (ADR) primarily used for?",
                                                                               "options":  {
                                                                                               "a":  "To document every single code change made in a project.",
                                                                                               "b":  "To capture the \u0027why\u0027 behind architecturally significant decisions, including context, alternatives, rationale, and consequences.",
                                                                                               "c":  "To list all the tasks required to complete a feature.",
                                                                                               "d":  "To define project-wide coding standards and principles."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "An ADR documents \u0027The Decision, The Context, The Alternatives, The Rationale, The Consequences\u0027 for choices that have long-term impact and where multiple valid alternatives existed."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following scenarios would typically NOT warrant creating an ADR?",
                                                                               "options":  {
                                                                                               "a":  "Deciding between a microservices architecture and a monolithic one.",
                                                                                               "b":  "Choosing a specific database technology (e.g., PostgreSQL vs. MongoDB).",
                                                                                               "c":  "Deciding to use snake_case for function names in Python.",
                                                                                               "d":  "Implementing a complex caching strategy for performance."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter advises against creating ADRs for \u0027Style choices (naming conventions, formatting)\u0027 as they are not architecturally significant decisions."
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u0027three-part test\u0027 for determining if a decision needs an ADR?",
                                                                               "options":  {
                                                                                               "a":  "Is it simple, measurable, and achievable?",
                                                                                               "b":  "Does it have long-term consequences, are there multiple viable alternatives, and will someone question it in 6 months?",
                                                                                               "c":  "Is it related to security, performance, or scalability?",
                                                                                               "d":  "Does it involve a new technology, a new team member, or a new client?"
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The \u0027three-part test\u0027 for ADRs is: \u0027Does this have long-term consequences? Are there multiple viable alternatives? Will someone ask \u0027why did we choose this\u0027 in 6 months?\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "How does the quality of the specification impact the implementation plan?",
                                                                               "options":  {
                                                                                               "a":  "A detailed spec always leads to a perfect plan, regardless of the AI tool.",
                                                                                               "b":  "A vague spec will result in a vague plan, while a detailed spec will produce a detailed plan.",
                                                                                               "c":  "The spec quality has no impact on the plan; they are independent phases.",
                                                                                               "d":  "A good spec reduces the need for a plan altogether."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The \u0027Cascade Effect\u0027 is highlighted: \u0027Detailed spec ? detailed plan. Vague spec ? vague plan,\u0027 emphasizing the direct relationship between specification quality and plan quality."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  103,
                                           "chapter_title":  "Tasks Phase - Atomic Work Units and Checkpoints",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the \u0027checkpoint pattern\u0027 and why is it considered critical in the Tasks Phase?",
                                                                               "options":  {
                                                                                               "a":  "It\u0027s a method for automatically deploying code to production without human intervention.",
                                                                                               "b":  "It\u0027s a workflow where the Agent completes a phase, the Human reviews and commits, and then directs the Agent to the next step, ensuring human control and early issue detection.",
                                                                                               "c":  "It\u0027s a way to skip the review process for small tasks.",
                                                                                               "d":  "It\u0027s a tool for tracking the progress of multiple agents working in parallel."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter defines the checkpoint pattern as \u0027Agent: \u0027Here\u0027s Phase 1 code\u0027 ? You: \u0027Review... looks good!\u0027 ? You: \u0027Commit to git\u0027 ? You: \u0027Tell me what\u0027s next\u0027 ? Agent: \u0027Phase 2\u0027,\u0027 emphasizing human control and early issue detection."
                                                                           },
                                                                           {
                                                                               "question":  "What are the key characteristics of an \u0027atomic work unit\u0027 (task) in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "It takes 8+ hours to complete and has multiple acceptance criteria.",
                                                                                               "b":  "It takes 1-2 hours to complete, has a single, clear acceptance criterion, and can be reviewed individually.",
                                                                                               "c":  "It is always implemented by the AI without human review.",
                                                                                               "d":  "It is a high-level goal that can be broken down later."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "A task is defined as a unit of work that \u0027Takes 1-2 hours to complete,\u0027 \u0027Has a single, clear acceptance criterion,\u0027 and \u0027Can be reviewed and approved individually.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What does the \u0027TDD approach\u0027 (Test-Driven Development) imply in the context of task dependencies?",
                                                                               "options":  {
                                                                                               "a":  "Implementation tasks must always be completed before any test tasks.",
                                                                                               "b":  "Tests MUST exist before implementation; a RED test task precedes a GREEN implementation task.",
                                                                                               "c":  "Tests are optional and can be added at any point.",
                                                                                               "d":  "Tests are only written for critical features, not for every task."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The TDD workflow is explicitly shown as \u0027?? RED (test) ? ?? GREEN (implement),\u0027 with the key insight that \u0027Tests MUST exist before implementation.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is \u0027lineage traceability\u0027 in the Tasks Phase?",
                                                                               "options":  {
                                                                                               "a":  "The ability to track the history of code changes in Git.",
                                                                                               "b":  "The ability to trace a requirement from the initial specification through the plan to an atomic task unit.",
                                                                                               "c":  "The process of identifying which tasks are assigned to which team members.",
                                                                                               "d":  "The documentation of all dependencies between different software components."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Lineage traceability is described as the ability to \u0027trace: specification requirement ? plan component ? task unit,\u0027 ensuring that tasks are well-connected to the original specification."
                                                                           },
                                                                           {
                                                                               "question":  "What is a common mistake regarding task sizing?",
                                                                               "options":  {
                                                                                               "a":  "Making tasks too small (less than 1 minute).",
                                                                                               "b":  "Making tasks too large (8+ hours), which hides complexity and delays feedback.",
                                                                                               "c":  "Not assigning a specific time estimate to each task.",
                                                                                               "d":  "Creating tasks that are too independent and have no dependencies."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Mistake 1 is \u0027Tasks Too Large (8+ Hours),\u0027 with the explanation that \u0027Large tasks hide complexity, delay feedback, and make checkpoints meaningless.\u0027"
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  104,
                                           "chapter_title":  "Implement Phase - AI-Driven Code Generation and Validation",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary function of the `/sp.implement` command in Spec-Kit Plus?",
                                                                               "options":  {
                                                                                               "a":  "To generate a project Constitution.",
                                                                                               "b":  "To analyze a specification for ambiguities.",
                                                                                               "c":  "To orchestrate AI-driven code generation, tests, and documentation for tasks.",
                                                                                               "d":  "To create Architectural Decision Records (ADRs)."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter states that `/sp.implement` \u0027orchestrates AI code generation\u0027 for tasks, including \u0027Code implementing each task,\u0027 \u0027Tests validating the code,\u0027 and \u0027Documentation (docstrings, comments).\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u00275-Step Validation Process\u0027 for AI-generated code?",
                                                                               "options":  {
                                                                                               "a":  "Design, Develop, Deploy, Debug, Document.",
                                                                                               "b":  "Read and Understand, Check Against Specification, Run Acceptance Criteria Tests, Manual Testing (Optional), Review and Approve.",
                                                                                               "c":  "Specify, Clarify, Plan, Task, Implement.",
                                                                                               "d":  "Compile, Link, Execute, Test, Refactor."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The \u00275-Step Validation Process\u0027 includes \u0027Read and Understand,\u0027 \u0027Check Against Specification,\u0027 \u0027Run Acceptance Criteria Tests,\u0027 \u0027Manual Testing (Optional),\u0027 and \u0027Review and Approve,\u0027 emphasizing systematic verification."
                                                                           },
                                                                           {
                                                                               "question":  "What are PHRs (Prompt History Records) primarily used for?",
                                                                               "options":  {
                                                                                               "a":  "To store project-wide rules and principles.",
                                                                                               "b":  "To document the \u0027why\u0027 behind significant architectural decisions.",
                                                                                               "c":  "To automatically document AI collaboration sessions, including prompts, responses, and decisions.",
                                                                                               "d":  "To track code coverage metrics."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "PHRs \u0027automatically documents: What prompt you gave the agent, What the agent responded with, What decision was made, When it happened,\u0027 serving as a record of AI collaboration."
                                                                           },
                                                                           {
                                                                               "question":  "When should a developer request an \u0027explicit PHR\u0027?",
                                                                               "options":  {
                                                                                               "a":  "For every routine coding task.",
                                                                                               "b":  "When the system\u0027s auto-creation might miss important decisions, such as novel problem-solving or complex tradeoff decisions.",
                                                                                               "c":  "Only when a major bug is discovered.",
                                                                                               "d":  "Never, as PHRs are always auto-created."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Explicit PHRs are warranted for \u0027Novel problem-solving approach,\u0027 \u0027Non-obvious error resolution,\u0027 \u0027Complex tradeoff decision,\u0027 or \u0027Learning moment worth preserving,\u0027 when auto-creation might miss these."
                                                                           },
                                                                           {
                                                                               "question":  "What is a common mistake during the Implement Phase regarding AI-generated code?",
                                                                               "options":  {
                                                                                               "a":  "Reading the code too carefully.",
                                                                                               "b":  "Accepting AI code without reading it first, leading to missed bugs or issues.",
                                                                                               "c":  "Asking too many clarifying questions to the AI.",
                                                                                               "d":  "Running tests too frequently."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Mistake 1 is \u0027Accepting AI Code Without Reading It First,\u0027 with the explanation that \u0027AI makes mistakes... Blind trust leads to bugs,\u0027 emphasizing the need for human review and validation."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  105,
                                           "chapter_title":  "Git Worktrees \u0026 Parallel Specifications",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary benefit of using \u0027git worktrees\u0027 for parallel development?",
                                                                               "options":  {
                                                                                               "a":  "It allows developers to work on a single feature without using branches.",
                                                                                               "b":  "It creates isolated workspaces, enabling multiple features to be specified/built in parallel without conflicts.",
                                                                                               "c":  "It automatically merges all changes into the main branch.",
                                                                                               "d":  "It reduces the need for version control systems."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter explains that git worktrees provide \u0027complete isolation\u0027 between workstreams, allowing \u0027multiple features being specified/built in parallel\u0027 without merge conflicts."
                                                                           },
                                                                           {
                                                                               "question":  "How does the \u0027parallel approach\u0027 to specification writing compare to the \u0027traditional sequential approach\u0027 in terms of time savings for 3 features?",
                                                                               "options":  {
                                                                                               "a":  "It takes the same amount of time.",
                                                                                               "b":  "It is 3 times faster (e.g., 90 min sequential vs. 30 min parallel).",
                                                                                               "c":  "It is 2 times faster.",
                                                                                               "d":  "It is slower due to increased coordination overhead."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The \u0027Time savings at scale\u0027 table explicitly shows that for 3 features, the parallel approach takes 30 minutes compared to 90 minutes sequentially, resulting in a \u00273x\u0027 speedup."
                                                                           },
                                                                           {
                                                                               "question":  "Why is it necessary to modify the local `/sp.specify` command when using git worktrees?",
                                                                               "options":  {
                                                                                               "a":  "Because `/sp.specify` cannot create new files in a worktree.",
                                                                                               "b":  "Because `/sp.specify` by default tries to create new branches, which conflicts with worktrees already being on feature branches.",
                                                                                               "c":  "Because git worktrees do not support the `/sp.specify` command.",
                                                                                               "d":  "To change the default output format of the specification."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The \u0027conflict\u0027 is that \u0027Worktrees: Already on feature branches\u0027 while \u0027`/sp.specify`: Tries to create new branches,\u0027 necessitating modification to detect existing branches and skip creation."
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u0027orchestration mindset\u0027 that this lesson aims to teach?",
                                                                               "options":  {
                                                                                               "a":  "Memorizing all git commands for worktrees.",
                                                                                               "b":  "Learning how to manage multiple AI agent sessions working in parallel and strategically thinking about problem-solving.",
                                                                                               "c":  "Writing code faster than AI agents.",
                                                                                               "d":  "Delegating all decision-making to AI agents."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The lesson emphasizes learning \u0027orchestration mindset: how to manage multiple AI agent sessions working in parallel\u0027 and \u0027strategic thinking, not command memorization.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "When running parallel specifications in multiple Claude sessions, what is a key observation regarding isolation?",
                                                                               "options":  {
                                                                                               "a":  "All agents share the same branch, leading to frequent merge conflicts.",
                                                                                               "b":  "Changes in one worktree immediately affect all other worktrees.",
                                                                                               "c":  "There is complete isolation between agents, with no conflicts, and each creates specs in its correct location.",
                                                                                               "d":  "Only one agent can run `/sp.specify` at a time."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027What you\u0027ll observe\u0027 section confirms \u0027Complete isolation between agents - no conflicts\u0027 and \u0027Each creates spec in correct location.\u0027"
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  106,
                                           "chapter_title":  "Parallel Planning and Tasks: Managing 2-3 Agents Simultaneously",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary benefit of running planning and task generation in parallel for multiple features?",
                                                                               "options":  {
                                                                                               "a":  "It eliminates the need for a shared project Constitution.",
                                                                                               "b":  "It dramatically reduces the total time spent by executing multiple planning sessions simultaneously, rather than sequentially.",
                                                                                               "c":  "It ensures that all features are implemented by a single AI agent.",
                                                                                               "d":  "It makes the planning process more complex and error-prone."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter highlights that running planning in parallel saves significant time (e.g., 40 minutes for 3 features) because \u0027time is no longer sequential,\u0027 allowing multiple agents to work concurrently."
                                                                           },
                                                                           {
                                                                               "question":  "How does a \u0027shared constitution\u0027 enable parallel planning and task generation without constant synchronization?",
                                                                               "options":  {
                                                                                               "a":  "It forces all agents to use the same programming language.",
                                                                                               "b":  "It provides a common set of standards, definitions of \u0027good,\u0027 and API contract patterns, ensuring agents make aligned decisions independently.",
                                                                                               "c":  "It automatically resolves all merge conflicts between parallel workstreams.",
                                                                                               "d":  "It dictates the exact implementation details for each feature."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The shared constitution acts as the \u0027glue\u0027 that keeps all three aligned \u0027without constant synchronization,\u0027 ensuring agents follow the same standards and patterns."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following is an indicator of \u0027bad decomposition\u0027 when evaluating plan quality?",
                                                                               "options":  {
                                                                                               "a":  "Plan length is 2-4 pages per feature.",
                                                                                               "b":  "Balanced complexity across features.",
                                                                                               "c":  "One feature\u0027s plan is 3-4 times larger than others, signaling hidden complexity.",
                                                                                               "d":  "Explicitly listed dependencies with minimal cross-feature interaction."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "A \u0027Bad Decomposition\u0027 is indicated if \u0027One feature much larger than others\u0027 or \u0027One plan is 3-4x larger than others,\u0027 signaling hidden complexity that should be refactored."
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u0027Rubric: Good vs Bad Decomposition\u0027 used for?",
                                                                               "options":  {
                                                                                               "a":  "To assess the performance of individual AI agents.",
                                                                                               "b":  "To compare the efficiency of sequential vs. parallel execution.",
                                                                                               "c":  "To evaluate the quality of feature decomposition by analyzing plan length, complexity, tasks count, and dependencies.",
                                                                                               "d":  "To determine the optimal number of git worktrees to use."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The rubric is used to \u0027Compare your three plans\u0027 based on \u0027Plan length,\u0027 \u0027Complexity,\u0027 \u0027Tasks count,\u0027 \u0027Dependencies,\u0027 and \u0027Integration points\u0027 to assess decomposition quality."
                                                                           },
                                                                           {
                                                                               "question":  "Why is \u0027monitoring multiple sessions\u0027 important when running parallel tasks?",
                                                                               "options":  {
                                                                                               "a":  "To ensure all agents are working on the same task.",
                                                                                               "b":  "To track which session finished first, if any errored out, and if all are progressing at similar speeds.",
                                                                                               "c":  "To manually intervene and correct AI-generated code in real-time.",
                                                                                               "d":  "It is not important, as AI agents are fully autonomous."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Monitoring multiple sessions is important to \u0027track: Which session finished first? Did any session error out? Are all three progressing at similar speed?\u0027"
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  107,
                                           "chapter_title":  "Parallel Implementation \u0026 Integration: Proving Decomposition Works",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the profound insight regarding merge conflicts and decomposition quality?",
                                                                               "options":  {
                                                                                               "a":  "Merge conflicts are always a sign of poor git skills.",
                                                                                               "b":  "Clean merges mean excellent decomposition, while many merge conflicts mean the system design needs rethinking.",
                                                                                               "c":  "Merge conflicts are an unavoidable part of any parallel development.",
                                                                                               "d":  "The number of merge conflicts is directly proportional to the number of features."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter states: \u0027Clean merges mean excellent decomposition. Many merge conflicts mean your system design needs rethinking.\u0027 This highlights that merge conflicts are a feedback mechanism for system architecture."
                                                                           },
                                                                           {
                                                                               "question":  "What is the key principle for merging features when they have dependencies?",
                                                                               "options":  {
                                                                                               "a":  "Merge features in any order, as git will handle dependencies automatically.",
                                                                                               "b":  "Always merge the largest feature first to get it out of the way.",
                                                                                               "c":  "You must merge features in dependency order; if Feature B depends on Feature A, Feature A must merge first.",
                                                                                               "d":  "Merge all features simultaneously to save time."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Key principle\u0027 is: \u0027You must merge features in dependency order. If Feature B depends on Feature A, Feature A must merge first.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "How does parallel implementation affect the total clock time compared to sequential implementation for three features?",
                                                                               "options":  {
                                                                                               "a":  "It increases the total clock time due to overhead.",
                                                                                               "b":  "It results in the same total clock time.",
                                                                                               "c":  "It significantly reduces the total clock time, as features are implemented concurrently.",
                                                                                               "d":  "It is only beneficial for very small features."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter shows that for three features, sequential implementation takes ~2 hours, while parallel implementation takes ~50 minutes, demonstrating a significant reduction in total clock time."
                                                                           },
                                                                           {
                                                                               "question":  "When handling a merge conflict, what is the correct sequence of actions?",
                                                                               "options":  {
                                                                                               "a":  "Decide which changes to keep, edit the file, then run `git commit`.",
                                                                                               "b":  "Run `git commit`, then decide which changes to keep, then edit the file.",
                                                                                               "c":  "Edit the file, then run `git add`, then run `git commit`.",
                                                                                               "d":  "Run `git add`, then edit the file, then run `git commit`."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Resolution\u0027 steps are: \u0027Decide which to keep (or combine both),\u0027 \u0027Edit the file to resolve conflict,\u0027 and then \u0027Mark resolved: git add filename.py; git commit -m \"Merge...\"\u0027."
                                                                           },
                                                                           {
                                                                               "question":  "What does it mean if you experience many merge conflicts during integration?",
                                                                               "options":  {
                                                                                               "a":  "Your git client is misconfigured.",
                                                                                               "b":  "Your decomposition was poor, and the system design needs rethinking.",
                                                                                               "c":  "You need to switch to a different version control system.",
                                                                                               "d":  "The AI agents are not coordinating effectively."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter explicitly states: \u0027Many merge conflicts mean your system design needs rethinking,\u0027 indicating that conflicts are a direct feedback on decomposition quality."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  108,
                                           "chapter_title":  "Scaling Decomposition Thinking: From 3 to 5+ Features",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the \u0027N-squared problem\u0027 in the context of communication complexity?",
                                                                               "options":  {
                                                                                               "a":  "It refers to the number of lines of code increasing exponentially with features.",
                                                                                               "b":  "It describes how the number of potential coordination points between N agents increases quadratically (N*(N-1)/2).",
                                                                                               "c":  "It\u0027s a problem where the number of bugs increases with the square of the features.",
                                                                                               "d":  "It\u0027s a mathematical formula for calculating project deadlines."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Fred Brooks\u0027 \u0027N-squared problem\u0027 states that with N agents, the number of potential coordination points is N�(N-1)/2, leading to rapidly increasing complexity as N grows."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following decomposition patterns is explicitly stated to \u0027scale beautifully\u0027 from 3 to 5+ features?",
                                                                               "options":  {
                                                                                               "a":  "Vague specifications with implicit contracts.",
                                                                                               "b":  "Features that frequently modify shared code and data.",
                                                                                               "c":  "Tight, clear specifications with explicit inputs, outputs, and boundaries.",
                                                                                               "d":  "Mediocre APIs with unclear behavior."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter states that \u0027Tight, Clear Specifications Scale,\u0027 emphasizing explicit inputs, outputs, and boundaries as critical for clean integration at scale."
                                                                           },
                                                                           {
                                                                               "question":  "What is a \u0027cross-cutting concern\u0027 and why does it become a bottleneck at 5+ features if not handled correctly?",
                                                                               "options":  {
                                                                                               "a":  "A feature that is too large and needs to be split.",
                                                                                               "b":  "A concern (like authentication, logging) that affects all features but doesn\u0027t belong to any one, becoming a bottleneck if implemented ad-hoc by each feature.",
                                                                                               "c":  "A dependency between two features that creates a circular loop.",
                                                                                               "d":  "A configuration setting that is hardcoded in multiple places."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Cross-cutting concerns are things like authentication or logging that affect all features. If handled ad-hoc, they \u0027break\u0027 at 5+ features, requiring design as \u0027shared services\u0027 with clear APIs."
                                                                           },
                                                                           {
                                                                               "question":  "What is a \u0027red flag\u0027 indicating poor decomposition when analyzing a multi-feature system?",
                                                                               "options":  {
                                                                                               "a":  "All features have roughly balanced implementation times.",
                                                                                               "b":  "Minimal merge conflicts during integration.",
                                                                                               "c":  "One feature is much larger than others (e.g., 3x-4x the size), becoming a bottleneck.",
                                                                                               "d":  "Clear API boundaries between features."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "Red Flag 1 is \u0027One Feature Is Much Larger Than Others,\u0027 indicating that such a feature \u0027isn\u0027t really a feature; it\u0027s a detail of another feature\u0027 and will become a bottleneck at scale."
                                                                           },
                                                                           {
                                                                               "question":  "How do \u0027Specifications reduce communication complexity\u0027?",
                                                                               "options":  {
                                                                                               "a":  "By eliminating the need for any communication between agents.",
                                                                                               "b":  "By making communication asynchronous, allowing agents to read a clear, documented contract instead of engaging in synchronous discussions.",
                                                                                               "c":  "By forcing all agents to work on the same feature simultaneously.",
                                                                                               "d":  "By automatically generating all code, removing the need for human understanding."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The insight is that \u0027Specifications reduce communication complexity by making communication asynchronous,\u0027 allowing agents to rely on documented specs rather than synchronous conversations."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  109,
                                           "chapter_title":  "Contract-Based Autonomous Coordination",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary benefit of \u0027Contract-Based Autonomous Coordination\u0027 in AI-native development?",
                                                                               "options":  {
                                                                                               "a":  "It allows for constant monitoring and micromanagement of AI agents.",
                                                                                               "b":  "It enables agents to work autonomously with minimal oversight by defining clear boundaries and measurable acceptance criteria upfront.",
                                                                                               "c":  "It eliminates the need for any specifications or plans.",
                                                                                               "d":  "It forces all agents to work on the same feature simultaneously."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter emphasizes that \u0027When contracts are explicit and acceptance criteria are measurable, agents can work with minimal oversight,\u0027 leading to \u0027Trust Without Micromanagement.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is the key difference between \u0027vague\u0027 and \u0027measurable\u0027 acceptance criteria?",
                                                                               "options":  {
                                                                                               "a":  "Vague criteria are shorter, while measurable criteria are longer.",
                                                                                               "b":  "Vague criteria require human judgment for verification, while measurable criteria enable autonomous verification without human judgment.",
                                                                                               "c":  "Vague criteria are used for early-stage features, measurable for late-stage.",
                                                                                               "d":  "There is no significant difference; both achieve the same outcome."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter explicitly states: \u0027Vague criteria require human judgment. Measurable criteria enable autonomous verification.\u0027 This is the core distinction."
                                                                           },
                                                                           {
                                                                               "question":  "Which of the following is NOT one of the four questions a good integration contract should answer?",
                                                                               "options":  {
                                                                                               "a":  "What does this feature provide?",
                                                                                               "b":  "What is the personal background of the AI agent implementing this feature?",
                                                                                               "c":  "What does this feature depend on?",
                                                                                               "d":  "How will we know it\u0027s done?"
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "A good contract answers: \u0027What does this feature provide?\u0027, \u0027What does this feature depend on?\u0027, \u0027How will it integrate?\u0027, and \u0027How will we know it\u0027s done?\u0027. The personal background of the AI agent is irrelevant."
                                                                           },
                                                                           {
                                                                               "question":  "What is the purpose of \u0027completion hooks\u0027 in autonomous coordination?",
                                                                               "options":  {
                                                                                               "a":  "To block agents from starting new tasks until previous ones are manually approved.",
                                                                                               "b":  "To automatically notify the orchestrator when certain events occur, such as an agent finishing implementation or tests passing.",
                                                                                               "c":  "To provide a visual representation of the project\u0027s progress.",
                                                                                               "d":  "To allow agents to communicate directly with each other without human intervention."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Completion hooks are \u0027scripts that fire automatically when certain events occur,\u0027 notifying the orchestrator that work is complete, thus enabling async coordination and progress monitoring."
                                                                           },
                                                                           {
                                                                               "question":  "How do \u0027explicit contracts\u0027 reduce coordination overhead and enable autonomous work?",
                                                                               "options":  {
                                                                                               "a":  "By forcing synchronous meetings to clarify ambiguities.",
                                                                                               "b":  "By eliminating the need for any communication between agents or humans.",
                                                                                               "c":  "By making communication asynchronous; the contract itself communicates the intent, reducing the need for constant check-ins and status meetings.",
                                                                                               "d":  "By allowing agents to interpret requirements based on their own judgment."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The chapter explains that \u0027Contracts + Hooks = Trust Without Micromanagement\u0027 and that \u0027Vague contracts = coordination overhead. Clear contracts = autonomous work,\u0027 reducing sync meetings and speeding up integration."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  110,
                                           "chapter_title":  "Lesson 6: SpecKit-Orchestrated Autonomous Execution",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the \u0027SpecKit Orchestrator Paradigm\u0027 primarily based on?",
                                                                               "options":  {
                                                                                               "a":  "Complex bash scripts for agent coordination.",
                                                                                               "b":  "Using SpecKit Plus commands and well-defined specifications as the coordination mechanism for autonomous agents.",
                                                                                               "c":  "Headless mode execution for all AI agents.",
                                                                                               "d":  "Manual monitoring of all agent sessions."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The chapter clarifies that SpecKit Plus itself becomes the orchestrator, coordinating multiple AI agent sessions through shared specifications and completion hooks, rather than complex scripting."
                                                                           },
                                                                           {
                                                                               "question":  "What is the key shift in coordination from \u0027Manual Coordination\u0027 (Lesson 5) to \u0027Specification-Driven Orchestration\u0027 (Lesson 6)?",
                                                                               "options":  {
                                                                                               "a":  "From synchronous human monitoring to asynchronous human oversight, with agents executing autonomously based on clear specifications.",
                                                                                               "b":  "From agents working independently to agents requiring constant human intervention.",
                                                                                               "c":  "From using specifications to using only code for coordination.",
                                                                                               "d":  "From small projects to large, complex projects."
                                                                                           },
                                                                               "correct_answer":  "a",
                                                                               "explanation":  "The shift is from \u0027Human monitors 5 terminals\u0027 and \u0027Coordination is synchronous\u0027 to \u0027Specifications define ALL integration requirements upfront\u0027 and \u0027Human focuses on strategic decisions, not execution monitoring,\u0027 enabling autonomous execution."
                                                                           },
                                                                           {
                                                                               "question":  "What is the purpose of a \u0027contract.md\u0027 file in SpecKit-Orchestrated execution?",
                                                                               "options":  {
                                                                                               "a":  "To document the personal preferences of each AI agent.",
                                                                                               "b":  "To define what each agent MUST build, including feature boundaries, data contracts, success criteria, and dependencies, enabling clean integration.",
                                                                                               "c":  "To store the entire codebase for the project.",
                                                                                               "d":  "To track the time spent by each AI agent on a task."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "A contract is a specification that defines \u0027What each agent MUST build (feature boundaries), What data contracts exist (API contracts, data formats), What success looks like (acceptance criteria), What dependencies exist (if any),\u0027 ensuring clean integration."
                                                                           },
                                                                           {
                                                                               "question":  "How do \u0027completion hooks\u0027 contribute to autonomous execution?",
                                                                               "options":  {
                                                                                               "a":  "They allow agents to ask clarifying questions during execution.",
                                                                                               "b":  "They automatically notify the human orchestrator when an agent has completed its tasks, enabling asynchronous progress monitoring.",
                                                                                               "c":  "They prevent agents from starting tasks until all prerequisites are manually approved.",
                                                                                               "d":  "They provide real-time visual feedback on agent progress."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "Completion hooks are \u0027scripts that fire automatically when certain events occur,\u0027 notifying the orchestrator that work is complete, allowing the human to \u0027walk away from your computer\u0027 and be notified when agents are done."
                                                                           },
                                                                           {
                                                                               "question":  "What is the ultimate goal of \u0027SpecKit-Orchestrated Autonomous Execution\u0027 for the human developer?",
                                                                               "options":  {
                                                                                               "a":  "To eliminate the need for any human involvement in software development.",
                                                                                               "b":  "To shift from managing execution to strategic oversight and creative independence, delegating execution to autonomous AI agents.",
                                                                                               "c":  "To become an expert in writing complex bash scripts for automation.",
                                                                                               "d":  "To manually coordinate 15+ AI agents simultaneously."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The lesson\u0027s core message is \u0027Creative Independence Through Specification-Driven Orchestration,\u0027 where the human shifts from \u0027managing execution to strategic oversight\u0027 and focuses on strategy while agents work autonomously."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       },
                                       {
                                           "chapter_id":  111,
                                           "chapter_title":  "Capstone Project: Prove Your Decomposition Skills",
                                           "skipped":  false,
                                           "questions":  {
                                                             "value":  [
                                                                           {
                                                                               "question":  "What is the primary goal of the Capstone Project in Chapter 111?",
                                                                               "options":  {
                                                                                               "a":  "To learn a new programming language.",
                                                                                               "b":  "To prove decomposition thinking by building a multi-feature system in parallel, integrating cleanly, and measuring productivity gains.",
                                                                                               "c":  "To memorize all git commands for worktrees.",
                                                                                               "d":  "To develop a complex AI model from scratch."
                                                                                           },
                                                                               "correct_answer":  "b",
                                                                               "explanation":  "The challenge is to \u0027Build a 3-feature system in parallel, integrate cleanly, measure your productivity gains, and document your work for employers,\u0027 proving decomposition skills."
                                                                           },
                                                                           {
                                                                               "question":  "What is the expected speedup target for a well-decomposed 3-feature system using the parallel workflow?",
                                                                               "options":  {
                                                                                               "a":  "Less than 1x (slower than sequential).",
                                                                                               "b":  "1x (same as sequential).",
                                                                                               "c":  "2-3x speedup.",
                                                                                               "d":  "More than 5x speedup."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Time Tracking Worksheet\u0027 section states the \u0027Target: 2-3x speedup for well-decomposed systems.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What does it indicate if the speedup achieved in the Capstone Project is less than 2x?",
                                                                               "options":  {
                                                                                               "a":  "The AI agents were not efficient enough.",
                                                                                               "b":  "The project was too simple.",
                                                                                               "c":  "Likely causes include merge conflicts (poor decomposition), unbalanced features, or hidden dependencies.",
                                                                                               "d":  "The time tracking method was inaccurate."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "If speedup is \u0027\u003c 2x\u0027, likely causes are listed as \u0027Merge conflicts (poor decomposition), Unbalanced features (one took much longer), Hidden dependencies (integration issues).\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "When crafting a portfolio narrative for employers, what should be emphasized?",
                                                                               "options":  {
                                                                                               "a":  "The specific git commands used and terminal management techniques.",
                                                                                               "b":  "Tool descriptions, such as \u0027I used git worktrees to run 3 sessions in parallel.\u0027",
                                                                                               "c":  "Decomposition thinking, strategic capability, and the ability to coordinate autonomous teams at scale.",
                                                                                               "d":  "The number of lines of code written by the AI."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027What TO Say\u0027 section advises emphasizing \u0027decomposition thinking � breaking complex systems into parallelizable units with clear contracts\u0027 and the ability to \u0027coordinate autonomous teams at scale.\u0027"
                                                                           },
                                                                           {
                                                                               "question":  "What is the \u0027bottleneck\u0027 that is \u0027ALWAYS decomposition\u0027 in scaling multi-agent systems?",
                                                                               "options":  {
                                                                                               "a":  "The speed of the AI tools.",
                                                                                               "b":  "The number of available terminal windows.",
                                                                                               "c":  "The quality of the specifications and how well the system is broken down into independent units.",
                                                                                               "d":  "The amount of RAM on the developer\u0027s machine."
                                                                                           },
                                                                               "correct_answer":  "c",
                                                                               "explanation":  "The \u0027Scaling Reflection\u0027 section explicitly states: \u0027The bottleneck is ALWAYS decomposition, not tools,\u0027 highlighting the critical role of well-defined specifications and system breakdown."
                                                                           }
                                                                       ],
                                                             "Count":  5
                                                         }
                                       }
                                   ]
                  }
}
