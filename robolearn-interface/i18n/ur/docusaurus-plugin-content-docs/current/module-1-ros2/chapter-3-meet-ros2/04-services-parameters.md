---
id: lesson-3-4-services-parameters
title: 'Lesson 3.4: Services and Parameters (CLI Exploration)'
sidebar_position: 4
sidebar_label: 3.4 Services & Parameters
description: >-
  Explore ROS 2 services (request/response) and parameters (runtime
  configuration) using CLI tools.
duration_minutes: 60
proficiency_level: A2
layer: L1
hardware_tier: 1
learning_objectives:
  - List available services using ros2 service list
  - Call services with arguments using ros2 service call
  - List and modify parameters using ros2 param list/set
  - Understand services vs topics conceptually
skills:
  - ros2-fundamentals
  - ros2-cli
  - ros2-service-pattern
tier_1_path: Cloud ROS 2 (TheConstruct)
generated_by: content-implementer v1.0.0
created: '2025-11-29'
version: 1.0.0
---


# سروسز اور پیرامیٹرز (CLI ایکسپلوریشن)

سبق 3.2 اور 3.3 میں، آپ نے **ٹاپکس** کو دریافت کیا—جو پب/سب (pub/sub) استعمال کرتے ہوئے ڈیٹا کے مسلسل بہاؤ (continuous data streams) ہیں۔

اب آپ **سروسز**—یعنی ریکویسٹ/رسپانس تعاملات (جیسے فنکشن کال کرنا) اور **پیرامیٹرز**—یعنی رن ٹائم کنفیگریشن ویری ایبلز کو دریافت کریں گے۔

اس سبق کے اختتام تک، آپ ROS 2 کے فراہم کردہ نوڈ کمیونیکیشن کے مکمل ٹول کٹ کو سمجھ جائیں گے۔

**مدت**: 60 منٹ | **ہارڈ ویئر ٹائر**: ٹائر 1 | **صرف CLI ایکسپلوریشن—ابھی کوئی کوڈنگ نہیں**

---

## پیشگی ضروریات (Prerequisites)

شروع کرنے سے پہلے، سبق 3.2 سے `turtlesim` کو چلتا ہوا رکھیں:

**ٹرمینل 1**:
```bash
ros2 run turtlesim turtlesim_node
```

جب آپ ٹرمینل 2 میں ایکسپلوریشن کر رہے ہوں تو اسے چلتا رہنے دیں (اس سبق کے لیے آپ کو ٹیلی اوپ کی ضرورت نہیں ہے)۔

---

## بنیادی تصورات (Core Concepts)

### سروس کیا ہے؟

ایک **سروس** ایک سنکرونس (synchronous) ریکویسٹ/رسپانس تعامل ہے۔ ٹاپکس کے برعکس (جو مسلسل سٹریم ہوتے ہیں)، سروسز **RPC-جیسی** (Remote Procedure Call) ہوتی ہیں۔

**مثال (Analogy)**:
- **ٹاپک**: خبروں کی نشریات (مسلسل سٹریم، جو سن رہا ہے اسے مل جاتی ہے)
- **سروس**: فون کال (میں آپ سے ایک سوال پوچھتا ہوں، آپ جواب دیتے ہیں، کال ختم ہو جاتی ہے)

**خصوصیات**:
- کلائنٹ ایک ریکویسٹ بھیجتا ہے
- سرور اسے پروسیس کرتا ہے
- سرور ایک رسپانس واپس بھیجتا ہے
- کمیونیکیشن بلاک ہوتی ہے (کلائنٹ رسپانس کا انتظار کرتا ہے)

**turtlesim میں مثالیں**:
- `/spawn`: "X, Y پوزیشن پر ایک نیا ٹرٹل بنائیں" (کسی رسپانس ڈیٹا کی ضرورت نہیں)
- `/kill`: "ایک ٹرٹل کو ڈیلیٹ کریں" (کامیابی/ناکامی کے ساتھ رسپانس دیتا ہے)
- `/reset`: "تمام ڈرائنگز صاف کریں، شروع کی حالت پر واپس جائیں" (نتیجے کے ساتھ رسپانس دیتا ہے)
- `/teleport_absolute`: "ٹرٹل کو بالکل X, Y پوزیشن پر لے جائیں" (کامیابی کی تصدیق کرتا ہے)

---

### پیرامیٹر کیا ہے؟

ایک **پیرامیٹر** ایک رن ٹائم کنفیگریشن ویری ایبل ہے جو ایک نوڈ کے لیے مخصوص (scoped) ہوتا ہے۔

**turtlesim میں مثالیں**:
- `background_r`, `background_g`, `background_b`: کینوس کے پس منظر کا رنگ (RGB ویلیوز 0-255)
- `pen_r`, `pen_g`, `pen_b`: ڈرائنگ پین کا رنگ

**خصوصیات**:
- ایک نوڈ کی ملکیت ہوتا ہے (مثلاً، `/turtlesim` اپنے رنگ کے پیرامیٹرز کا مالک ہے)
- کسی بھی وقت پڑھا جا سکتا ہے
- رن ٹائم پر تبدیل کیا جا سکتا ہے (نوڈ نئی ویلیوز پر فوری ردعمل دیتا ہے)
- نوڈ کے لیے مخصوص ہوتا ہے ( `/turtlesim` کے نیچے کے پیرامیٹرز دوسرے نوڈز سے الگ ہوتے ہیں)

---

### سروسز بمقابلہ ٹاپکس: کسے کب استعمال کریں؟

**ٹاپکس کا استعمال کریں جب**:
- ڈیٹا مسلسل ہو (سینسر سٹریمز، اوڈومیٹری)
- ایک سے زیادہ نوڈز کو ایک ہی ڈیٹا کی ضرورت ہو (براڈکاسٹ)
- گارنٹیڈ ڈیلیوری کے بجائے ریئل ٹائم فیڈ بیک کو ترجیح دی جائے
- مثال: `/turtle1/odometry` (پوزیشن اپ ڈیٹس مسلسل سٹریم ہوتی ہیں)

**سروسز کا استعمال کریں جب**:
- آپ کو رسپانس کی ضرورت ہو (ریکویسٹ/رسپانس تعامل)
- ایکشن الگ تھلگ (discrete) ہو (اسپاون، کل، ری سیٹ)
- بلاکنگ کال مناسب ہو (سرور رسپانس کا انتظار کریں)
- مثال: `/spawn` (کلائنٹ سرور کے ٹرٹل بنانے کا انتظار کرتا ہے)

**عمومی اصول**: مسلسل ڈیٹا کے لیے ٹاپکس، الگ تھلگ ایکشنز کے لیے سروسز۔

---

## سٹیپ 1: دستیاب سروسز کی فہرست بنائیں

```bash
ros2 service list
```

**متوقع آؤٹ پٹ**:
```
/clear
/kill
/reset
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
```

**یہ کیا کرتے ہیں**:
- `/clear`: تمام ڈرائنگز مٹا دیں (کینوس خالی)
- `/kill`: ایک ٹرٹل کو ڈیلیٹ کریں (نام درکار ہے)
- `/reset`: ابتدائی حالت پر ری سیٹ کریں
- `/spawn`: ایک نیا ٹرٹل بنائیں (پوزیشن/روٹیشن درکار ہے)
- `/turtle1/set_pen`: ڈرائنگ پین کی خصوصیات تبدیل کریں
- `/turtle1/teleport_absolute`: ٹرٹل کو بالکل مقام پر لے جائیں
- `/turtle1/teleport_relative`: ٹرٹل کو موجودہ پوزیشن کے لحاظ سے لے جائیں

---

## سٹیپ 2: سروس کی تفصیلات حاصل کریں

دیکھیں کہ ایک سروس کیا آرگومنٹس کی توقع کرتی ہے:

```bash
ros2 service type /spawn
```

**آؤٹ پٹ**:
```
turtlesim/srv/Spawn
```

`Spawn` سروس کیا توقع کرتی ہے؟ انٹرفیس دیکھیں:

```bash
ros2 interface show turtlesim/srv/Spawn
```

**آؤٹ پٹ**:
```
float32 x
float32 y
float32 theta
string name
---
uint32 success
string message
```

**اس کا کیا مطلب ہے**:
- **ریکویسٹ** (`---` کے اوپر):
  - `x`: X کوآرڈینیٹ
  - `y`: Y کوآرڈینیٹ
  - `theta`: روٹیشن اینگل (ریڈینز میں)
  - `name`: نئے ٹرٹل کا نام
- **رسپانس** (`---` کے نیچے):
  - `success`: کامیاب ہونے پر 1، ناکام ہونے پر 0
  - `message`: ٹیکسٹ رسپانس

---

## سٹیپ 3: ایک سروس کال کریں

`/spawn` سروس کا استعمال کرتے ہوئے ایک نیا ٹرٹل بنائیں:

```bash
ros2 service call /spawn turtlesim/srv/Spawn "{x: 5.0, y: 5.0, theta: 1.57, name: 'turtle2'}"
```

**آپ کیا دیکھتے ہیں**:
- `turtlesim` کینوس میں، ایک **دوسرا ٹرٹل** پوزیشن (5, 5) پر ظاہر ہوتا ہے
- ٹرمینل رسپانس دکھاتا ہے:
  ```
  requester: making request: x=5.0 y=5.0 theta=1.57 name='turtle2'
  response:
  success: True
  message: ''
  ```

**کیا ہوا**:
1. آپ نے `/spawn` پر کوآرڈینیٹس اور نام کے ساتھ ایک ریکویسٹ بھیجی
2. `Turtlesim` نے اسے وصول کیا، ایک نیا ٹرٹل بنایا
3. ایک رسپانس واپس بھیجا: `success: True`
4. سروس کال مکمل ہو گئی

---

## سٹیپ 4: ایک اور سروس کال کریں (ٹیلی پورٹ)

ایک ٹرٹل کو ایک بالکل مخصوص مقام پر لے جائیں:

```bash
ros2 service call /turtle1/teleport_absolute turtlesim/srv/TeleportAbsolute "{x: 8.0, y: 8.0, theta: 0.0}"
```

**نتیجہ**: ٹرٹل 1 بغیر کوئی راستہ ڈرا کیے پوزیشن (8, 8) پر فوری طور پر چلا جاتا ہے۔

**ٹاپکس سے موازنہ کریں**: اگر آپ نے ویلاسٹی کمانڈز (ٹاپک) شائع کیے ہوتے، تو ٹرٹل آسانی سے حرکت کرتا۔ سروس کے ساتھ، یہ فوری طور پر چھلانگ لگاتا ہے۔

---

## سٹیپ 5: کینوس صاف کریں

```bash
ros2 service call /clear std_srvs/srv/Empty "{}"
```

**نتیجہ**: تمام ڈرائنگز غائب ہو جاتی ہیں۔ کینوس دوبارہ خالی۔

**نوٹ**: ایمپٹی سروس (کسی ریکویسٹ ڈیٹا کی ضرورت نہیں، اس لیے `{}`)

---

## سٹیپ 6: پیرامیٹرز کی فہرست بنائیں

`/turtlesim` نوڈ پر تمام کنفیگریشن پیرامیٹرز دیکھیں:

```bash
ros2 param list
```

**متوقع آؤٹ پٹ**:
```
/turtlesim:
  background_b
  background_g
  background_r
  pen_r
  pen_g
  pen_b
```

**یہ کیا ہیں**:
- `background_r/g/b`: پس منظر کے سرخ، سبز، نیلے اجزاء (0-255)
- `pen_r/g/b`: ڈرائنگ پین کے سرخ، سبز، نیلے اجزاء (0-255)

---

## سٹیپ 7: پیرامیٹر ویلیوز حاصل کریں

```bash
ros2 param get /turtlesim background_r
```

**آؤٹ پٹ**:
```
Integer value is: 69
```

پس منظر کا سرخ جزو فی الحال 69 ہے۔

تمام رنگ کے پیرامیٹرز حاصل کریں:

```bash
ros2 param list /turtlesim
```

---

## سٹیپ 8: ایک پیرامیٹر تبدیل کریں

پس منظر کا رنگ سبز میں تبدیل کریں:

```bash
ros2 param set /turtlesim background_r 0
ros2 param set /turtlesim background_g 255
ros2 param set /turtlesim background_b 0
```

**نتیجہ**: `Turtlesim` کینوس کا پس منظر گہرا سبز ہو جاتا ہے!

پین کا رنگ سرخ میں تبدیل کریں:

```bash
ros2 param set /turtlesim pen_r 255
ros2 param set /turtlesim pen_g 0
ros2 param set /turtlesim pen_b 0
```

اب کینوس پر ڈرا کریں (ٹیلی اوپ چلائیں یا ویلاسٹی ٹاپک کو ایکو کریں)۔ ٹرٹل سرخ رنگ میں ڈرا کرتا ہے۔

---

## سروسز بمقابلہ ٹاپکس کو سمجھنا

آئیے دونوں کمیونیکیشن پیٹرن کا موازنہ کریں:

```
┌─────────────────────────────────────────────────────────────┐
│                    ٹاپکس (سبق 3.3)                        │
├─────────────────────────────────────────────────────────────┤
│ پبلشر (ٹیلی اوپ)    →  /turtle1/cmd_vel  →  سبسکرائبر   │
│                            (ٹاپک)          (Turtlesim)     │
│                                                              │
│ خصوصیات:                                                    │
│ • مسلسل سٹریم                                               │
│ • ایک بار پبلش کریں، کہیں بھی وصول کریں                     │
│ • رسپانس کا انتظار نہیں                                     │
│ • یک طرفہ (عام طور پر)                                      │
│ • فائر اینڈ فارگیٹ (Fire-and-forget)                         │
│                                                              │
│ استعمال کے معاملات:                                         │
│ • سینسر ڈیٹا (LIDAR، کیمرہ، IMU)                           │
│ • مسلسل فیڈ بیک (اوڈومیٹری، ویلاسٹی)                        │
│ • غیر مطابقت پذیر اپ ڈیٹس (Asynchronous updates)          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   سروسز (یہ سبق)                            │
├─────────────────────────────────────────────────────────────┤
│ کلائنٹ (آپ)          →  /spawn  ↔  سرور                 │
│                       (سروس) (Turtlesim)                    │
│ ریکویسٹ بھیجتا ہے                                            │
│ رسپانس کا انتظار کرتا ہے ←────────────                      │
│                                                              │
│ خصوصیات:                                                    │
│ • ریکویسٹ/رسپانس پیٹرن                                     │
│ • سنکرونس (کلائنٹ انتظار کرتا ہے)                           │
│ • سرور سے ڈیٹا واپس ملتا ہے                                 │
│ • دو طرفہ                                                   │
│ • ٹرانزیکشن جیسا                                           │
│                                                              │
│ استعمال کے معاملات:                                         │
│ • الگ تھلگ ایکشنز (اسپاون، کل، ری سیٹ)                       │
│ • کنفیگریشن کمانڈز                                          │
│ • جب آپ کو تصدیق کی ضرورت ہو                               │
└─────────────────────────────────────────────────────────────┘
```

---

## ہینڈز آن چیلنجز

### چیلنج 1: تین ٹرٹلز بنائیں

`/spawn` سروس کا استعمال کرتے ہوئے، دو اور ٹرٹلز مختلف پوزیشنوں پر بنائیں:

```bash
ros2 service call /spawn turtlesim/srv/Spawn "{x: 2.0, y: 2.0, theta: 0.0, name: 'turtle3'}"
ros2 service call /spawn turtlesim/srv/Spawn "{x: 9.0, y: 2.0, theta: 0.785, name: 'turtle4'}"
```

نتیجہ: کینوس پر چار ٹرٹلز (اصل + 3 نئے)۔

---

### چیلنج 2: turtle2 کے لیے ٹیلی پورٹ سروس تلاش کریں

آپ نے پہلے `turtle2` بنایا تھا۔ کیا آپ اس کی ٹیلی پورٹ سروس تلاش کر سکتے ہیں؟

```bash
ros2 service list | grep turtle2
```

یا ایکسپلور کریں:

```bash
ros2 service list
```

`turtle2` سے متعلقہ سروسز تلاش کریں۔

ملنے کے بعد، اسے ٹیلی پورٹ کرنے کی کوشش کریں:

```bash
ros2 service call /turtle2/teleport_absolute turtlesim/srv/TeleportAbsolute "{x: 1.0, y: 1.0, theta: 3.14159}"
```

---

### چیلنج 3: پیرامیٹرز کے ساتھ ایک رنگ ڈیزائن کریں

`ros2 param set` کا استعمال کرتے ہوئے، ایک کسٹم پس منظر کا رنگ بنائیں:

```bash
ros2 param set /turtlesim background_r 200
ros2 param set /turtlesim background_g 150
ros2 param set /turtlesim background_b 100
```

پین کا رنگ بھی تبدیل کریں اور ڈرا کریں۔ بصری نتیجہ کو ریئل ٹائم میں تبدیل ہوتے دیکھیں۔

---

## یہ کیوں اہم ہے

آپ نے اب ROS 2 کے مکمل کمیونیکیشن ٹول کٹ کو دریافت کر لیا ہے:

1. **ٹاپکس** (سبق 3.3): مسلسل pub/sub ڈیٹا سٹریمز
2. **سروسز** (یہ سبق): ریکویسٹ/رسپانس ایکشنز
3. **پیرامیٹرز**: رن ٹائم کنفیگریشن

حقیقی روبوٹ سسٹم ان سب کا استعمال کرتے ہیں:
- **ٹاپکس**: سینسر ڈیٹا (LIDAR، کیمرہ)
- **سروسز**: ہائی لیول کمانڈز (بازو کو حرکت دیں، گرپر کھولیں)
- **پیرامیٹرز**: کنفیگریشن (زیادہ سے زیادہ رفتار، حفاظتی حدود)

---

## ڈیزائن فیصلہ فریم ورک (Design Decision Framework)

جب آپ ROS 2 سسٹم بناتے ہیں، تو پوچھیں:

**کیا یہ مسلسل ہے یا الگ تھلگ (discrete)?**
- مسلسل → ٹاپک (ڈیٹا سٹریم کریں)
- الگ تھلگ → سروس (ایک بار کا ایکشن)

**کیا مجھے رسپانس کی ضرورت ہے؟**
- ہاں → سروس (تصدیق کا انتظار کریں)
- نہیں → ٹاپک (فائر اینڈ فارگیٹ)

**کیا یہ ڈیٹا ہر نوڈ کو چاہیے؟**
- ہاں → ٹاپک (براڈکاسٹ)
- نہیں → سروس (مخصوص کلائنٹ/سرور)

**فیصلوں کی مثالیں**:
- موٹر ویلاسٹی: ٹاپک (مسلسل، براڈکاسٹ)
- گرپر کمانڈ (کھولنا/بند کرنا): سروس (الگ تھلگ، تصدیق درکار ہے)
- درجہ حرارت سینسر: ٹاپک (مسلسل سٹریم)
- ایمرجنسی سٹاپ: سروس (الگ تھلگ، تصدیق درکار ہے)

---

## AI کے ساتھ کوشش کریں

**سیٹ اپ**: `turtlesim` کو چلتا رکھیں۔ اپنا AI ٹول کھولیں۔

**پرامپٹ 1** (ٹاپک بمقابلہ سروس کے تبادلے):

اپنے AI سے پوچھیں:

```
In turtlesim, velocity is published as a topic (/turtle1/cmd_vel).
Could we instead implement it as a service?
("Please move the turtle forward" → server moves it → responds "done")

What are pros and cons of using a service instead of a topic for velocity control?
```

**متوقع بصیرت**: مسلسل کنٹرول (جو بار بار فائر ہوتا ہے) کے لیے ٹاپکس بہتر ہیں، جبکہ سروسز ہر کال پر بلاک ہو جائیں گی۔ یہ استدلال آپ کے مستقبل کے ڈیزائن کے فیصلوں کی رہنمائی کرے گا۔

---

**پرامپٹ 2** (پیرامیٹر ڈیزائن):

اپنے AI سے پوچھیں:

```
Turtlesim has parameters for pen color (pen_r, pen_g, pen_b) and background color.
Why are these parameters instead of service calls?
What's the benefit of changing them at runtime rather than restarting the node?
```

**آپ کیا سیکھتے ہیں**: پیرامیٹرز نوڈز کو دوبارہ شروع کیے بغیر رن ٹائم پر ٹیوننگ کے قابل بناتے ہیں۔ سروسز کام کرتیں لیکن بلاکنگ کالز کی ضرورت پڑتی۔ ٹاپکس غیر ضروری طور پر براڈکاسٹ کرتے۔

---

**پرامپٹ 3** (روبوٹ سسٹم ڈیزائن کرنا):

اپنے AI سے پوچھیں:

```
I'm designing a mobile robot with:
- A LIDAR sensor
- A motor controller
- An emergency stop button

For each, should I use a topic, service, or parameter?
Explain your reasoning.
```

**آپ کیا سیکھتے ہیں**: حقیقی دنیا کے ڈیزائن کے فیصلے—سینسر ڈیٹا (ٹاپک)، الگ تھلگ کمانڈز (سروس)، کنفیگریشن (پیرامیٹر)۔

---

## چیک پوائنٹ: باب 3 میں مہارت

باب 4 (آپ کا پہلا کوڈ) پر جانے سے پہلے، تصدیق کریں کہ آپ یہ کر سکتے ہیں:

- [ ] **سیٹ اپ (سبق 3.1)**: ROS 2 ماحول تک رسائی حاصل کریں اور تشخیصی کمانڈز چلائیں
- [ ] **Turtlesim (سبق 3.2)**: `turtlesim` لانچ کریں اور ٹیلی اوپ سے ٹرٹل کو کنٹرول کریں
- [ ] **نوڈز اور ٹاپکس (سبق 3.3)**: نوڈز، ٹاپکس کی فہرست بنائیں، اور ریئل ٹائم ڈیٹا کو ایکو کریں
- [ ] **سروسز اور پیرامیٹرز (سبق 3.4)**: سروسز کال کریں اور پیرامیٹرز میں ترمیم کریں
- [ ] **فرق کو سمجھیں** ٹاپکس (مسلسل) اور سروسز (الگ تھلگ) کے درمیان
- [ ] **`rqt_graph` کا استعمال کرتے ہوئے سسٹم کا تصور کریں**

اگر تمام خانے چیک ہو گئے ہیں، تو آپ کے پاس وہ **ذہنی ماڈل** ہے جس کی ضرورت سبق 4 کے لیے ہے، جہاں آپ اپنا پہلا ROS 2 کوڈ (پائیتھن پبلشر/سبسکرائبر) لکھیں گے۔

---

## باب 3 مہارت گیٹ

آپ **باب 4: آپ کا پہلا ROS 2 کوڈ** کے لیے تیار ہیں جب آپ یہ کر سکتے ہیں:

✓ `turtlesim` لانچ کریں اور اسے ٹیلی اوپ سے کنٹرول کریں
✓ `ros2 node list` کا استعمال کرتے ہوئے تمام نوڈز کی فہرست بنائیں
✓ `ros2 topic list -t` کا استعمال کرتے ہوئے تمام ٹاپکس کی فہرست بنائیں
✓ `ros2 topic echo` کا استعمال کرتے ہوئے ٹاپک ڈیٹا کو ایکو کریں
✓ `ros2 service call` کا استعمال کرتے ہوئے ایک سروس کال کریں
✓ `ros2 param set` کا استعمال کرتے ہوئے ایک پیرامیٹر میں ترمیم کریں
✓ `rqt_graph` کے ساتھ نوڈز/ٹاپکس کا تصور کریں
✓ ٹاپکس اور سروسز کے درمیان فرق کی وضاحت کریں

**مبارک ہو** **باب 3: ROS 2 سے ملو** مکمل کرنے پر! آپ نے باہر سے ROS 2 کا تجربہ کیا ہے۔ باب 4 میں، آپ اپنے نوڈز لکھ کر اندر سے اس کا تجربہ کریں گے۔

---

**اگلا باب**: [→ باب 4: آپ کا پہلا ROS 2 کوڈ](../chapter-4-first-code/README.md)