---
id: lesson-4-4-try-with-ai
title: 'Lesson 4.4: Try With AI'
sidebar_position: 4
sidebar_label: 4.4 Try With AI
description: >-
  Collaborate with AI to extend pub/sub systems with validation and production
  refinement.
chapter: 4
lesson: 4
duration_minutes: 60
proficiency_level: B1
layer: L2
cognitive_load:
  new_concepts: 2
learning_objectives:
  - Collaborate with AI to extend pub/sub systems
  - Validate and refine AI-generated code
  - 'Recognize when AI knowledge exceeds your own (Teacher role, invisible)'
  - 'Guide AI using constraints and domain context (Student role, invisible)'
  - >-
    Iterate toward better designs through bidirectional refinement (Co-Worker,
    invisible)
  - Understand production-readiness concepts
skills:
  - ros2-publisher-subscriber
hardware_tier: 1
tier_1_path: Cloud ROS 2 (TheConstruct)
generated_by: content-implementer v1.0.0
created: '2025-11-29'
version: 1.0.0
---


# سبق 4.4: AI کے ساتھ کوشش کریں (Try With AI)

اب آپ کے پاس کام کرنے والے پبلشر اور سبسکرائبر نوڈز ہیں۔ وہ پیغامات بھیجتے اور وصول کرتے ہیں۔ لیکن "کام کرنے والے کوڈ" اور "پروڈکشن کوڈ" کے درمیان ایک خلا ہے۔

پروڈکشن کوڈ غلطیوں کو خوبصورتی سے سنبھالتا ہے، تشخیصات (diagnostics) کو لاگ کرتا ہے، پیرامیٹرز کو ترتیب دیتا ہے، اور ناکامیوں سے بحال ہوتا ہے۔ یہ سب ہاتھ سے لکھنا تھکا دینے والا اور غلطیوں کا شکار ہوتا ہے۔ یہ وہ جگہ ہے جہاں AI تعاون (collaboration) کی چمک نظر آتی ہے۔

اس سبق میں، آپ اپنے پب/سب سسٹم کو بہتر بنانے کے لیے AI کے ساتھ کام کریں گے۔ آپ دریافت کریں گے کہ AI کیسے ایسے پیٹرن تجویز کر سکتا ہے جن کے بارے میں آپ نہیں جانتے تھے، آپ ان تجاویز کو اپنی حدود (constraints) کے ساتھ کیسے بہتر بنا سکتے ہیں، اور کیسے تکرار (iteration) ایسے بہتر ڈیزائن تیار کرتی ہے جو آپ دونوں میں سے کوئی بھی اکیلے نہیں بنا سکتا تھا۔

---

## تین منظرنامے: دو طرفہ سیکھنے کی دریافت (Discovering Bidirectional Learning)

### منظرنامہ 1: AI آپ کو سکھاتا ہے (پیٹرن کی دریافت)

آپ کے پاس ایک سادہ پبلشر ہے۔ یہ کام کرتا ہے لیکن نامکمل لگتا ہے:

```python
def timer_callback(self):
    msg = String()
    msg.data = f'Hello World: {self.i}'
    self.publisher_.publish(msg)
    self.get_logger().info(f'Publishing: "{msg.data}"')
    self.i += 1
```

**آپ اپنے AI سے پوچھتے ہیں:**

> "میرے پاس ایک سادہ ROS 2 پبلشر ہے جو String پیغامات بھیجتا ہے۔ یہ کام کرتا ہے، لیکن مجھے لگتا ہے کہ پروڈکشن کے استعمال کے لیے مجھ سے کچھ چھوٹ رہا ہے۔ پروڈکشن کے لیے تیار پبلشر کیسا نظر آئے گا؟ مجھے کوڈ میں مخصوص بہتری بتائیں۔"

**AI جواب دیتا ہے** (آپ کو پیٹرن سکھاتے ہوئے):

یہاں پروڈکشن کے لیے تیار ورژن ہے:

```python
def timer_callback(self):
    try:
        msg = String()
        msg.data = f'Hello World: {self.i}'

        # مناسب سطح پر لاگ کریں (زیادہ تفصیل کے لیے DEBUG، عام کے لیے INFO)
        self.get_logger().debug(f'Publishing message #{self.i}')

        self.publisher_.publish(msg)
        self.i += 1

        # میٹرکس کو ٹریک کریں
        if self.i % 100 == 0:
            self.get_logger().info(f'Published {self.i} messages total')

    except Exception as e:
        self.get_logger().error(f'Error in callback: {e}')
        # کریش نہ ہوں، بس لاگ کریں اور جاری رکھیں
```

**آپ نے کیا سیکھا:**
- غلطی سے نمٹنا (callbacks میں try/except)
- لاگنگ کی سطحیں (DEBUG بمقابلہ INFO بمقابلہ ERROR)
- میٹرکس ٹریکنگ (کل کتنے؟)
- خوبصورت خرابی سے بچاؤ (غلطیوں کو لاگ کریں، کریش نہ ہوں)

AI نے ہزاروں ROS 2 پروجیکٹس سے پیٹرن تجویز کیے — ایسے پیٹرن جو آپ شاید مہینوں تک خود دریافت نہ کر پاتے۔

---

### منظرنامہ 2: آپ AI کو سکھاتے ہیں (حدود کی بہتری - Constraint Refinement)

AI کی تجویز اچھی ہے لیکن آپ کی حدود (constraints) کے مطابق نہیں ہے:

**آپ جواب دیتے ہیں:**

> "یہ اچھا لگتا ہے، لیکن ہمارے سسٹم میں بینڈوتھ کی سخت حدود ہیں۔ ہم زیادہ سے زیادہ 10 پیغامات فی سیکنڈ بھیج سکتے ہیں۔ آپ کا کوڈ ہر 0.5 سیکنڈ میں پبلش کرتا ہے (فی سیکنڈ 2 بار)۔ نیز، ہمیں DEBUG لاگنگ کی ضرورت نہیں ہے — صرف سنگ میل (milestone) والے پیغامات۔ کیا آپ مجھے دکھا سکتے ہیں کہ اسے قابل ترتیب (configurable) کیسے بنایا جائے تاکہ ہم دوبارہ بنائے بغیر (rebuilding) ریٹ تبدیل کر سکیں؟"

**AI موافقت کرتا ہے** (آپ کی حدود سے سیکھتے ہوئے):

یہاں ایک قابل ترتیب ورژن ہے:

```python
class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')

        # قابل ترتیب پیرامیٹر کا اعلان کریں
        self.declare_parameter('publish_rate_hz', 2.0)
        rate = self.get_parameter('publish_rate_hz').value

        self.publisher_ = self.create_publisher(String, 'topic', 10)
        self.timer = self.create_timer(1.0/rate, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        try:
            msg = String()
            msg.data = f'Hello World: {self.i}'
            self.publisher_.publish(msg)
            self.i += 1

            # صرف سنگ میل لاگ کریں (ہر 10 پیغامات پر)
            if self.i % 10 == 0:
                self.get_logger().info(f'Milestone: {self.i} messages published')

        except Exception as e:
            self.get_logger().error(f'Error: {e}')
```

**اب آپ دوبارہ بنائے بغیر ریٹ کو کنٹرول کر سکتے ہیں:**

```bash
# ایک بار دوبارہ بنائیں
cd ~/ros2_ws && colcon build

# ڈیفالٹ ریٹ (2 Hz) کے ساتھ چلائیں
ros2 run my_first_package minimal_publisher

# کسٹم ریٹ (1 Hz - بینڈوتھ کی حد کا احترام کرتا ہے) کے ساتھ چلائیں
ros2 run my_first_package minimal_publisher --ros-args -p publish_rate_hz:=1.0
```

**کیا ہوا:**
- آپ نے اپنی حد فراہم کی (زیادہ سے زیادہ 10 پیغامات/سیکنڈ)
- AI نے اپنی تجویز کو بہتر بنایا (اسے قابل ترتیب بنایا)
- اب آپ دوبارہ کمپائل کیے بغیر رن ٹائم پر ریٹ کو کنٹرول کرتے ہیں

آپ کی رائے نے حل کو شکل دی۔ یہ گفتگو کسی بھی اصل تجویز سے بہتر چیز پر متفق ہوئی۔

---

### منظرنامہ 3: تکراری بہتری (Iterative Refinement) (ہم آہنگی - Convergence)

آپ کو احساس ہوا کہ پیرامیٹر کا طریقہ کار اور بھی بہتر ہو سکتا ہے:

**آپ پوچھتے ہیں:**

> "اچھا! اب میں اسے مزید آگے لے جانا چاہتا ہوں۔ مختلف روبوٹس مختلف میسج ٹائپس استعمال کرتے ہیں (سادہ کے لیے String، ویلاسٹی کمانڈز کے لیے geometry_msgs/Twist)۔ کیا ہم ایسا سسٹم ڈیزائن کر سکتے ہیں جہاں میں کوڈ میں ترمیم کیے بغیر ریٹ اور میسج ٹائپ دونوں تبدیل کر سکوں؟ میں سوچ رہا ہوں: ایک بیس کلاس یا ایبسٹریکشن جو اسے آسان بنا دے۔"

**AI تجویز کرتا ہے:**

```python
from abc import ABC, abstractmethod

class ConfigurablePublisher(Node, ABC):
    """پروڈکشن پبلشرز کے لیے بیس کلاس۔"""

    def __init__(self, node_name, topic_name, msg_type, queue_size=10):
        super().__init__(node_name)

        # قابل ترتیب پیرامیٹرز
        self.declare_parameter('publish_rate_hz', 2.0)
        self.declare_parameter('topic_name', topic_name)

        rate = self.get_parameter('publish_rate_hz').value
        topic = self.get_parameter('topic_name').value

        self.publisher_ = self.create_publisher(msg_type, topic, queue_size)
        self.timer = self.create_timer(1.0/rate, self.timer_callback)
        self.message_count = 0

    @abstractmethod
    def create_message(self):
        """سب کلاسز مناسب میسج ٹائپ بنانے کے لیے اسے نافذ کرتی ہیں۔"""
        pass

    def timer_callback(self):
        try:
            msg = self.create_message()
            self.publisher_.publish(msg)
            self.message_count += 1

            if self.message_count % 10 == 0:
                self.get_logger().info(f'Published {self.message_count} messages')

        except Exception as e:
            self.get_logger().error(f'Error: {e}')


# String پیغامات کے لیے سب کلاس
class StringPublisher(ConfigurablePublisher):
    def __init__(self):
        super().__init__('string_publisher', 'topic', String)
        self.counter = 0

    def create_message(self):
        msg = String()
        msg.data = f'Hello World: {self.counter}'
        self.counter += 1
        return msg


# Twist پیغامات (ویلاسٹی کمانڈز) کے لیے سب کلاس
from geometry_msgs.msg import Twist

class VelocityPublisher(ConfigurablePublisher):
    def __init__(self):
        super().__init__('velocity_publisher', 'cmd_vel', Twist)

    def create_message(self):
        msg = Twist()
        msg.linear.x = 0.5  # آگے کی رفتار
        msg.angular.z = 0.1  # گردش
        return msg
```

**اب آپ کے پاس دوبارہ استعمال کے قابل انفراسٹرکچر ہے:**

```python
# String پیغامات کے لیے
string_pub = StringPublisher()

# Velocity کمانڈز کے لیے
vel_pub = VelocityPublisher()

# دونوں ایک ہی ریٹ پیرامیٹر کا احترام کرتے ہیں
# دونوں سنگ میل لاگ کرتے ہیں
# دونوں غلطیوں کو اسی طرح سنبھالتے ہیں
```

**تکرار مکمل:**
- تکرار 1: سادہ کام کرنے والا کوڈ
- تکرار 2: غلطی سے نمٹنے اور لاگنگ کے ساتھ پروڈکشن کے لیے تیار
- تکرار 3: قابل ترتیب ریٹ پیرامیٹر
- تکرار 4: متعدد میسج ٹائپس کے لیے ایبسٹریکشن

**کیا سامنے آیا:** ایک دوبارہ استعمال کے قابل پیٹرن جسے آپ میں سے کسی نے بھی آزادانہ طور پر ڈیزائن نہیں کیا۔ AI نے پیٹرن تجویز کیا، آپ نے اسے حدود کے ساتھ بہتر بنایا، اور مل کر آپ ایک خوبصورت ایبسٹریکشن پر متفق ہوئے۔

تکرار کے ذریعے، ڈیزائن اس سے بہتر ہوا جو کسی بھی ابتدائی نقطہ پیش کر سکتا تھا۔

---

## کیا ہوا

بہاؤ پر توجہ دیں:
1. **آپ نے پوچھا** → AI نے پروڈکشن پیٹرن تجویز کیے۔
2. **آپ نے مزاحمت کی** → AI نے آپ کی بینڈوتھ کی حد کے مطابق ڈھال لیا۔
3. **آپ نے تکرار کی** → ڈیزائن ایک خوبصورت ایبسٹریکشن پر متفق ہوا۔

یہ مکالمہ کا پیٹرن کیریئر میں دہرایا جاتا ہے۔ آپ کے سوالات اور حدود جتنے زیادہ مخصوص ہوں گے، AI اتنا ہی زیادہ کارآمد ہوگا۔

---

## ہدایت یافتہ مشق: آپ کی باری

اب آپ کوشش کریں۔ اپنے AI سے پوچھنے کے لیے ان منظرناموں میں سے ایک کا انتخاب کریں:

### مشق کا اختیار 1: سبسکرائبر کی مضبوطی (Robustness)

آپ کے پاس ایک سبسکرائبر ہے جو پیغامات وصول کرتا ہے۔ اپنے AI سے پوچھیں:

> "میرے پاس ایک ROS 2 سبسکرائبر ہے جو String پیغامات وصول کرتا ہے اور انہیں پرنٹ کرتا ہے۔ میں اسے مضبوط بنانا چاہتا ہوں: جب پبلشر مر جائے (5 سیکنڈ تک کوئی پیغام نہ آئے) تو اس کا پتہ لگائیں، اعدادوش পরিসংখ্যান (statistics) لاگ کریں (کل موصول شدہ، ریٹ)، اور خراب شدہ پیغامات کو خوبصورتی سے سنبھالیں۔ کوڈ دکھائیں۔"

متوقع نتیجہ: AI ٹائم آؤٹ کا پتہ لگانے، میٹرکس، اور غلطی سے نمٹنے کے پیٹرن تجویز کرتا ہے۔ آپ اپنی ضروریات کی بنیاد پر اسے بہتر بناتے ہیں۔ آپ ایک مضبوط ڈیزائن کی طرف تکرار کرتے ہیں۔

### مشق کا اختیار 2: ملٹی نوڈ رابطہ (Coordination)

آپ کے پاس ایک پبلشر اور ایک سبسکرائبر ہے۔ اپنے AI سے پوچھیں:

> "میں اپنے سسٹم کو بڑھانا چاہتا ہوں: ایک پبلشر ویلاسٹی کمانڈز بھیجتا ہے، تین مختلف سبسکرائبر موٹر کنٹرول، اوڈومیٹری لاگنگ، اور حفاظت کی نگرانی سنبھالتے ہیں۔ میں اسے دیکھ بھال کے لیے کیسے منظم کروں؟ کیا ہر سبسکرائبر ایک الگ نوڈ ہونا چاہیے یا کیا وہ ایک کا اشتراک کر سکتے ہیں؟"

متوقع نتیجہ: AI فوائد اور نقصانات کی وضاحت کرتا ہے۔ آپ اپنے استعمال کے کیس کی بنیاد پر فیصلہ کرتے ہیں۔ آپ فن تعمیر (architecture) پر تکرار کرتے ہیں۔

### مشق کا اختیار 3: ہارڈ ویئر ایبسٹریکشن

آپ کے پاس ایک سادہ پبلشر ہے۔ اپنے AI سے پوچھیں:

> "یہ پبلشر میرے لیپ ٹاپ پر کام کرتا ہے لیکن اسے تین مختلف روبوٹ پلیٹ فارمز (Jetson، Raspberry Pi، اور ایک کلاؤڈ VM) پر کام کرنے کی ضرورت ہے۔ میسج ٹائپ اور ریٹ ایک جیسا ہے، لیکن نیٹ ورک کا راستہ مختلف ہے۔ میں اسے کیسے ایبسٹریکٹ کروں تاکہ پبلشر کا کوڈ پلیٹ فارمز کے درمیان تبدیل نہ ہو؟"

متوقع نتیجہ: AI کنفیگریشن فائلوں یا ماحولیاتی متغیرات (environment variables) کی تجویز دیتا ہے۔ آپ اپنی تعیناتی (deployment) کی ضروریات کی بنیاد پر اسے بہتر بناتے ہیں۔ آپ ایک پورٹیبل ڈیزائن کی طرف تکرار کرتے ہیں۔

---

## AI سے تیار کردہ کوڈ کی توثیق (Validating AI-Generated Code)

جب AI کوڈ تجویز کرتا ہے، تو ہمیشہ اس کی تصدیق کریں کہ آیا یہ کام کرتا ہے:

```python
# AI یہ تجویز کرتا ہے — کیا یہ سمجھ میں آتا ہے؟
self.declare_parameter('publish_rate_hz', 2.0)
rate = self.get_parameter('publish_rate_hz').value
self.timer = self.create_timer(1.0/rate, self.timer_callback)

# اسے جانچیں:
# کیا میں سمجھ سکتا ہوں کہ ہر لائن کیا کرتی ہے؟
# ✓ 'publish_rate_hz' نامی پیرامیٹر کو ڈیفالٹ 2.0 Hz کے ساتھ اعلان کریں
# ✓ پیرامیٹر کی قیمت پڑھیں
# ✓ مدت = 1.0/rate کے ساتھ ایک ٹائمر بنائیں

# کیا یہ کمپائل/چلتا ہے؟
# ✓ ہاں، کم از کم تنہائی میں

# کیا یہ ROS 2 Humble پیٹرن سے میل کھاتا ہے؟
# ✓ ہاں، پیرامیٹرز کا اعلان، پڑھنا، اور اس طرح استعمال کیا جاتا ہے

# کیا کوئی کنارے کے معاملات (edge cases) ہو سکتے ہیں؟
# ✓ کیا ہوگا اگر ریٹ 0 ہو؟ (1.0/0 پر کریش ہو جائے گا)
# ✓ بہتر ہے کہ توثیق کریں: اگر ریٹ <= 0 ہو، تو غلطی لاگ کریں اور ڈیفالٹ استعمال کریں

# اپنے تجزیہ کی بنیاد پر کوڈ کو بہتر بنائیں
```

ہمیشہ تجویز کردہ کوڈ کا تجربہ کریں۔ AI زیادہ تر وقت صحیح ہوتا ہے لیکن وہ کنارے کے معاملات سے محروم ہو سکتا ہے جنہیں آپ کا ڈومین علم پکڑ لیتا ہے۔

---

## دیکھنے کے لیے عام AI غلطیاں

1. **پرانا API**: "یہ ROS 1 کا طریقہ ہے۔ ROS 2 Humble نے اسے بدل دیا۔ نیا پیٹرن کیا ہے؟"
2. **غائب شدہ درآمدات (imports)**: "آپ کا کوڈ Twist استعمال کرتا ہے لیکن اسے درآمد نہیں کرتا۔ Twist کس پیکیج سے آتا ہے؟"
3. **غیر محفوظ ڈیفالٹس**: "آپ کا کوڈ پیرامیٹرز کی توثیق نہیں کرتا۔ اگر ریٹ منفی ہو تو کیا ہونا چاہیے؟"
4. **زیادہ انجینئرنگ (Overengineering)**: "یہ ایک سادہ ضرورت کے لیے بہت زیادہ ایبسٹریکشن ہے۔ کیا ہم اسے آسان بنا سکتے ہیں؟"

جب آپ کوئی غلطی پکڑیں، تو اسے درست کریں اور AI کو صحیح طریقہ دکھائیں۔ AI آپ کی اصلاحات سے سیکھتا ہے۔

---

## ros2-publisher-subscriber مہارت کا استعمال

اس باب کے دوران، آپ نے `ros2-publisher-subscriber` مہارت سے پیٹرن استعمال کیے ہیں۔ اس مہارت نے یہ چیزیں محفوظ کیں:

- **پبلشر پیٹرن**: نوڈ کلاس، ٹائمر کال بیک، پبلش سائیکل
- **سبسکرائبر پیٹرن**: نوڈ کلاس، سبسکرپشن کال بیک، میسج ہینڈلنگ
- **عام غلطیاں**: صفائی بھول جانا، غلط درآمدات، کیو کی گہرائی کا الجھن
- **تشخیص کے طریقے**: ros2 topic echo، ros2 topic info کا استعمال

یہ مہارت موجود ہے تاکہ جب بھی آپ کوئی اور پب/سب نوڈ لکھیں، تو آپ شروع سے شروع نہ کریں۔ آپ ثابت شدہ پیٹرن کا حوالہ دیتے ہیں اور اسے اپناتے ہیں۔

یہ پیٹرن آپ کی سیکھنے میں بڑھتا جائے گا:
- **ماڈیول 1**: آپ پب/سب سیکھتے ہیں
- **ماڈیول 2**: آپ سینسر ڈیٹا (LIDAR، کیمرہ) کے لیے پب/سب استعمال کرتے ہیں
- **ماڈیول 3**: آپ متعدد پب/سب نوڈز کو ایک سسٹم میں جوڑتے ہیں
- **ماڈیول 4**: آپ ایک پیچیدہ خود مختار نظام کے حصے کے طور پر پب/سب استعمال کرتے ہیں

---

## اس باب میں تخلیق کی گئی ذہانت

### ros2-publisher-subscriber مہارت

**یہ کیا شامل کرتا ہے:**
- ROS 2 نوڈ کی ساخت (init → timer/callback → spin → shutdown)
- پبلشر پیٹرن (create_publisher → publish)
- سبسکرائبر پیٹرن (create_subscription → callback)
- عام پیرامیٹرز (QoS کیو کی گہرائی، ٹاپک کے نام)
- ڈیبگنگ کی تکنیکیں (ros2 topic echo، ros2 topic info)

**کب استعمال کریں:**
- کوئی بھی ROS 2 پبلشر یا سبسکرائبر لکھتے وقت
- موجودہ پب/سب نوڈز کو بڑھاتے وقت
- دوسروں کو یہ پیٹرن سکھاتے وقت

**کتابوں میں قدر:**
- کسی بھی روبوٹکس کورس کو اس پیٹرن کی ضرورت ہے
- ROS 2 صنعت میں معیاری مڈل ویئر ہے
- یہ پیٹرن مستقبل کی کتابوں میں بڑھتا جائے گا

---

## عکاسی: آپ نے کیا حاصل کیا

**اس سبق میں، آپ نے:**
- کوڈ کو بہتر بنانے کے لیے AI کے ساتھ کام کیا
- اپنی مخصوص حدود کے ساتھ AI کی رہنمائی کی
- بات چیت کے ذریعے بہتر ڈیزائن کی طرف تکرار کی
- AI سے تیار کردہ کوڈ کو تنقیدی طور پر درست کیا
- پروڈکشن کے لیے تیار پیٹرن بنائے

**اس باب میں، آپ نے:**
- شروع سے ایک ROS 2 ورک اسپیس بنایا
- colcon کے ساتھ پیکیجز لکھے
- ایک پبلشر لکھا (ڈیٹا بھیجنا)
- ایک سبسکرائبر لکھا (ڈیٹا وصول کرنا)
- ان دونوں کو بہتر بنانے کے لیے AI کے ساتھ تعاون کیا

**ماڈیول 1 میں، آپ نے:**
- جسمانی بمقابلہ سافٹ ویئر AI کو سمجھا (باب 1)
- روبوٹس کے سینس کرنے اور حرکت کرنے کا طریقہ جانا (باب 2)
- CLI کے ذریعے ROS 2 کو دریافت کیا (باب 3)
- Python میں ROS 2 کوڈ لکھ سکتے ہیں (باب 4)

آپ باب 7 میں کیپ اسٹون پروجیکٹ کی طرف بڑھ رہے ہیں، جہاں آپ ان تمام ٹکڑوں کو ایک مکمل ملٹی نوڈ سسٹم میں ضم کریں گے۔

---

## AI کے ساتھ کوشش کریں (حتمی چیلنج)

یہ بغیر کسی رہنمائی کے تین کرداروں کے پیٹرن پر عمل کرنے کا آپ کا موقع ہے۔ کسی ایسے منظرنامے کا انتخاب کریں جو آپ کو متوجہ کرے اور AI کے ساتھ تعاون کریں:

### چیلنج 1: کارکردگی کی اصلاح (Performance Optimization)

> "میرا پبلشر اور سبسکرائبر کام کر رہے ہیں لیکن سست محسوس ہوتے ہیں۔ پبلشر 100 بار فی سیکنڈ پبلش کرتا ہے لیکن سبسکرائبر فی سیکنڈ صرف 50 پیغامات پر عمل کر سکتا ہے۔ پیغامات چھوٹ رہے ہیں۔ آپ اس کی تشخیص کیسے کریں گے؟ حل کیا ہیں؟ آئیے مل کر ایک ڈیزائن کریں۔"

متوقع نتیجہ: AI تشخیص (ros2 topic hz)، ممکنہ حل (کیو کی گہرائی بڑھانا، کال بیک کو بہتر بنانا، پبلش ریٹ کم کرنا)، ہر ایک کے لیے فوائد اور نقصانات تجویز کرتا ہے۔ آپ اپنی ضروریات کے مطابق ایک حل پر متفق ہوتے ہیں۔

### چیلنج 2: غلطی سے بحالی (Error Recovery)

> "اگر پبلشر کریش ہو جاتا ہے، تو سبسکرائبر ایسے ڈیٹا تک رسائی حاصل کرنے کی کوشش کرتا ہے جو اب بھیجا نہیں جا رہا ہے۔ آپ اس کو سنبھالنے کا بہترین طریقہ کیا سمجھتے ہیں؟ کیا سبسکرائبر کو ٹائم آؤٹ ہونا چاہیے اور باہر نکل جانا چاہیے؟ ایک انتباہ لاگ کرنا چاہیے؟ دوبارہ منسلک کرنے کی کوشش کرنی چاہیے؟ مجھے پیٹرن سکھائیں۔"

متوقع نتیجہ: AI ٹائم آؤٹ پیٹرن، ایکسپوننشل بیک آف، ہیلتھ مانیٹرنگ سکھاتا ہے۔ آپ اپنے سسٹم کی اہمیت کی بنیاد پر اسے بہتر بناتے ہیں۔ آپ ایک مضبوط حل کی طرف تکرار کرتے ہیں۔

### چیلنج 3: سسٹم فن تعمیر (System Architecture)

> "میرے پاس اب ایک سادہ پب/سب سسٹم ہے، لیکن حتمی پروڈکٹ میں 5 پبلشرز اور 8 سبسکرائبرز کی ضرورت ہے جو سب آپس میں بات چیت کر رہے ہیں۔ میں اس کوڈ کو کیسے منظم کروں؟ کیا یہ ایک بڑا پیکیج ہونا چاہیے یا متعدد پیکیجز؟ میں اسے قابل دیکھ بھال کیسے رکھوں؟"

متوقع نتیجہ: AI ماڈیولٹی کے فوائد اور نقصانات کی وضاحت کرتا ہے۔ آپ اپنی ٹیم کی ساخت کی بنیاد پر فیصلہ کرتے ہیں۔ آپ ایک ایسے فن تعمیر کی طرف تکرار کرتے ہیں جو بڑھتا ہے۔

---

## عکاسی کریں

ان سوالات پر غور کریں:

1. **AI کی تجویز نے آپ کو کب حیران کیا؟** آپ نے کون سے پیٹرن یا تکنیک سیکھے جو آپ خود دریافت نہیں کرتے؟

2. **آپ نے کب مزاحمت کی؟** آپ کی مخصوص حدود فراہم کرنے سے AI کی تجاویز کیسے تبدیل ہوئیں؟

3. **تکرار کے ذریعے کیا سامنے آیا؟** حتمی ڈیزائن آپ کے ابتدائی خیال اور AI کی پہلی تجویز سے کس طرح مختلف تھا؟

4. **آپ اس مکالمہ کے پیٹرن کو کہاں لاگو کر سکتے ہیں؟** آپ کے کام میں کون سے دوسرے مسائل اس قسم کی تکراری بہتری سے فائدہ اٹھا سکتے ہیں؟

---

آپ نے پب/سب میں مہارت حاصل کر لی ہے۔ باب 5 میں، آپ سروسز (request/response)، کسٹم میسج ٹائپس، اور ٹاپکس اور سروسز کے درمیان انتخاب کے لیے ڈیزائن پیٹرن سیکھیں گے۔