---
id: lesson-4-1-workspaces-packages
title: 'Lesson 4.1: Workspaces and Packages'
sidebar_position: 1
sidebar_label: 4.1 Workspaces & Packages
description: >-
  Create your first ROS 2 workspace and package, understanding the build system
  structure.
chapter: 4
lesson: 1
duration_minutes: 60
proficiency_level: A2-B1
layer: L1
cognitive_load:
  new_concepts: 2
learning_objectives:
  - Create a ROS 2 workspace from scratch
  - Understand package.xml purpose and structure
  - Build packages using colcon
  - Verify workspace environment sourcing
skills:
  - ros2-fundamentals
  - package-management
hardware_tier: 1
tier_1_path: Cloud ROS 2 (TheConstruct) or local installation with fallback to cloud
generated_by: content-implementer v1.0.0
created: '2025-11-29'
version: 1.0.0
---


# سبق 4.1: ورک اسپیسز اور پیکیجز

ROS 2 کے ساتھ آپ کے پہلے عملی تجربے میں خوش آمدید! اب تک، آپ نے کمانڈ لائن کے ذریعے ROS 2 کو دریافت کیا ہے — موجودہ نوڈز چلانا، نوڈ گراف کا معائنہ کرنا، سروسز کو کال کرنا۔ اب وقت آگیا ہے کہ آپ اپنا کوڈ لکھیں اور اسے مناسب طریقے سے منظم کریں۔

اس سے پہلے کہ آپ ROS 2 نوڈ لکھ سکیں، آپ کو یہ سمجھنا ہوگا کہ ROS 2 پروجیکٹس کیسے ترتیب دیئے جاتے ہیں۔ ROS 2 ورک اسپیس کو ایک فولڈر کے طور پر سمجھیں جس میں آپ کا تمام سورس کوڈ، بلڈ آرٹیفیکٹس، اور کمپائلڈ باائنریز شامل ہیں۔ اس ورک اسپیس کے اندر پیکیجز انفرادی پروجیکٹس ہیں — ہر ایک اپنے کوڈ، کنفیگریشن، اور میٹا ڈیٹا کے ساتھ ایک خود ساختہ ماڈیول ہے۔

اس سبق میں، آپ شروع سے اپنا پہلا ورک اسپیس بنائیں گے، سمجھیں گے کہ ایک پیکیج کے اندر کیا ہوتا ہے، اور سیکھیں گے کہ `colcon` کے ساتھ اپنے کوڈ کو کیسے بلڈ کیا جائے۔

---

## ورک اسپیسز کو سمجھنا

ROS 2 ورک اسپیس صرف ایک ڈائریکٹری ہے جو ایک مخصوص ڈھانچے کی پیروی کرتی ہے۔ جب آپ ایک ورک اسپیس کو بلڈ کرتے ہیں، تو ROS 2 ٹولز جانتے ہیں کہ آپ کا کوڈ کہاں سے تلاش کرنا ہے، اسے کمپائل کرنا ہے، اور آپ کے ماحول کو اس طرح ترتیب دینا ہے کہ آپ اسے چلا سکیں۔

### عام ورک اسپیس ڈھانچہ

جب آپ ایک ورک اسپیس بناتے ہیں، تو اس میں تین اہم ڈائریکٹریاں ہوتی ہیں:

```
ros2_ws/
├── src/                    # آپ کا سورس کوڈ یہاں رہتا ہے
│   └── my_first_package/
│       ├── my_first_package/
│       ├── setup.py
│       ├── setup.cfg
│       ├── package.xml
│       └── resource/
├── build/                  # بلڈ آرٹیفیکٹس (colcon کے ذریعے بنائے گئے)
├── install/                # کمپائلڈ باائنریز اور اسکرپٹس
└── log/                     # بلڈ لاگز
```

**اہم ڈائریکٹریاں:**
- **src/**: جہاں آپ کوڈ لکھتے ہیں۔ یہ واحد ڈائریکٹری ہے جسے آپ عام طور پر ہاتھ سے ایڈٹ کرتے ہیں۔
- **build/**: عارضی بلڈ فائلیں۔ آپ اسے محفوظ طریقے سے ڈیلیٹ کر سکتے ہیں — `colcon` اسے دوبارہ بنا دے گا۔
- **install/**: کمپائل شدہ آؤٹ پٹ۔ یہ وہ ہے جسے آپ دراصل چلاتے ہیں۔

### یہ ڈھانچہ کیوں؟

یہ تین ڈائریکٹریز کا طریقہ کار کاموں کو الگ کرتا ہے:
- **src/** = "جو میں نے لکھا"
- **build/** = "کمپائل کرتے وقت عارضی فائلیں"
- **install/** = "جو میں چلا سکتا ہوں"

اس کا مطلب ہے کہ آپ `build/` اور `install/` کو ڈیلیٹ کر سکتے ہیں بغیر کسی کام کو کھوئے ہوئے۔ اس کا یہ بھی مطلب ہے کہ آپ ایک ہی مشین پر ایک سے زیادہ ورک اسپیس رکھ سکتے ہیں، ہر ایک کی اپنی بلڈ اور انسٹال ڈائریکٹریاں ہوں گی۔

---

## اپنا پہلا ورک اسپیس بنانا

آئیے ایک ورک اسپیس بناتے ہیں۔ آپ یہ ایک بار کریں گے، پھر اس کے اندر بار بار پیکیجز شامل کریں گے۔

### مرحلہ 1: ورک اسپیس کا ڈھانچہ بنائیں

ایک ٹرمینل کھولیں اور چلائیں:

```bash
# ورک اسپیس ڈائریکٹری بنائیں
mkdir -p ~/ros2_ws/src

# اس میں جائیں
cd ~/ros2_ws
```

بس اتنا ہی۔ آپ نے ایک ورک اسپیس بنا لیا ہے۔ جب آپ `src/` کے اندر پیکیجز کو بلڈ کریں گے تو ROS 2 خود بخود اس فولڈر کو پہچان لے گا۔

**اگر آپ کلاؤڈ ROS 2** (TheConstruct) استعمال کر رہے ہیں:
- اپنا ROS 2 Humble ورک اسپیس ٹرمینل کھولیں
- اوپر والے وہی احکامات چلائیں

### مرحلہ 2: ماحول کی تصدیق کریں

کچھ بھی بلڈ کرنے سے پہلے، تصدیق کریں کہ ROS 2 صحیح طریقے سے انسٹال ہے:

```bash
# چیک کریں کہ ros2 کمانڈ دستیاب ہے
echo $ROS_DISTRO
```

متوقع آؤٹ پٹ: `humble`

اگر آپ کو کوئی خرابی ملتی ہے، تو آپ کو ROS 2 سیٹ اپ اسکرپٹ کو سورس کرنے کی ضرورت ہو سکتی ہے:

```bash
# مقامی تنصیب کے لیے
source /opt/ros/humble/setup.bash

# دوبارہ تصدیق کریں
echo $ROS_DISTRO
```

### مرحلہ 3: اپنے ورک اسپیس کو بلڈ کریں (حالانکہ یہ خالی ہے)

اپنے ورک اسپیس میں جائیں اور اسے بلڈ کریں:

```bash
cd ~/ros2_ws
colcon build
```

یہ `build/` اور `install/` ڈائریکٹریاں بنائے گا۔ متوقع آؤٹ پٹ:

```
Starting >>> ros2_ws
Finished <<< ros2_ws [0.05s]

Summary: 0 packages processed
```

آپ نے ابھی تک کوئی پیکیج شامل نہیں کیا ہے، اس لیے یہ "0 packages processed" دکھا رہا ہے۔ یہ نارمل ہے۔

---

## اپنا پہلا پیکیج بنانا

اب آئیے اپنے ورک اسپیس کے اندر ایک پیکیج بناتے ہیں۔ ایک پیکیج ROS 2 کی تنظیم کی اکائی ہے — ایک فولڈر جس میں کوڈ، انحصار (dependencies)، اور میٹا ڈیٹا شامل ہوتا ہے۔

### پیکیج بنانا

`ros2 pkg create` کمانڈ استعمال کریں:

```bash
cd ~/ros2_ws
ros2 pkg create my_first_package --build-type ament_python
```

یہ Python استعمال کرتے ہوئے "my_first_package" نام کا ایک پیکیج بناتا ہے۔ آئیے دیکھتے ہیں کہ ابھی کیا ہوا:

**بنائی گئی ڈائریکٹری:**
```
src/
└── my_first_package/
    ├── my_first_package/          # Python پیکیج ڈائریکٹری
    │   └── __init__.py
    ├── test/                       # یونٹ ٹیسٹ کے لیے (ہم ابھی اسے چھوڑ دیں گے)
    ├── setup.py                    # Python پیکیج میٹا ڈیٹا
    ├── setup.cfg                   # Python پیکیج کنفیگریشن
    ├── package.xml                 # ROS 2 پیکیج میٹا ڈیٹا
    └── resource/
        └── my_first_package
```

اہم فائل **package.xml** ہے — یہ ROS 2 کو بتاتی ہے کہ یہ پیکیج کیا ہے اور اس کے انحصار کیا ہیں۔

### package.xml کو سمجھنا

آئیے دیکھتے ہیں کہ کیا بنایا گیا ہے:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_first_package</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="you@example.com">you</maintainer>
  <license>TODO</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>

  <test_depend>ament_cmake_pytest</test_depend>

  <exec_depend>ros2launch</exec_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

**ہر سیکشن کا کیا مطلب ہے:**

| سیکشن | مقصد |
|---------|---------|
| `<name>` | پیکیج کی شناخت (امپورٹس اور کمانڈز میں استعمال ہوتا ہے) |
| `<version>` | سیمیٹک ورژن (نئے پیکیجز کے لیے 0.0.0 عام ہے) |
| `<description>` | انسان کے پڑھنے کے قابل تفصیل |
| `<maintainer>` | اس پیکیج کو کون برقرار رکھتا ہے |
| `<license>` | لائسنس کی قسم (MIT، Apache-2.0، وغیرہ) |
| `<depend>` | رن ٹائم انحصار (وہ کوڈ جسے آپ امپورٹ کرتے ہیں) |
| `<test_depend>` | صرف ٹیسٹ کے لیے انحصار |
| `<exec_depend>` | قابل عمل انحصار (جیسے `ros2launch`) |
| `<build_type>` | یا تو `ament_python` یا `ament_cmake` |

**`<depend>` اندراجات اہم ہیں۔** جب آپ ایسا کوڈ لکھتے ہیں جو `rclpy` (ROS 2 کی Python لائبریری) کو امپورٹ کرتا ہے، تو آپ کو `rclpy` کو انحصار کے طور پر درج کرنا ہوگا۔ ROS 2 اس کا استعمال کرتا ہے:
1. یہ چیک کرنے کے لیے کہ انحصار انسٹال ہیں یا نہیں
2. پیکیجز کو صحیح ترتیب میں بلڈ کرنے کے لیے (اگر A کا انحصار B پر ہے، تو پہلے B کو بلڈ کریں)
3. Python امپورٹ پاتھ کو صحیح طریقے سے ترتیب دینے کے لیے

---

## اپنے ورک اسپیس کو بلڈ کرنا

اب جب کہ آپ کے پاس ایک پیکیج ہے، پورے ورک اسپیس کو بلڈ کریں:

```bash
cd ~/ros2_ws
colcon build
```

متوقع آؤٹ پٹ:

```
Starting >>> my_first_package
Compiling Cython modules...
Finished <<< my_first_package [2.34s]

Summary: 1 package processed
```

**کیا ہوا؟**
1. `colcon` کو `src/` میں 1 پیکیج ملا (my_first_package)
2. اس نے Python بلڈ پروسیس چلایا
3. اس نے پیکیج کو `install/` میں انسٹال کر دیا۔

آپ کسی بھی وقت `build/` اور `install/` کو محفوظ طریقے سے ڈیلیٹ کر سکتے ہیں۔ دوبارہ بلڈ کرنے کے لیے، بس دوبارہ `colcon build` چلائیں۔

---

## ورک اسپیس کو سورس کرنا

اس ورک اسپیس سے کوئی بھی کوڈ چلانے سے پہلے، آپ کو سیٹ اپ اسکرپٹ کو سورس کرنا ہوگا۔ یہ آپ کے شیل ماحول کو آپ کے پیکیجز کو تلاش کرنے کے لیے تبدیل کرتا ہے:

```bash
source ~/ros2_ws/install/setup.bash
```

اب آپ کے شیل کو `install/` میں موجود ہر چیز کے بارے میں معلوم ہے۔ اگر آپ کوئی Python اسکرپٹ یا لانچ فائل لکھتے ہیں، تو ROS 2 اسے تلاش کر لے گا۔

**اہم:** آپ کو اپنا کوڈ چلانے سے **پہلے** ورک اسپیس کو سورس کرنا ضروری ہے۔ اگر آپ ایک نیا ٹرمینل کھولتے ہیں، تو آپ کو دوبارہ سورس کرنا ہوگا۔

### تصدیق کریں کہ سورسنگ کام کر گئی

```bash
echo $ROS_PACKAGE_PATH
```

آپ کو ایک ایسا پاتھ دیکھنا چاہیے جس میں `~/ros2_ws/install` شامل ہو۔ یہ تصدیق کرتا ہے کہ ورک اسپیس آپ کے سرچ پاتھ میں ہے۔

---

## ورک فلو: بنائیں → بلڈ کریں → سورس کریں → چلائیں

یہ وہ ورک فلو ہے جسے آپ کوڈ شامل کرنے پر دہرائیں گے:

```
1. src/ میں فائلیں بنائیں/ایڈٹ کریں
   └── Python کوڈ، package.xml، وغیرہ ایڈٹ کریں

2. ورک اسپیس کو بلڈ کریں
   └── cd ~/ros2_ws && colcon build

3. ورک اسپیس کو سورس کریں
   └── source ~/ros2_ws/install/setup.bash

4. اپنا نوڈ چلائیں
   └── ros2 run my_first_package my_node_name
```

---

## عام مسائل کا حل (Troubleshooting)

**خرابی: "colcon: command not found"**
- آپ کو `colcon` انسٹال کرنے کی ضرورت ہے: `pip install colcon-common-extensions`
- یا کلاؤڈ ROS 2 (TheConstruct) استعمال کریں جہاں یہ پہلے سے انسٹال ہے۔

**خرابی: "package.xml not found"**
- یقینی بنائیں کہ جب آپ `ros2 pkg create` چلاتے ہیں تو آپ `src/` ڈائریکٹری میں ہیں۔
- پیکیج فولڈرز `src/` کے براہ راست بچے ہونے چاہئیں۔

**خرابی: "No such file or directory: ./install/setup.bash"**
- یقینی بنائیں کہ آپ نے پہلے `colcon build` چلایا ہے۔
- صحیح پاتھ کو سورس کریں: `source ~/ros2_ws/install/setup.bash`

**خرابی: "colcon build" کو کوئی پیکیج نہیں ملتا**
- چیک کریں کہ آپ کے پیکیج میں صحیح جگہ پر `package.xml` موجود ہے۔
- فولڈر ڈھانچہ چیک کریں: `~/ros2_ws/src/my_first_package/package.xml`

---

## یہ ڈھانچہ کیوں اہم ہے

یہ تین ڈائریکٹریز کا ڈھانچہ (`src/`، `build/`، `install/`) صنعت بھر میں استعمال ہوتا ہے:
- **CMake پروجیکٹس** اسی پیٹرن کا استعمال کرتے ہیں
- **ROS پروجیکٹس** (ROS 1 اور ROS 2 دونوں) اسی پیٹرن کا استعمال کرتے ہیں
- **پیشہ ورانہ C++ پروجیکٹس** اکثر اسی پیٹرن کا استعمال کرتے ہیں

اس ڈھانچے کو اب سمجھنا آپ کو پیشہ ورانہ روبوٹکس ڈویلپمنٹ کے لیے تیار کرتا ہے۔

---

## AI کے ساتھ کوشش کریں

اب آپ کے پاس ایک ورک اسپیس اور ایک پیکیج ہے۔ آئیے دیکھیں کہ AI آپ کو پیکیج مینجمنٹ کے بارے میں کیا سکھا سکتا ہے۔

**اپنے AI سے پوچھیں:**

> "میرے پاس 'my_first_package' نام کا ایک پیکیج ہے جس کے انحصار rclpy اور std_msgs پر ہیں۔ جیسے جیسے میرا کوڈ بڑھتا ہے، مجھے کن دیگر انحصار کو شامل کرنے کی ضرورت پڑ سکتی ہے؟ مجھے عام ROS 2 انحصار کی ایک چیک لسٹ دیں اور بتائیں کہ ہر ایک کو کب استعمال کرنا ہے۔"

**متوقع نتیجہ:** AI انحصار تجویز کرے گا جیسے:
- `geometry_msgs` پوزیشن/رفتار ڈیٹا کے لیے
- `sensor_msgs` کیمرہ، LIDAR، IMU ڈیٹا کے لیے
- `tf2` کوآرڈینیٹ ٹرانسفارمیشنز کے لیے (ایڈوانسڈ)
- `rclcpp` C++ نوڈز کے لیے (Python میں نہیں، لیکن جاننا اچھا ہے)

نوٹ کریں کہ AI ایسے پیٹرن جانتا ہے جنہیں انسانوں کو سیکھنے میں وقت لگا۔ آپ کو 50 ROS 2 ٹیوٹوریل پڑھنے کی ضرورت نہیں تھی — AI نے اہم انحصار کو پہلے ہی تجویز کر دیا۔

**اپنے تصور کو چیلنج کریں:**

> "کیا ہر اس چیز پر انحصار کرنا بہتر ہے جسے میں استعمال کر سکتا ہوں، یا صرف وہی انحصار شامل کرنا جب ان کی ضرورت ہو؟"

**متوقع نتیجہ:** AI ٹریڈ آف کی وضاحت کرے گا:
- **جلدی شامل کریں**: آسان انحصار کی فہرست، لیکن بڑا بلڈ
- **صرف ضرورت پڑنے پر شامل کریں**: صاف انحصار کی فہرست، لیکن آپ کچھ بھول سکتے ہیں
- **بہترین طریقہ**: ضرورت پڑنے پر شامل کریں، وجہ بتائیں

یہ وہ استدلال ہے جو تجربے سے آتا ہے۔ AI سے پوچھ کر، آپ ان پیٹرن سے سیکھ رہے ہیں جو اس نے ہزاروں ROS 2 پروجیکٹس میں دیکھے ہیں۔

---

## غور کریں

ان سوالات پر غور کریں:

1. **ROS 2 ورک اسپیس کیوں استعمال کرتا ہے؟** اگر تمام پیکیجز عالمی سطح پر انسٹال ہوتے تو کیا مسائل پیدا ہوتے؟

2. **`colcon` `build/` اور `install/` کو کیوں الگ کرتا ہے؟** ڈویلپمنٹ کے دوران یہ علیحدگی کیا فائدہ فراہم کرتی ہے؟

3. **اگر آپ سورس کرنا بھول جائیں تو کیا ہوتا ہے؟** ایک کامیاب بلڈ کے بعد "package not found" کی خرابی کو آپ کیسے تشخیص کریں گے؟

اگلے سبق میں، آپ اپنا پہلا ROS 2 نوڈ لکھیں گے — ایک پبلشر جو ڈیٹا کو ایک ٹاپک پر بھیجتا ہے۔