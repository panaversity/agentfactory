---
id: lesson-11-3-imu-contact-sensors
title: 'Lesson 11.3: IMU and Contact Sensors'
sidebar_position: 3
sidebar_label: 11.3 IMU & Contact
description: Adding inertial measurement and touch sensors to robots
duration_minutes: 60
proficiency_level: B1
layer: L1
hardware_tier: 1
learning_objectives:
  - Configure IMU sensors for orientation and acceleration data
  - Add contact sensors to detect collisions
  - Understand noise models for realistic sensor behavior
  - 'Interpret IMU data streams (acceleration, angular velocity, orientation)'
skills:
  - sensor-simulation
  - imu-config
cognitive_load:
  new_concepts: 6
tier_1_path: TheConstruct cloud environment
generated_by: content-implementer v1.0.0
created: '2025-11-29'
version: 1.0.0
---


# سبق 11.3: IMU اور کانٹیکٹ سینسرز (IMU and Contact Sensors)

## IMU اور ٹچ کی اہمیت کیوں ہے؟

**انرشل میژرمنٹ یونٹس (IMUs)** روبوٹ کی اپنی حرکت کو ماپتے ہیں:
- لینیئر ایکسیلیریشن (کیا روبوٹ آگے کی طرف تیز ہو رہا ہے؟)
- اینگولر ویلاسٹی (کیا روبوٹ گھوم رہا ہے؟)
- اوریینٹیشن (روبوٹ کس طرف منہ کیے ہوئے ہے؟)

IMUs ان چیزوں کے لیے ضروری ہیں:
- **ہیومینوئڈ واکنگ**: توازن کا پتہ لگانا اور ٹانگوں کی پوزیشن کو ایڈجسٹ کرنا
- **انرشل نیویگیشن**: GPS ناکام ہونے پر ڈیڈ ریکنگنگ (اندازے سے راستہ معلوم کرنا)
- **فال ڈیٹیکشن**: ہیومینوئڈز کو پتہ چلتا ہے کہ وہ کب گر رہے ہیں

**کانٹیکٹ سینسرز** یہ پتہ لگاتے ہیں کہ روبوٹ کسی چیز کو کب چھوتا ہے:
- **پاؤں کے سینسرز**: ہیومینوئڈ کو پتہ چلتا ہے کہ پاؤں زمین پر کب ہے
- **گریپر سینسرز**: مینیپولیٹر کو پتہ چلتا ہے کہ چیز کب پکڑی گئی ہے
- **بمپر**: موبائل روبوٹ ٹکراؤ کا پتہ لگاتا ہے

یہ سینسرز مل کر روبوٹس کو پروپریو سیپشن (اپنے جسم کے بارے میں آگاہی) اور ایکسٹریو سیپشن (رابطوں کے بارے میں آگاہی) فراہم کرتے ہیں۔

---

## IMU ڈیٹا کو سمجھنا

### IMU کے تین اجزاء

ایک IMU میں عام طور پر تین سینسرز ہوتے ہیں جو ایک ہی پیکیج میں ضم ہوتے ہیں:

**1. ایکسیلیریومیٹر** (x, y, z میں لینیئر ایکسیلیریشن ماپتا ہے)
```
Accelerometer output: (ax, ay, az) in m/s²

ٹیبل پر ساکن:
  ax = 0, ay = 0, az = 9.81  (گریوٹی نیچے کی طرف کھینچ رہی ہے!)

آگے کی طرف تیز ہوتے ہوئے:
  ax = 5.0, ay = 0, az = 9.81  (آگے کی حرکت + گریوٹی)

اچھلتے ہوئے:
  ax = 0, ay = 0, az = 20  (اوپر کی طرف ایکسیلیریشن + گریوٹی)
```

**اہم**: ایکسیلیریومیٹر ہمیشہ گریوٹی کو ماپتا ہے! یہاں تک کہ ایک ساکن سینسر بھی 9.81 m/s² نیچے کی طرف ریڈنگ دیتا ہے (وہ ایکسیلیریشن جس سے گریوٹی کو منسوخ کرنا پڑتا ہے)۔

**2. جائیروسکوپ** (رول، پچ، یاو میں اینگولر ویلاسٹی ماپتا ہے)
```
Gyroscope output: (ωx, ωy, ωz) in rad/s

ساکن:
  ωx = 0, ωy = 0, ωz = 0  (کوئی گردش نہیں)

z-axis کے گرد گھومنا (یاو) 1 چکر/سیکنڈ کی رفتار سے:
  ωx = 0, ωy = 0, ωz = 6.28  (مکمل گردش کے لیے 2π ریڈ/سیکنڈ)
```

**3. میگنیٹومیٹر** (زمین کے مقناطیسی میدان کو ماپتا ہے، کمپاس کی طرح کام کرتا ہے)
```
Magnetometer output: (mx, my, mz)

شمال کی طرف منہ کیے ہوئے:
  mx = بڑی ویلیو، my = چھوٹی، mz = چھوٹی

مشرق کی طرف منہ کیے ہوئے:
  mx = چھوٹی، my = بڑی ویلیو، mz = چھوٹی
```

**3-axis اوریینٹیشن** (تینوں سینسرز سے اخذ کردہ):
```
Orientation: (roll, pitch, yaw)
- roll: x-axis کے گرد گردش (بائیں/دائیں جھکاؤ)
- pitch: y-axis کے گرد گردش (آگے/پیچھے جھکاؤ)
- yaw: z-axis کے گرد گردش (عمودی کے گرد گردش)
```

### IMU ڈیٹا میں شور (Noise)

حقیقی IMUs میں خامیاں ہوتی ہیں:

**تعصب (Bias)**: سینسر صفر ریڈنگ دینا چاہیے لیکن غیر صفر دیتا ہے
```
Gyroscope ساکن ہونے پر رپورٹ کرتا ہے: (0.01, -0.02, 0.015) rad/s
(چھوٹی سی بہاؤ، لیکن وقت کے ساتھ جمع ہوتی جاتی ہے)
```

**شور (Noise)**: حقیقی ویلیو کے ارد گرد بے ترتیب اتار چڑھاؤ
```
Accelerometer ریڈ کرتا ہے: 9.81, 9.82, 9.79, 9.81, 9.80, ...
(بے ترتیب طریقے سے 0.01 m/s² سے مختلف ہوتا ہے)
```

**ڈرفٹ (Drift)**: وقت کے ساتھ غلطیاں جمع ہوتی جاتی ہیں
```
جائیروسکوپ ویلاسٹی کو انٹیگریٹ کرنے پر → اوریینٹیشن
1 منٹ پر: چھوٹی غلطیاں جمع ہوتی ہیں
10 منٹ پر: اوریینٹیشن کا تخمینہ غیر قابل اعتماد ہو جاتا ہے
```

سمولیشن میں، آپ حقیقی سینسر کے رویے سے مماثل ٹریننگ ڈیٹا بنانے کے لیے حقیقت پسندانہ شور ماڈلز شامل کر سکتے ہیں۔

---

## اپنے روبوٹ میں IMU شامل کرنا

### مرحلہ 1: SDF میں IMU سینسر کی تعریف کریں

اپنے روبوٹ کے بنیادی لنک (عام طور پر `base_link`) میں `imu` قسم کا `<sensor>` عنصر شامل کریں۔

**مثال: روبوٹ بیس پر IMU**

```xml
<model name="my_robot">
  <link name="base_link">
    <!-- Robot body... -->

    <!-- IMU SENSOR DEFINITION -->
    <sensor name="imu" type="imu">
      <!-- IMU parameters -->
      <imu>
        <!-- Accelerometer noise -->
        <acceleration_xyzn>
          <x>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.05</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.05</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.05</stddev>
            </noise>
          </z>
        </acceleration_xyzn>

        <!-- Gyroscope noise -->
        <angular_velocity_xyzn>
          <x>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.01</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.01</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0</mean>
              <stddev>0.01</stddev>
            </noise>
          </z>
        </angular_velocity_xyzn>
      </imu>

      <!-- Publishing behavior -->
      <always_on>1</always_on>
      <update_rate>100</update_rate>

      <!-- Topic name -->
      <plugin name="imu_controller" filename="libgazebo_ros_imu_sensor.so">
        <frame_name>base_link</frame_name>
      </plugin>
    </sensor>
  </link>
</model>
```

**کیا ہو رہا ہے:**
- `<sensor type="imu">` اسے انرشل میژرمنٹ یونٹ کے طور پر متعین کرتا ہے
- `<acceleration_xyzn>` ایکسیلیریومیٹر کے لیے شور (x, y, z محور) کی وضاحت کرتا ہے
- `<angular_velocity_xyzn>` جائیروسکوپ کے لیے شور کی وضاحت کرتا ہے
- `<stddev>0.05</stddev>` گاسین شور کا معیاری انحراف (standard deviation) ہے
- `<update_rate>100</update_rate>` فی سیکنڈ 100 بار شائع کرتا ہے (اعلی تعدد)

### مرحلہ 2: IMU کی اشاعت کی تصدیق کریں

**IMU ٹاپکس چیک کریں:**
```bash
ros2 topic list | grep imu
```

**متوقع نتیجہ:**
```
/imu
```

**IMU ڈیٹا کا معائنہ کریں:**
```bash
ros2 topic echo /imu --once
```

**نتیجہ دکھاتا ہے:**
```
header:
  seq: 1234
  stamp: {sec: 10, nsec: 500000000}
  frame_id: base_link
orientation: {x: 0.0, y: 0.0, z: 0.707, w: 0.707}  # کوارٹرنیئن (90 ڈگری گھمایا ہوا)
orientation_covariance: [0.01, ...]  # اوریینٹیشن میں غیر یقینی صورتحال
angular_velocity: {x: 0.0, y: 0.0, z: 0.1}  # 0.1 ریڈ/سیکنڈ پر گھوم رہا ہے
angular_velocity_covariance: [0.001, ...]
linear_acceleration: {x: 0.1, y: 0.0, z: 9.81}  # z میں گریوٹی
linear_acceleration_covariance: [0.0025, ...]
```

**تشریح:**
- `orientation`: روبوٹ کی پوز کوارٹرنیئن کے طور پر (رول، پچ، یاو کو انکوڈ کرتا ہے)
- `angular_velocity`: روبوٹ کتنی تیزی سے گھوم رہا ہے
- `linear_acceleration`: روبوٹ کا ایکسیلیریشن جمع گریوٹی

---

## کانٹیکٹ سینسرز شامل کرنا

کانٹیکٹ سینسرز یہ پتہ لگاتے ہیں کہ سطحیں ایک دوسرے کو کب چھوتی ہیں (ٹکراؤ، پکڑنا، پاؤں کا رابطہ)۔

### مثال: روبوٹ بمپر پر کانٹیکٹ سینسر

```xml
<model name="my_robot">
  <link name="base_link">
    <!-- Robot body... -->

    <!-- ٹکراؤ کا پتہ لگانے کے لیے ایک بمپر لنک بنائیں -->
    <collision name="bumper_collision">
      <geometry>
        <box>
          <size>0.3 0.1 0.05</size>
        </box>
      </geometry>
    </collision>
  </link>

  <link name="bumper_link">
    <!-- بمپر سینسر (صرف ایک ٹکراؤ کی شکل) -->
    <inertial>
      <mass>0.01</mass>
    </inertial>
    <collision name="bumper_collision">
      <geometry>
        <box>
          <size>0.3 0.1 0.05</size>
        </box>
      </geometry>
    </collision>
  </link>

  <!-- بمپر لگانے کے لیے جوائنٹ -->
  <joint name="bumper_joint" type="fixed">
    <parent>base_link</parent>
    <child>bumper_link</child>
    <origin xyz="0.15 0 0"/>  <!-- روبوٹ کا اگلا حصہ -->
  </joint>

  <!-- کانٹیکٹ سینسر کی تعریف -->
  <sensor name="bumper_sensor" type="contact">
    <contact>
      <collision>bumper_collision</collision>
    </contact>
    <plugin name="bumper_controller" filename="libgazebo_ros_bumper.so">
      <bumper_topic_name>bumper</bumper_topic_name>
    </plugin>
  </sensor>
</model>
```

**کیا ہو رہا ہے:**
- `bumper_link` ایک الگ لنک ہے جس میں ٹکراؤ کی شکل ہے
- `<sensor type="contact">` اس ٹکراؤ کی شکل کی نگرانی کرتا ہے
- جب روبوٹ کسی چیز سے ٹکراتا ہے، تو سینسر ایک کانٹیکٹ ایونٹ شائع کرتا ہے
- پلگ ان ایونٹ کو ROS 2 میسج میں ترجمہ کرتا ہے

### کانٹیکٹ سینسر ٹاپکس

**کانٹیکٹ ایونٹس یہاں شائع ہوتے ہیں:**
```
/bumper
```

**میسج میں شامل ہوتا ہے:**
```
contacts:
  - contact1:
    collision1_name: bumper_collision
    collision2_name: ground_plane::ground_plane_collision
    position: [x, y, z]  # جہاں ٹکراؤ ہوا
```

---

## مشق: اپنے روبوٹ میں IMU شامل کریں

**کام:**
1. پچھلے اسباق سے اپنا روبوٹ SDF استعمال کریں۔
2. `base_link` میں ایک IMU سینسر شامل کریں۔
3. ایکسیلیریومیٹر اور جائیروسکوپ کے شور کو ترتیب دیں۔
4. اپنے روبوٹ کے ساتھ Gazebo لانچ کریں۔
5. تصدیق کریں کہ `/imu` ٹاپک شائع ہو رہا ہے۔
6. اپنے روبوٹ کو گھمائیں اور IMU ویلیوز کو تبدیل ہوتے ہوئے دیکھیں
7. اپنے روبوٹ کو روکیں اور تصدیق کریں کہ ایکسیلیریشن z-axis میں ~9.81 (گریوٹی) ریڈ کر رہا ہے۔

**متوقع نتیجہ**: آپ اپنے روبوٹ کی حرکت کی عکاسی کرنے والا حقیقت پسندانہ IMU ڈیٹا دیکھتے ہیں۔

---

## کوارٹرنیئنز کو سمجھنا (اوریینٹیشن کی ایڈوانس نمائندگی)

IMU ڈیٹا میں اوریینٹیشن ایک **کوارٹرنیئن** کے طور پر شامل ہوتا ہے: (x, y, z, w)

کوارٹرنیئنز 3D میں گردش کو بغیر گیمبل لاک (جو کہ آئلر اینگلز کی ایک حد ہے) کے ظاہر کرتے ہیں۔

**ساکن روبوٹ (کوئی گردش نہیں):**
```
Quaternion: (0, 0, 0, 1)
Euler angles: (0, 0, 0) = roll 0°, pitch 0°, yaw 0°
```

**روبوٹ z-axis کے گرد 90 ڈگری گھمایا گیا:**
```
Quaternion: (0, 0, 0.707, 0.707)  ≈ sin(45°), cos(45°)
Euler angles: (0, 0, 90°) = yaw 90°
```

**تبدیلی** (عام طور پر لائبریریوں کے ذریعے ہینڈل کی جاتی ہے):
```python
import math
from tf_transformations import quaternion_from_euler

roll = 0
pitch = 0
yaw = math.radians(90)  # 90 ڈگری ریڈین میں

quat = quaternion_from_euler(roll, pitch, yaw)
# نتیجہ: (0, 0, 0.707, 0.707)
```

زیادہ تر عملی مقاصد کے لیے، آپ کو کوارٹرنیئن ریاضی کو سمجھنے کی ضرورت نہیں ہے—ROS لائبریریاں تبدیلی کو سنبھالتی ہیں۔ بس یہ جان لیں کہ اوریینٹیشن اس طرح ظاہر کی جاتی ہے۔

---

## عام IMU اور کانٹیکٹ کے مسائل

### مسئلہ 1: IMU بہت زیادہ شور والا ڈیٹا شائع کرتا ہے

**علامت**: IMU ایکسیلیریشن/روٹیشن ویلیوز بے ترتیب طریقے سے بدلتی ہیں

**ممکنہ وجہ:**
- شور کا stddev بہت زیادہ ہے
- سینسر کی تعدد بہت کم ہے (update_rate بہت کم ہے)

**حل:**
1. update_rate بڑھائیں: `<update_rate>200</update_rate>`
2. شور کم کریں: `<stddev>0.01</stddev>` (0.05 سے کم)
3. اپنے نوڈ میں پوسٹ پروسیسنگ (موونگ ایوریج فلٹر) کریں

### مسئلہ 2: کانٹیکٹ سینسر کبھی ٹرگر نہیں ہوتا

**علامت**: روبوٹ دیوار سے ٹکراتا ہے لیکن کوئی کانٹیکٹ میسج نہیں آتا

**ممکنہ وجہ:**
- ٹکراؤ کی شکل SDF میں صحیح طریقے سے متعین نہیں کی گئی
- کانٹیکٹ سینسر غلط ٹکراؤ ہندسیات (geometry) کی نگرانی کر رہا ہے
- ٹکراؤ کا پتہ لگانے کے لیے فزکس انجن میں سیٹنگز درست نہیں ہیں

**حل:**
1. SDF میں تصدیق کریں کہ ٹکراؤ کی شکل موجود ہے
2. سینسر کی تعریف میں ٹکراؤ کے نام کی دوبارہ جانچ کریں
3. فزکس انجن میں ٹکراؤ کا پتہ لگانا فعال کریں

### مسئلہ 3: گریوٹی مسلسل ایکسیلیریومیٹر کو متاثر کرتی ہے

**علامت**: IMU ہمیشہ z-axis میں 9.81 ریڈ کرتا ہے، جس سے حقیقی ایکسیلیریشن کا پتہ لگانا مشکل ہو جاتا ہے

**یہ متوقع ہے!** حقیقی IMUs کو بھی یہ مسئلہ ہوتا ہے۔

**حل:**
- اپنے پروسیسنگ نوڈ میں گریوٹی (9.81) کو z-axis سے گھٹائیں۔
- سینسر فیوژن استعمال کریں: جائیروسکوپ (جس میں گریوٹی نہیں ہوتی) کو ایکسیلیریومیٹر کے ساتھ یکجا کریں۔
- بہت سی روبوٹکس لائبریریاں "IMU فیوژن" فراہم کرتی ہیں جو گریوٹی کو خود بخود ہٹا دیتی ہے۔

---

## توثیق کی فہرست (Validation Checklist)

IMU اور کانٹیکٹ سینسرز شامل کرنے کے بعد:

- [ ] SDF میں IMU سینسر کی تعریف کی گئی ہے
- [ ] Gazebo بغیر کسی خرابی کے لانچ ہوتا ہے
- [ ] `ros2 topic list` میں `/imu` اور `/bumper` (اگر کانٹیکٹ شامل کیا گیا ہے) نظر آتا ہے
- [ ] `ros2 topic echo /imu` روبوٹ کے حرکت کرنے پر تبدیل ہونے والی ویلیوز دکھاتا ہے
- [ ] اوریینٹیشن کوارٹرنیئن ویلیوز سمجھ میں آتی ہیں (ایک ویلیو 1 کے قریب ہونی چاہیے)
- [ ] ساکن ہونے پر ایکسیلیریشن z-axis میں ~9.81 ریڈ کرتا ہے
- [ ] کانٹیکٹ سینسر ٹکراؤ پر ٹرگر ہوتا ہے (اگر کانٹیکٹ شامل کیا گیا ہے)

---

## AI کے ساتھ کوشش کریں

**سیٹ اپ**: اپنے AI اسسٹنٹ کو IMU کنفیگریشن کے مسئلے کے بارے میں بتائیں۔

**پرامپٹ سیٹ:**

```
Prompt 1 (بنیادی): "میں نے اپنے روبوٹ میں ایک IMU شامل کیا ہے۔ یہ base_link پر ہے۔
غیر متوازن زمین پر چلنے والے روبوٹ کے لیے آپ شور کی سطح (stddev) کیا تجویز کریں گے؟ کیا ایکسیلیریومیٹر کے شور کو جائیروسکوپ کے شور سے زیادہ یا کم ہونا چاہیے؟"

Prompt 2 (انٹرمیڈیٹ): "میرے ہیومینوئڈ میں اکثر گرنے کا مسئلہ ہوتا ہے۔
میں چاہتا ہوں کہ IMU گرنے کا پتہ لگائے (ایکسیلیریشن میں اچانک تبدیلی)۔
آپ کون سی IMU اپ ڈیٹ ریٹ تجویز کریں گے؟ 10 Hz، 50 Hz، یا 200 Hz؟"

Prompt 3 (ایڈوانسڈ): "میں روبوٹ کی اوریینٹیشن کا تخمینہ لگانے کے لیے IMU ڈیٹا (ایکسیلیریومیٹر + جائیروسکوپ + میگنیٹومیٹر) کو فیوز کر رہا ہوں۔
انڈور ماحول میں میگنیٹومیٹر میں بہاؤ (drift) آتا ہے۔ کیا مجھے اوریینٹیشن کے تخمینے کے لیے ایکسیلیریومیٹر یا جائیروسکوپ پر زیادہ انحصار کرنا چاہیے؟"
```

**متوقع نتائج:**
- AI حقیقت پسندانہ شور کی سطح تجویز کرتا ہے
- AI اپ ڈیٹ ریٹ اور پروسیسنگ بوجھ کے درمیان سمجھوتے کی وضاحت کرتا ہے
- AI سینسر فیوژن کی حکمت عملیوں کے بارے میں سوچنے میں مدد کرتا ہے

**حفاظتی نوٹ**: سمولیشن میں IMU سینسر مثالی ہوتے ہیں (مثالی شور ماڈلز، کوئی تعصب بہاؤ نہیں)۔ حقیقی IMUs میں درجہ حرارت پر منحصر تعصب، جھٹکے سے پیدا ہونے والی خرابیاں، اور ماحولیاتی حساسیت ہوتی ہے۔ حقیقی روبوٹس پر تعینات کرتے وقت، روبوٹ کے حقیقی آپریٹنگ ماحول میں IMUs کو کیلیبریٹ کریں اور حقیقی ہارڈ ویئر کے ساتھ اپنے سینسر فیوژن الگورتھم کی توثیق کریں۔

**اختیاری توسیع**: ایک ROS 2 نوڈ لکھیں جو `/imu` سنتا ہے، ایکسیلیریومیٹر سے گریوٹی کو ہٹاتا ہے، اور اچانک اثرات (20 m/s² سے زیادہ ایکسیلیریشن میگنیٹیوڈ) کا پتہ لگاتا ہے۔ یہ ہیومینوئڈ روبوٹس میں فال ڈیٹیکشن کی بنیاد ہے۔